const arrayData = [
    {
      "script": "/* This script parses the active connection info from linux\n *\n * Example of linux active connections\n\nProto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name\ntcp        0      0 127.0.0.1:2208              0.0.0.0:*                   LISTEN      2261/hpiod\ntcp        0      0 0.0.0.0:111                 0.0.0.0:*                   LISTEN      2038/portmap\ntcp        0      0 0.0.0.0:977                 0.0.0.0:*                   LISTEN      2067/rpc.statd\ntcp        0      0 127.0.0.1:2207              0.0.0.0:*                   LISTEN      2266/python\ntcp        0      0 10.196.39.213:111           10.255.31.44:699            ESTABLISHED 2038/portmap\ntcp        1      0 10.196.39.213:1850          10.196.39.217:9082          CLOSE_WAIT  1327/httpd\n...\n */\n\nvar DiscoveryNetstatParser = Class.create();\nDiscoveryNetstatParser.prototype = {\n\tinitialize: function() {\n\t},\n\t\n\tparse: function(output) {\n\t\tthis.tcp = [];\n\t\tthis.isValid = true;\n\t\tthis.errorString = '';\n\t\t\n\t\tvar lines = output.split(/\\n/);\n\t\t\n\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tif (JSUtil.nil(line)) {\n\t\t\t\tif (i != lines.length - 1)\n\t\t\t\t\tthis.error('Empty line in netstat output, line: ' + (i + 1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvar parts = line.split(/\\s+/);\n\t\t\tif (parts.length < 7 || !parts[0].startsWith(\"tcp\"))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvar local = parts[3];\n\t\t\tif(JSUtil.nil(local))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(local.toLowerCase().indexOf(\"::ffff:\") === 0)\n\t\t\t\tlocal = local.substring(7);\n\t\t\t\n\t\t\tvar ipPortMap = this.parseAddress(local);\n\t\t\tif(ipPortMap == null)\n\t\t\t\tcontinue;\n\t\t\tvar localIP = ipPortMap[\"ip\"];\n\t\t\tvar localPort = ipPortMap[\"port\"];\n\t\t\t\n\t\t\tvar remote = parts[4];\n\t\t\tif(JSUtil.nil(remote) && (state == \"ESTABLISHED\" || state == \"TIME_WAIT\" || state == \"CLOSE_WAIT\"))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(!JSUtil.nil(remote) && remote.toLowerCase().indexOf(\"::ffff:\") === 0)\n\t\t\t\tremote = remote.substring(7);\n\t\t\t\n\t\t\tvar remoteIP = remote.split(\":\")[0];\n\t\t\tvar remotePort = remote.split(\":\")[1];\n\t\t\t\n\t\t\tvar state = parts[5];\n\t\t\tif(JSUtil.nil(state))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvar pidProg = parts[6];\n\t\t\tif(JSUtil.nil(pidProg))\n\t\t\t\tcontinue;\n\t\t\tvar pid = parseInt(pidProg.split(\"/\")[0]);\n\t\t\tif (isNaN(pid)) {\n\t\t\t\tthis.error('Invalid PID: ' + pid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\tpid = \"\"+pid;\n\t\t\t\n\t\t\tvar connection =  {};\n\t\t\tif (state == \"LISTEN\") {\n\t\t\t\tconnection.type = \"on\";\n\t\t\t\tconnection.ip = localIP;\n\t\t\t\tconnection.port = localPort;\n\t\t\t\tconnection.pid = pid;\n\t\t\t\tthis.tcp.push(connection);\n\t\t\t} else if (state == \"ESTABLISHED\" || state == \"TIME_WAIT\" || state == \"CLOSE_WAIT\") {\n\t\t\t\tconnection.type = \"to\";\n\t\t\t\tconnection.ip = remoteIP;\n\t\t\t\tconnection.port = remotePort;\n\t\t\t\tconnection.pid = pid;\n\t\t\t\tconnection.local_ip = localIP;\n\t\t\t\tconnection.local_port = localPort;\n\t\t\t\tthis.tcp.push(connection);\n\t\t\t}\n\t\t}\n\t\t\n\t},\n\t\n\tparseAddress: function(address){\n\t\tvar ip;\n\t\tvar port;\n\t\t\n\t\tvar parts = /([^\\]]+):([0-9]+)/.exec(address);\n\t\tif(!parts || parts.length != 3)\n\t\t\treturn null;\n\t\t\n\t\tport = Number(parts[2]);\n\t\tif (isNaN(port))\n\t\t\treturn null;\n\t\telse\n\t\t\tport = \"\"+port;\n\t\t\n\t\tif(parts[1] == \"::1\")\n\t\t\tip = \"127.0.0.1\";\n\t\telse {\n\t\t\tip = parts[1];\n\t\t\t\n\t\t\tif (parts[1] == '*' || !SncIPAddressV4.getIPAddressV4Instance(parts[1]) || parts[1] == \"::\")\n\t\t\t\tip = '0.0.0.0';\n\t\t}\n\t\t\n\t\tif(!ip || !port)\n\t\t\treturn null;\n\t\t\n\t\tvar ipPortMap = {};\n\t\tipPortMap[\"ip\"] = ip;\n\t\tipPortMap[\"port\"] = port;\n\t\treturn ipPortMap;\n\t\t\n\t},\n\t\n\terror: function(msg) {\n\t\tthis.isValid = false;\n\t\tif (!JSUtil.nil(this.errorString))\n\t\t\tthis.errorString += '\\n';\n\t\tthis.errorString += msg;\n\t},\n\t\n\tgetConnections: function(){\n\t\treturn JSON.stringify(this.tcp);\n\t},\n\t\n\tgetError: function(){\n\t\treturn this.errorString;\n\t},\n\t\n\tgetIsValid: function(){\n\t\treturn this.isValid;\n\t},\n\t\n\ttype: 'DiscoveryNetstatParser'\n};",
      "sys_id": "01d84eb60b22101088b90bdb35673af0"
    },
    {
      "script": "var GenerateWQLScriptJS = Class.create();\n\nGenerateWQLScriptJS.prototype = {\n\n    initialize : function(namespace, wql) {\n        this.namespace = namespace;\n        this.wql = wql;\n    },\n\n    generateScript: function() {\n\t\tvar scriptValue = \"var scanner = getScanner();\\n\" +\n\t\t\t\t\t\t  \"if (scanner) {\\n\" +\n\t\t\"   scanner.wmiQuery('\" + this.namespace + \"', '\" + this.wql + \"');\\n\" +\n \t\t\t\t\t\t \"}\\n\";\n\t\treturn scriptValue;\n    },\n\n    type: \"GenerateWQLScriptJS\"\n}",
      "sys_id": "157e428fc3023100d8d4bea192d3aefa"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n\nvar StandaloneESXProbe = Class.create();\n\n(function() {\n\nvar _this,\n\toutput = { },\n\tresourceMap = {\n\t\tname: 'name'\n\t},\n\tcomputeMap = {\n\t\thost: [ { name: 'name' } ],\n\t\tresourcePool: resourceMap\n\t};\n\nresourceMap.resourcePool = [ resourceMap ];\n\n//////////////////////////////////////////////////////////////////////////\nStandaloneESXProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\nprocess : function() {\n\tvar name, dcs,\n\t\tvc = new Packages.com.service_now.mid.util.VersionComparator(),\n\t\tvSphereApiVersion = '4.1',\n\t\tmors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\tmorMap = { };\n\n\tif (!this.serviceInstance)\n\t\treturn;\n\n        this.debug('Starting ESX Sever discovery...');\n\t_this = this;\n\n\t// Get information about the esx server\n\toutput.esx = fetchESXServer();\n\n\t// Error if ESX version is too old.\n\tif (vc.compare(vSphereApiVersion, output.esx.version) < 0) {\n\t\tthis.setError(\"ESX version \" + output.esxServer.version + \" is not supported.  Only \" + vSphereApiVersion + \" or newer is supported\");\n\t\treturn;\n\t}\n\tdcs = this.fetchManagedObjects('Datacenter', {\n\t\tname: 'name',\n\t\tvmFolder: 'folder_morid',\n\t\thostFolder: 'host_morid'\n\t});\n\tif (mors) {\n\t\toutput.esxdc = [ ];\n\t\tmors.forEach(function(mor) { morMap[mor.morid] = 1; });\n\t\tdcs.forEach(function(dc) { if (morMap[dc.morid]) output.esxdc.push(dc); });\n\t} else\n\t\toutput.esxdc = dcs;\n\n\t// Now get the list of objects that exist in ESX Server\n\toutput.esxdc.forEach(\n\t\tfunction(dc) {\n\t\t\tdc.folders = walkFolderTrees(dc.mo, {\n\t\t\t\tname: 'name',\n\t\t\t\tdatastoreFolder: { name: 'name' },\n\t\t\t\thostFolder: { name: 'name' },\n\t\t\t\tnetworkFolder: { name: 'name' },\n\t\t\t\tvmFolder: { name: 'name' }\n\t\t\t});\n\t\t});\n\tgetHosts(output.esxdc);\n\n\t// Stringify the results, dropping anything named 'mo' (these are vijava ManagedObjects)\n\tthis.output = JSON.stringify(output, function(key, value) { if (key != \"mo\") return value; });\n},\n\n\ttype : 'StandaloneESXProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction getHosts(esxs) {\n\n\tvar clusters = [ ],\n\t\thosts = [ ],\n\t\tpools = [ ];\n\n\toutput.hosts = hosts;\n\tesxs.forEach(\n\t\tfunction(esx) {\n\t\t\textractClusters(esx.folders.hostFolder);\n\t\t});\n\tclusters.forEach(\n\t\tfunction(cluster) {\n\t\t\tcluster.host && cluster.host.forEach(\n\t\t\t\tfunction(host) {\n\t\t\t\t\thosts.push(host.morid);\n\t\t\t\t});\n\n\t\t\textractPools(cluster.resourcePool);\n\t\t});\n\n\toutput.pools = pools;\n\tfunction extractPools(pool) {\n\t\tif (pool) {\n\t\t\tpools.push(pool.morid);\n\t\t\tpool.resourcePool.forEach(\n\t\t\t\tfunction(pool) {\n\t\t\t\t\textractPools(pool);\n\t\t\t\t});\n\t\t}\n\t}\n\n\tfunction extractClusters(folder) {\n\t\tfolder.childEntity.forEach(function (child) {\n\t\t\tif (child.type == 'Folder')\n\t\t\t\textractClusters(child);\n\t\t\telse\n\t\t\t\tclusters.push(_this.getPropsForManagedObject(child.mo, computeMap));\n\t\t});\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fetchESXServer() {\n\tvar dm = {\n\t\t'content.about.name': 'name',\n\t\t'content.about.version': 'version',\n\t\t'content.about.fullName': 'fullname',\n\t\t'content.about.apiVersion': 'api_version'\n\t},\n\tesxServer = _this.getPropsForManagedObject(_this.serviceInstance, dm);\n\tesxServer.url = '' + _this.serverConnection.getUrl();\n\treturn esxServer;\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction walkFolderTrees(root, dataMap) {\n\tvar name, vms,\n\tfolders = _this.getPropsForManagedObject(root, dataMap);\n\tfor (name in dataMap) {\n\t\tif (name == 'propNames')\n\t\t\tcontinue;\n\t\tfolders[name].childEntity = walkFolderTree(folders[name].mo);\n\t}\n\n\treturn folders;\n\n\tfunction walkFolderTree(root) {\n\t\tvar childEntity = { childEntity: [ { name: 'name' } ] },\n\t\t\tfolder = _this.getPropsForManagedObject(root, childEntity),\n\t\t\tnewChildren = [ ];\n\n\t\tfolder.childEntity.forEach(\n\t\t\tfunction(child) {\n\t\t\t\tif (child.type != 'VirtualApp')\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\tif (child.type == 'Folder' || child.type == 'StoragePod')\n\t\t\t\t\tchild.childEntity = walkFolderTree(child.mo);\n\t\t\t\telse if (child.type == 'VirtualApp')\n\t\t\t\t\twalkVirtualAppTree(child, newChildren);\n\t\t\t});\n\n\t\treturn newChildren;\n    }\n\n\tfunction walkVirtualAppTree(root, parentChildren) {\n\t\tvar childEntity = { resourcePool: [ { } ], vm: [ { name: 'name' } ]},\n\t\t\tvirtualApp = _this.getPropsForManagedObject(root.mo, childEntity);\n\t\tvirtualApp.resourcePool.forEach(\n\t\t\tfunction(child) {\n\t\t\t\tchild.childEntity = walkVirtualAppTree(child, parentChildren);\n\t\t\t}\n\t\t);\n\t\tvirtualApp.vm.forEach(\n\t\t\tfunction(child) {\n\t\t\t\tparentChildren.push(child);\n\t\t\t}\n\t\t);\n\t}\n}\n\n})();",
      "sys_id": "17db143bc7121010f580178603c2601f"
    },
    {
      "script": "ms.include(\"PrototypeServer\");\n\nvar JSON = Class.create();\n\n// Ported from the YUI library's json-parse shim code (BSD licensed).\n// http://yuilibrary.com/yui/docs/api/files/json_js_parse-shim.js.html\nJSON._UNSAFE = /[^\\],:{}\\s]/;\nJSON._BRACKETS = /(?:^|:|,)(?:\\s*\\[)+/g;\nJSON._VALUES = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nJSON._ESCAPES = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nJSON._UNICODE_EXCEPTIONS = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n/**\n * Encodes a JS object into string JSON.\n * @param {} obj\n * @return string The JSON string\n */\nJSON.stringify = function(obj, replacer) {\n\tif (typeof JSON._singleton === 'undefined')\n\t\tJSON._singleton = new JSON();\n\t\n\treturn JSON._singleton.encode(obj, replacer);\n};\n\n/**\n * Parses a JSON string and returns the parsed JS data.\n * @param string json\n * @return {}\n * @throws Error On Invalid or illegal JSON format\n */\nJSON.parse = function(json) {\n\tjson = '' + json;\n\tjson = json.replace(JSON._UNICODE_EXCEPTIONS, JSON._escapeException);\n\t\n\t// create a filtered string for validity testing\n\tvar filtered = json.replace(JSON._ESCAPES, '@')\n\t.replace(JSON._VALUES, ']')\n\t.replace(JSON._BRACKETS, '');\n\t\n\t// throw an exception if the filtered string is unsafe\n\tif (JSON._UNSAFE.test(filtered))\n\t\tthrow 'JSON.parse';\n\t\n\t// evaluate and return the json object\n\tvar obj = eval('(' + json + ')');\n\treturn obj;\n};\n\nJSON._escapeException = function(c) {\n\treturn '\\\\u'+('0000'+(+(c.charCodeAt(0))).toString(16)).slice(-4);\n};\n\nJSON.prototype = {\n  sChars: {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\"' : '\\\\\"',\n            '\\\\': '\\\\\\\\'\n  },\n\n  initialize: function() {\n\n  },\n\n  pad: function(n) {\n        return n < 10 ? \"0\" + n : n;\n  },\n    \n  encodeString: function(s){\n        s = '' + s;\n        if (/[\"\\\\\\x00-\\x1f]/.test(s)) {\n            return '\"' + s.replace(/([\\x00-\\x1f\\\\\"])/g, function(a, b) {\n                var c = JSON.prototype.sChars[b];\n                if(c){\n                    return c;\n                }\n                c = b.charCodeAt();\n                return \"\\\\u00\" +\n                    Math.floor(c / 16).toString(16) +\n                    (c % 16).toString(16);\n            }) + '\"';\n        }\n        return '\"' + s + '\"';\n  },\n    \n  encodeArray: function(o, replacer){\n        var a = [\"[\"], b, i, l = o.length, v;\n            for (i = 0; i < l; i += 1) {\n                v = o[i];\n\n\t\t\t\tif (replacer)\n\t\t\t\t\tv = replacer(i, v);\n\n\t\t\t\tswitch (typeof v) {\n                    case \"undefined\":\n                    case \"function\":\n                    case \"unknown\":\n                        break;\n                    default:\n                        if (b) {\n                            a.push(',');\n                        }\n                        a.push(v === null ? \"null\" : this.encode(v, replacer));\n                        b = true;\n                }\n            }\n            a.push(\"]\");\n            return a.join(\"\");\n  },\n\n  encodeObject: function(o, replacer) {\n    var a = [\"{\"], b, i, v;\n\n    for (i in o) {\n        if(o.hasOwnProperty(i)) {\n            v = o[i];\n\t\t\t\n\t\t\tif (replacer)\n\t\t\t\tv = replacer(i, v);\n\n            switch (typeof v) {\n                case \"undefined\":\n                case \"function\":\n                case \"unknown\":\n                     break;\n                default:\n                     if (b) {\n                         a.push(',');\n                     }\n                     a.push(this.encode(i), \":\", v === null ? \"null\" : this.encode(v, replacer));\n                     b = true;\n            }\n        }\n    }\n\n    a.push(\"}\");\n    return a.join(\"\");\n  },\n    \n  encodeDate: function(o){\n        return '\"' + o.getFullYear() + \"-\" +\n                this.pad(o.getMonth() + 1) + \"-\" +\n                this.pad(o.getDate()) + \"T\" +\n                this.pad(o.getHours()) + \":\" +\n                this.pad(o.getMinutes()) + \":\" +\n                this.pad(o.getSeconds()) + '\"';\n  },\n\n  encode: function(o, replacer) {\n\t  \n        if (typeof o == \"undefined\" || o === null) {\n            return \"null\";\n        } else if (o instanceof Array) {\n            return this.encodeArray(o, replacer);\n        } else if (o instanceof Date) {\n            return this.encodeDate(o);\n        } else if (typeof o == \"string\" || o instanceof String) {\n            return this.encodeString(o);\n        } else if (typeof o == \"number\") {\n            return isFinite(o) ? String(o) : \"null\";\n        } else if (typeof o == \"boolean\") {\n            return String(o);\n        } else {\n            return this.encodeObject(o, replacer);\n        }\n  },\n\n  decode: function(source, reviver) {\n      var parser = new JSONParser();\n      return parser.parse(source, reviver);\n  },\n\n  type: \"JSON\"\n}",
      "sys_id": "1d53c9680a0a0b84148db3d4e1dceda3"
    },
    {
      "script": "/**\r\n * Parses JSON string to javascript object\r\n * \r\n * Created by Chase Solaegui and modified by Aleck Lin\r\n */\r\n\r\nvar JSONParser = Class.create();\r\n\r\nJSONParser.prototype = {\r\n    initialize : function() {\r\n    },\r\n    \r\n    parse: function (source, reviver) {\r\n        if (JSUtil.nil(source))\r\n            return;\r\n\r\n        return this.jsonParse(source, reviver);\r\n    },\r\n\r\n    /*\r\n     *  This is a modified JSON parser found in http://code.google.com/p/json-sans-eval/.\r\n     */\r\n\tjsonParse: function(json, opt_reviver) {\r\n\t  var number  = '(?:-?\\\\b(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\\\b)';\r\n\t  var oneChar = '(?:[^\\\\0-\\\\x08\\\\x0a-\\\\x1f\\\"\\\\\\\\]' + '|\\\\\\\\(?:[\\\"/\\\\\\\\bfnrt]|u[0-9A-Fa-f]{4}))';\r\n\t  var string = '(?:\\\"' + oneChar + '*\\\")';\r\n\t\r\n\t  // Will match a value in a well-formed JSON file.\r\n\t  // If the input is not well-formed, may match strangely, but not in an unsafe\r\n\t  // way.\r\n\t  // Since this only matches value tokens, it does not match whitespace, colons,\r\n\t  // or commas.\r\n\t  var jsonToken = new RegExp(\r\n\t      '(?:false|true|null|[\\\\{\\\\}\\\\[\\\\]]'\r\n\t      + '|' + number\r\n\t      + '|' + string\r\n\t      + ')', 'g');\r\n\t\r\n\t  // Matches escape sequences in a string literal\r\n\t  var escapeSequence = new RegExp('\\\\\\\\(?:([^u])|u(.{4}))', 'g');\r\n\t\r\n\t  // Decodes escape sequences in object literals\r\n\t  var escapes = {\r\n\t    '\"': '\"',\r\n\t    '/': '/',\r\n\t    '\\\\': '\\\\',\r\n\t    'b': '\\b',\r\n\t    'f': '\\f',\r\n\t    'n': '\\n',\r\n\t    'r': '\\r',\r\n\t    't': '\\t'\r\n\t  };\r\n\t\r\n\t  return run(json, opt_reviver);\r\n\t\r\n\t  function unescapeOne(_, ch, hex) {\r\n\t    return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));\r\n\t  }\r\n\t\r\n\t  // A non-falsy value that coerces to the empty string when used as a key.\r\n\t  var EMPTY_STRING = new String('');\r\n\t  var SLASH = '\\\\';\r\n\t\r\n\t  // Constructor to use based on an open token.\r\n\t  var firstTokenCtors = { '{': Object, '[': Array };\r\n\t\r\n\t  var hop = Object.hasOwnProperty;\r\n\t\r\n\t  function run(json, opt_reviver) {\r\n\t    // Split into tokens\r\n\t    var toks = json.match(jsonToken);\r\n\t    // Construct the object to return\r\n\t    var result;\r\n\t    var tok = toks[0];\r\n\t    var topLevelPrimitive = false;\r\n\t    if ('{' === tok) {\r\n\t      result = {};\r\n\t    } else if ('[' === tok) {\r\n\t      result = [];\r\n\t    } else {\r\n\t      // The RFC only allows arrays or objects at the top level, but the JSON.parse\r\n\t      // defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null\r\n\t      // at the top level.\r\n\t      result = [];\r\n\t      topLevelPrimitive = true;\r\n\t    }\r\n\t\r\n\t    // If undefined, the key in an object key/value record to use for the next\r\n\t    // value parsed.\r\n\t    var key;\r\n\t    // Loop over remaining tokens maintaining a stack of uncompleted objects and\r\n\t    // arrays.\r\n\t    var stack = [result];\r\n\t    for (var i = 1 - topLevelPrimitive, n = toks.length; i < n; ++i) {\r\n\t      tok = toks[i];\r\n\t\r\n\t      var cont;\r\n\t      switch (tok.charCodeAt(0)) {\r\n\t        default:  // sign or digit\r\n\t          cont = stack[0];\r\n\t          cont[key || cont.length] = +(tok);\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x22:  // '\"'\r\n\t          tok = tok.substring(1, tok.length - 1);\r\n\t          if (tok.indexOf(SLASH) !== -1) {\r\n\t            tok = tok.replace(escapeSequence, unescapeOne);\r\n\t          }\r\n\t          cont = stack[0];\r\n\t          if (!key) {\r\n\t            if (cont instanceof Array) {\r\n\t              key = cont.length;\r\n\t            } else {\r\n\t              key = tok || EMPTY_STRING;  // Use as key for next value seen.\r\n\t              break;\r\n\t            }\r\n\t          }\r\n\t          cont[key] = tok;\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x5b:  // '['\r\n\t          cont = stack[0];\r\n\t          stack.unshift(cont[key || cont.length] = []);\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x5d:  // ']'\r\n\t          stack.shift();\r\n\t          break;\r\n\t        case 0x66:  // 'f'\r\n\t          cont = stack[0];\r\n\t          cont[key || cont.length] = false;\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x6e:  // 'n'\r\n\t          cont = stack[0];\r\n\t          cont[key || cont.length] = null;\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x74:  // 't'\r\n\t          cont = stack[0];\r\n\t          cont[key || cont.length] = true;\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x7b:  // '{'\r\n\t          cont = stack[0];\r\n\t          stack.unshift(cont[key || cont.length] = {});\r\n\t          key = void 0;\r\n\t          break;\r\n\t        case 0x7d:  // '}'\r\n\t          stack.shift();\r\n\t          break;\r\n\t      }\r\n\t    }\r\n\t    // Fail if we've got an uncompleted object.\r\n\t    if (topLevelPrimitive) {\r\n\t      if (stack.length !== 1) { throw new Error(); }\r\n\t      result = result[0];\r\n\t    } else {\r\n\t      if (stack.length) { throw new Error(); }\r\n\t    }\r\n\t\r\n\t    if (opt_reviver) {\r\n\t      // Based on walk as implemented in http://www.json.org/json2.js\r\n\t      var walk = function (holder, key) {\r\n\t        var value = holder[key];\r\n\t        if (value && typeof value === 'object') {\r\n\t          var toDelete = null;\r\n\t          for (var k in value) {\r\n\t            if (hop.call(value, k) && value !== holder) {\r\n\t              // Recurse to properties first.  This has the effect of causing\r\n\t              // the reviver to be called on the object graph depth-first.\r\n\t\r\n\t              // Since 'this' is bound to the holder of the property, the\r\n\t              // reviver can access sibling properties of k including ones\r\n\t              // that have not yet been revived.\r\n\t\r\n\t              // The value returned by the reviver is used in place of the\r\n\t              // current value of property k.\r\n\t              // If it returns undefined then the property is deleted.\r\n\t              var v = walk(value, k);\r\n\t              if (v !== void 0) {\r\n\t                value[k] = v;\r\n\t              } else {\r\n\t                // Deleting properties inside the loop has vaguely defined\r\n\t                // semantics in ES3 and ES3.1.\r\n\t                if (!toDelete) { toDelete = []; }\r\n\t                toDelete.push(k);\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t          if (toDelete) {\r\n\t            for (var i = toDelete.length; --i >= 0;) {\r\n\t              delete value[toDelete[i]];\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return opt_reviver.call(holder, key, value);\r\n\t      }\r\n\t      result = walk({ '': result }, '');\r\n\t    }\r\n\t\r\n\t    return result;\r\n\t  }\r\n\t},\r\n\r\n}\r\n\r\n\r\n\r\n\r\n",
      "sys_id": "1d548db90a0a0b843717527b8eebc621"
    },
    {
      "script": "/**\n * JavaScript utility functions.\n * \n * Tom Dilatush tom.dilatush@service-now.com\n */\nvar JSUtil = Class.create();\n\n/*\n * Returns true if the given item is not null and is not undefined.\n */\nJSUtil.has = function(item) {\n    return (item != null) && (typeof item != 'undefined');\n}\n\n/*\n * Returns true if the given item is null or is undefined (the logical inverse of .has(), above).\n */\nJSUtil.doesNotHave = function(item) {\n    return !JSUtil.has(item);\n}\n\n/*\n * Returns true if the given item is null, undefined, or evaluates to the empty string.\n */\nJSUtil.nil = function(item) {\n    if (JSUtil.isJavaObject(item))\n        return (item.toString() == null) || (item.toString() == '');\n\n    return (item == null) || (typeof item == 'undefined') || ('' == '' + item);\n}\n\n/*\n * Returns true if the given item exists and is not empty (the logical inverse of .nil(), above).\n */\nJSUtil.notNil = function(item) {\n    return !JSUtil.nil(item);\n}\n\n/*\n *  Returns true if item is defined but has no properties or functions. (handy for associative arrays)\n */\nJSUtil.isEmpty = function(item) {\n    var result=false;\n    if (JSUtil.notNil(item)) {\n        result=true;\n        for (var i in item) {\n            result=false;\n            break;\n        }\n    }\n    return result;\n}\t\n\t\n/*\n * Returns true if the given item is a member of the given class.  For JavaScript objects, this method behaves exactly\n * like the JavaScript operator \"instanceof\".  However, this method (unlike the JavaScript operator) also tests Java\n * objects.\n * \n * item: the object to be tested.\n * klass: the class to be tested (for Java objects, must be the complete class name, like \"java.util.ArrayList\").\n */\nJSUtil.instance_of = function(item, klass) {\n    if (item == null)\n        return false;\n    if (!klass)\n        return false;\n    if (typeof item != 'object')\n        return false;\n    if (typeof item.getClass() == 'undefined')\n        if (klass.indexOf('.') < 0)\n            return eval('(item instanceof ' + klass + ')');\n        else\n            return false;\n    return item.getClass().getName() == klass;\n}\n\n/*\n * Returns the type of the given value as a string, as follows:\n *   'null'     if the given value is null or undefined\n *   'string'   if the given value is a primitive string or a String wrapper instance\n *   'number'   if the given value is a primitive number or a Number wrapper instance\n *   'boolean'  if the given value is a primitive boolean or a Boolean wrapper instance\n *   'function' if the given value is a function\n *   'object'   otherwise\n */\nJSUtil.type_of = function(value) {\n    if (value == null)\n        return 'null';\n        \n    var t = typeof value;\n    if ((t == 'string') || (t == 'number') || (t == 'boolean') || (t == 'function'))\n        return t;\n        \n    if (value instanceof String)\n        return 'string';\n        \n    if (value instanceof Number)\n        return 'number';\n        \n    if (value instanceof Boolean)\n        return 'boolean';\n        \n    return t;\n}\n\n/*\n * Returns true if the given value is an instance of a Java object.\n */\nJSUtil.isJavaObject = function(value) {\n    if (value == null)\n        return false;\n        \n    if (typeof value != 'object')\n        return false;\n        \n    if (typeof value.hashCode != 'function')\n        return false;\n        \n    if (typeof value.equals != 'function')\n        return false;\n        \n    if (typeof value.getClass != 'function')\n        return false;\n        \n    if (typeof value.notify != 'function')\n        return false;\n        \n    if (typeof value.notifyAll != 'function')\n        return false;\n        \n    if (typeof value.toString != 'function')\n        return false;\n        \n    return true;\n}\n\n/*\n * Coerces the given item to a boolean.  If the given item is a boolean, it is passed through.  Non-zero numbers return true.  Null or\n * undefined returns false.  Strings return true only if exactly equal to 'true'.  \n */\nJSUtil.toBoolean = function(item) {\n    if (!JSUtil.has(item))\n        return false;\n        \n    if (typeof item == 'boolean')\n        return item;\n        \n    if (typeof item == 'number')\n        return item != 0;\n        \n    if ((typeof item == 'string') || ((typeof item == 'object') && (item instanceof String)))\n        return item == 'true';\n        \n    // if we get here then we've got either a non-String object or a function; always return true for these...\n    return true;\n}\n\n/*\n * Returns the value in a boolean GlideRecord field.\n */\nJSUtil.getBooleanValue = function(gr, field) {\n    var val = gr.getValue(field);\n    return (val == 'true') || (val == '1');\n}\n\n/*\n * Logs all the properties in the given object: name, type, and value.  The optional second parameter is a name for the logged object.\n */\nJSUtil.logObject = function(obj, name) {\n    ms.log('Log Object' + ((name) ? ': ' + name : ''));\n    if (typeof obj != 'object' || obj == null) {\n        ms.log('  null, undefined, or not an object');\n        return;\n    }\n    // protect against recursive data structures...\n    this.log_levels = 0;\n    JSUtil._logObject(obj, null, '  ');\n}\n\n/*\n * Internal recursive object logger.\n */\nJSUtil._logObject = function(obj, name, lead) {\n    this.log_levels++;\n    if (this.log_levels > 25) {\n        this.log_level--;\n        ms.log(lead + '<<< recursion levels exceeded 25, ignoring >>>');\n        return;\n    }\n    var value = obj;\n    var type = JSUtil.type_of(value);\n    if (type == 'object') {\n        var ns = (name == null) ? '' : name + ': ';\n        if (value instanceof Array) {\n            ms.log(lead + ns + 'Array of ' + value.length + ' elements');\n            for (var i = 0; i < value.length; i++) {\n                var ae = value[i];\n                JSUtil._logObject(ae, '[' + i + ']', lead + '  ');\n            }\n        }\n        else {\n            if (JSUtil.isJavaObject(obj))\n                ms.log(lead + ns + 'Java Object');\n            else {\n                ms.log(lead + ns + 'Object');\n                for (var name in obj) {\n                    JSUtil._logObject(obj[name], name, '  ' + lead);\n                }\n            }\n        }\n    }\n    else \n        ms.log(lead + name + ': ' + type + '; ' + value);\n    this.log_levels--;\n}\n\n/**\n * Determines whether a value exists within an object or not.\n * @param {} container The haystack to search within.\n * @param {} value The expected needle value to compare against.\n * @param boolean|undefined strictCompare If true, uses === for comparison; == otherwise.\n * @return True if value exists in container, False otherwise.\n */\nJSUtil.contains = function(container, value, strictCompare) {\n\tif (strictCompare) {\n\t\t// strict equality\n\t\tfor (var key in container) {\n\t\t\tif (container[key] === value)\n\t\t\t\treturn true;             \n\t\t}\n\t} else {\n\t\t// equality\n\t\tfor (var key in container) {\n\t\t\tif (container[key] == value)\n\t\t\t\treturn true;             \n\t\t}\t\n\t}\n\t\n    return false;\n};\n\t\n/*\n * NOTE: between this banner and the following banner, several string literals are specified in an odd way: by the contatenation of a single\n *       character ('&') and the remainder of the HTML entity (such as 'amp;').  This method was employed to avoid having the entities translated \n *       into the equivalent characters when the script include is edited in the instance.\n */\nJSUtil.AMP     = /\\&/g;\nJSUtil.GT      = /\\>/g;\nJSUtil.LT      = /\\</g;\nJSUtil.QT      = /\\\"/g;\nJSUtil.AMP_ENT = new RegExp( '\\\\&' + 'amp;',  'g' );\nJSUtil.GT_ENT  = new RegExp( '\\\\&' + 'gt;',   'g' );\nJSUtil.LT_ENT  = new RegExp( '\\\\&' + 'lt;',   'g' );\nJSUtil.QT_ENT  = new RegExp( '\\\\&' + 'quot;', 'g' );\n\nJSUtil.escapeText = function(text) {\n    var result = ('' + text).replace(JSUtil.AMP, '&' + 'amp;');\n    result = result.replace(JSUtil.LT, '&' + 'lt;');\n    return result.replace(JSUtil.GT, '&' + 'gt;');\n}\n\nJSUtil.unescapeText = function(text) {\n    var result = ('' + text).replace(JSUtil.GT_ENT, '>');\n    result = result.replace(JSUtil.LT_ENT, '<');\n    return result.replace(JSUtil.AMP_ENT, '&');\n}\n\nJSUtil.escapeAttr = function(attr) {\n    var result = ('' + attr).replace(JSUtil.AMP, '&' + 'amp;');\n    return result.replace(JSUtil.QT, '&' + 'quot;');\n}\n\nJSUtil.unescapeAttr = function(attr) {\n    var result = ('' + attr).replace(JSUtil.QT_ENT, '\"');\n    return result.replace(JSUtil.AMP_ENT, '&');\n}\n/*\n * End of odd string construction...\n */\n\nJSUtil.prototype = {\n    type: \"JSUtil\"\n};",
      "sys_id": "1d5557480a0a0b84026940e176f072e9"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n\nvar VMWarevCenterClusterDRSProbe = Class.create();\n\n(function() {\n\n\tvar _this,\n\t\thostGroups = [],\n\t\tvmGroups = [],\n\t\tvmHostRules = [],\n\t\tvmAffinityRules = [];\n\n\t//////////////////////////////////////////////////////////////////////////\n\tVMWarevCenterClusterDRSProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n\t\tprocess: function() {\n\t\t\tvar leftOverMors = JSON.parse('' + probe.getParameter('clusters')),\n\t\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\t\t// Average measured size of a cluster with associated hosts and resource\n\t\t\t\t// pools is 600 bytes.  Default page size of 1000 leaves us well below\n\t\t\t\t// the 5 MB limit.\n\t\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 1000,\n\t\t\t\tclusterMorIds = leftOverMors.splice(0, pageSize),\n\t\t\t\toriginalData = [],\n\t\t\t\tresults = {\n\t\t\t\t\thostGroups: hostGroups,\n\t\t\t\t\tvmGroups: vmGroups,\n\t\t\t\t\tvmHostRules: vmHostRules,\n\t\t\t\t\tvmAffinityRules: vmAffinityRules\n\t\t\t\t},\n\t\t\t\tclusterMap = {\n\t\t\t\t\t//This block fetches the DRS settings for the cluster and the VMs that override the cluster DRS behaviour.\n\t\t\t\t\t//This also fetches the 'VM-Host Rules' & 'VM-Affinity Rules' from VMWare\n\t\t\t\t\tconfigurationEx: {\n\t\t\t\t\t\trule: [{\n\t\t\t\t\t\t\truleUuid: 'rule_uuid',\n\t\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\t\tenabled: 'active',\n\t\t\t\t\t\t\tmandatory: 'mandatory',\n\t\t\t\t\t\t\taffineHostGroupName: 'affineHostGroupName',\n\t\t\t\t\t\t\tantiAffineHostGroupName: 'antiAffineHostGroupName',\n\t\t\t\t\t\t\tvmGroupName: 'vm_group',\n\t\t\t\t\t\t\tvm: [ { } ]\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tgroup: [{\n\t\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\t\thost: [{}],\n\t\t\t\t\t\t\tvm: [ { } ]\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tdataMap = {\n\t\t\t\t\tClusterComputeResource: clusterMap\n\t\t\t\t},\n\t\t\t\tfixers = {\n\t\t\t\t\tClusterComputeResource: fixCluster\n\t\t\t\t};\n\n\t\t\tif (!this.serviceInstance)\n\t\t\t\treturn;\n\n\t\t\t_this = this;\n\n\t\t\t// Iterate over the MOR IDs of clusters we're going to explore\n\t\t\tclusterMorIds.forEach(\n\t\t\t\tfunction(cluster) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar table,\n\t\t\t\t\t\t\tclusterType = cluster.type,\n\t\t\t\t\t\t\tmor = new vim25.ManagedObjectReference();\n\n\t\t\t\t\t\t// Create a managed object for the current cluster, fetch data for it and its\n\t\t\t\t\t\t// resource pools from vCenter.\n\t\t\t\t\t\t// The \"cluster\" may be a ComputeResource or a ClusterComputerResource.\n\t\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp?topic=%2Fcom.vmware.wssdk.apiref.doc%2Fvim.ComputeResource.html,\n\t\t\t\t\t\t// http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.ClusterComputeResource.html and\n\t\t\t\t\t\t// http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.ResourcePool.html\n\t\t\t\t\t\tmor.setType(cluster.type);\n\t\t\t\t\t\tmor.setVal(cluster.morid);\n\t\t\t\t\t\tcluster = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\t\tcluster = _this.getPropsForUnknownType(cluster, dataMap);\n\n\t\t\t\t\t\tif (typeof dataMap[clusterType] == 'string')\n\t\t\t\t\t\t\tclusterType = dataMap[clusterType];\n\n\t\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\t\tif (debug)\n\t\t\t\t\t\t\toriginalData.push(JSON.stringify(cluster));\n\n\t\t\t\t\t\t// Fixup the data.\n\t\t\t\t\t\tfixers[clusterType](cluster);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing ' + cluster.type + ' ' + cluster.morid + ': ' + e.toString());\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tif (debug)\n\t\t\t\tresults.originalData = originalData.map(JSON.parse);\n\n\t\t\t// We fetched at most pageSize clusters.  Send back the IDs of remaining clusters so the\n\t\t\t// sensor can fire another probe.\n\t\t\tif (leftOverMors.length)\n\t\t\t\tresults.leftOverMors = leftOverMors;\n\n\t\t\t// Stringify the results, dropping anything named 'mo' (these are vijava ManagedObjects)\n\t\t\tthis.output = JsonCi.decircularize(results, function(key, value) {\n\t\t\t\tif (key != 'mo') return value;\n\t\t\t});\n\t\t},\n\n\t\ttype: 'VMWarevCenterClusterDRSProbe'\n\t});\n\n\t//////////////////////////////////////////////////////////////////////////\n\tfunction fixCluster(cluster) {\n\t\t//Check if the drs config block exists in the datamap.\n\t\tvar configurationEx = cluster.configurationEx,\n\t\t\tgroups = configurationEx && configurationEx.group,\n\t\t\trules = configurationEx && configurationEx.rule;\n\n\t\tfixDRSGroup(groups, cluster);\n\n\t\tfixDRSRules(rules, cluster);\n\n\t\tdelete cluster.configurationEx;\n\t}\n\n\tfunction fixDRSGroup(vmHostgroups, cluster) {\n\t\tvmHostgroups.forEach(function(group) {\n\t\t\tvar groupParent = group.parent;\n\t\t\tgroup.cluster = cluster;\n\t\t\tif (groupParent.contains('ClusterHostGroup')) {\n\t\t\t\tdelete group.vm;\n\t\t\t\thostGroups.push(group);\n\t\t\t} else if (groupParent.contains('ClusterVmGroup')) {\n\t\t\t\tdelete group.host;\n\t\t\t\tvmGroups.push(group);\n\t\t\t}\n\t\t\tdelete group.parent;\n\t\t});\n\t}\n\n\tfunction fixDRSRules(clusterDRSRules, cluster) {\n\t\tclusterDRSRules.forEach(function(rule) {\n\t\t\tvar ruleParent = rule.parent;\n\n\t\t\trule.cluster = cluster;\n\t\t\tif (ruleParent.contains('ClusterVmHostRuleInfo')) {\n\t\t\t\trule.host_group = rule.affineHostGroupName || rule.antiAffineHostGroupName;\n\t\t\t\trule.affinity = rule.affineHostGroupName ? true : false;\n\n\t\t\t\tdelete rule.vm;\n\t\t\t\tvmHostRules.push(rule);\n\t\t\t} else if (ruleParent.contains('ClusterAffinityRuleSpec'))\n\t\t\t\tpushAffinityRuleObject(rule, true);\n\t\t\telse if (ruleParent.contains('ClusterAntiAffinityRuleSpec'))\n\t\t\t\tpushAffinityRuleObject(rule, false);\n\n\t\t\tdelete rule.affineHostGroupName;\n\t\t\tdelete rule.antiAffineHostGroupName;\n\t\t\tdelete rule.parent;\n\t\t});\n\t}\n\n\tfunction pushAffinityRuleObject(rule, isAffinity) {\n\t\trule.affinity = isAffinity;\n\n\t\tdelete rule.vm_group;\n\t\tdelete rule.mandatory;\n\t\tvmAffinityRules.push(rule);\n\t}\n\n})();",
      "sys_id": "1fb087ae5b33330012868473b881c77f"
    },
    {
      "script": "var GlideSimpleDateFormatEx = Packages.com.glide.util.SimpleDateFormatEx;\nvar SncIPAddressV4 = Packages.com.snc.commons.networks.IPAddressV4;\nvar SncIPAddressV6 = Packages.com.snc.commons.networks.IPAddressV6;\nvar SncIPNetworkV4 = Packages.com.snc.commons.networks.IPNetworkV4;\nvar XMLUtil = Packages.com.glide.util.XMLUtil;\nvar IPCollectionUtil = Packages.com.service_now.mid.util.IPCollectionUtil;\n\nvar g_array_util = new ArrayUtil();",
      "sys_id": "2678642247012100fc856f2ccee4903b"
    },
    {
      "script": "var ArrayPolyfill;\n\n// Simple home-grown polyfill for find().\nif (!Array.prototype.find) {\n\t/**\n\t * ES6\n\t * Return the value of the first element in the array that satisfies the provided\n\t * testing function, otherwise return undefined\n\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n\t */\n\tArray.prototype.find = function(predicate) {\n\t\tif (this == null) {\n\t\t\tthrow new TypeError('Array.prototype.find called on null or undefined');\n\t\t}\n\t\tif (typeof predicate !== 'function') {\n\t\t\tthrow new TypeError('predicate must be a function');\n\t\t}\n\t\tvar list = Object(this);\n\t\tvar length = list.length >>> 0;\n\t\tvar thisArg = arguments[1];\n\t\tvar value;\n\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvalue = list[i];\n\t\t\tif (predicate.call(thisArg, value, i, list)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t};\n}",
      "sys_id": "2eb7802893010200e4e4705bb47ffb82"
    },
    {
      "script": "// Discovery\n\nvar PsOutputParser = Class.create();\nPsOutputParser.prototype = {\n    initialize: function() {\n    },\n    \n    /**\n     * Parses the given output from running ps (with at least the PID, PPID, and COMMAND columns), \n     * returning an array of running process objects with the following properties:\n\t *   count:      number of times this process was seen (Only used for ADME)\n     *   pid:        the PID of the process\n     *   ppid:       the PPID of the process\n     *   name:       the name of the command (sans path)\n     *   command:    the complete command (with path), but without the command's parameters\n     *   parameters: the command's parameters (if any)\n     *\n     * Note: this method assumes that parameters always start with a ' -' string.\n     */\n    parse: function(output) {\n        // parse the results from our ps output...\n\t\tvar cols = {};\n\t\t//ADME output payload starts with count\n \t\tif (output.startsWith(\"COUNT\") ) {\n\t\t\tcols = [\n\t\t\t\t{ header_matcher:/^COUNT$/,     prop_name:'count',     last:false },\n\t\t\t\t{ header_matcher:/^PID$/,     prop_name:'pid',     last:false }, \n\t\t\t\t{ header_matcher:/^PPID$/,    prop_name:'ppid',    last:false }, \n\t\t\t\t{ header_matcher:/^COMMAND$/, prop_name:'command', last:true  }\n\t\t\t];\t\t\t\n\t\t} else {\n\t\t\tcols = [\n\t\t\t\t{ header_matcher:/^PID$/,     prop_name:'pid',     last:false }, \n\t\t\t\t{ header_matcher:/^PPID$/,    prop_name:'ppid',    last:false }, \n\t\t\t\t{ header_matcher:/^C.*M.*D$/, prop_name:'command', last:true  }\n\t\t\t];\n\t\t}\n        var ttp = new TabularTextParser();\n        var rps = ttp.parse(output, cols);\n        this.error_msg = ttp.error_msg;  // preserve any error messages we got from the parser...\n        \n        // now iterate over our found objects to split the command into name, command, and parameters...\n        for (var i = 0; i < rps.length; i++) {\n            var rp = rps[i];\n\n\t\t\t// First check and see if we have a valid numerical value for pid and ppid\n\t\t\tif (isNaN(rp.pid) || isNaN(rp.ppid)) {\n\t\t\t\trps.splice(i,1);\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n            // find the start of the parameters, if there are any\n            // this is more challenging than it might appear, as all of the following are possible:\n            //    /usr/bin/xxx -a\n            //                 ^- parameters start\n            //    /usr/bin/xxx /usr/bin/yyy -a\n            //                 ^- parameters start\n            //    /usr/bin abc/xxx -a\n            //                     ^- parameters start\n            //    /usr/bin/xxx yyy -a\n            //                     ^- parameters start\n            //    /usr/bin/xxx yyy ccc -a\n            //                     ^- parameters start\t\n            var parts = rp.command.split(' ');\n            var j;\n            for (j = 1; j < parts.length; j++) {\n                var c = parts[j].charAt(0);\n                \n                // if this part starts with something we can tell is a parameter, run with it...\n                if ((c == '-') || (c == '/'))\n                    break;\n            }\n            rp.command = parts.slice(0, j).join(' ');\n            rp.parameters = parts.slice(j, parts.length).join(' ');\n            \n\t\t\t// For POSIX, the original process would typically have PID and PPID\n\t\t\t// equal to 0. We need to fake a real root for later\n\t\t\tif (rp.pid == rp.ppid)\n\t\t\t\trp.ppid = \"1000000000\" + rp.ppid;\n\t\t\t\n            // set the name...\n            var name_index = rp.command.lastIndexOf('/');\n            name_index = (name_index >= 0) ? name_index + 1 : 0;\n            rp.name = rp.command.substring(name_index);\n\t\t\t\n\t\t\t//Trim up the whitespace\n\t\t\tif(rp.name)\n            \trp.name = rp.name.trim();\n            if(rp.command)\n            \trp.command = rp.command.trim();\n\t\t\tif(rp.parameters)\n\t\t\t\trp.parameters = rp.parameters.trim();\n\t\t\tif(rp.parameters.toLowerCase().includes(\"password\")) {\n\t\t\t\trp.parameters = \"*** Command contains password - removed ***\";\n\t\t\t}\n        }\n        \n        return rps;\n    },\n\t\n\t/**\n     * Filters out any kernel processes (processes that are child of the \n\t * kernel thread).  These are not used in process classification.\n     */\n\tfilterKernelProcs: function(rps) {\n\t\t// find the kernel thread pid, and filter it out\n\t\tvar kpid = -1;\n\t\tfor (var i = 0; i < rps.length; i++) {\n\t\t\tif (rps[i].command == '[kthread]' || rps[i].command == '[kthreadd]') {\t\n\t\t\t\tkpid = rps[i].pid;\n\t\t\t\trps.splice(i,1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (kpid == -1)\n\t\t\treturn;\n\t\t\n\t\t// filter out any processes with ppid matching that of the kernel thread\n\t\tvar i = rps.length;\n\t\twhile (i--)\n\t\t\tif (rps[i].ppid == kpid)\n\t\t\t\trps.splice(i,1);\n\t},\n\t\n\t/**\n     * Filters out any processes which are produced by adme\n\t * ADME uses sort, uniq, sleep commands and PS captures those\n     */\n\tfilterAdmeProcs: function(rps,adme_pid) {\n\t\tvar i = rps.length;\n\t\twhile (i--) {\n\t\t\tif ( rps[i].ppid == adme_pid || rps[i].command == 'sort' || \n\t\t\t\t rps[i].command == 'uniq' || rps[i].command.startsWith('sleep') )\n\t\t\t\trps.splice(i,1);\n\t\t}\n\t},\n\n    type: 'PsOutputParser'\n};",
      "sys_id": "300bde7b9f21210054679ff3367fcf25"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n \nvar VMWarevCenterDatacentersProbe = Class.create();\n\n(function() {\n\nvar _this,\n\toutput = { },\n\tresourceMap = {\n\t\tname: 'name'\n\t},\n\tcomputeMap = {\n\t\thost: [ { name: 'name' } ],\n\t\tresourcePool: resourceMap\n\t},\n\t vmInsideVMFolder = [];\n\nresourceMap.resourcePool = [ resourceMap ];\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterDatacentersProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name, dcs,\n\t\t\tvc = new Packages.com.service_now.mid.util.VersionComparator(),\n\t\t\tvCenterMinApiVersion = '4.1',\n\t\t\tmors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\tmorMap = { };\n\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n        this.debug('Starting vCenter discovery...');\n\t\t_this = this;\n\n\t\t// Get information about the vCenter\n\t\toutput.vcenter = fetchvCenter();\n\n\t\t// Error if vCenter version is too old.\n\t\tif (vc.compare(vCenterMinApiVersion, output.vcenter.version) < 0) {\n\t\t\tthis.setError(\"vCenter version \" + output.vcenter.version + \" is not supported.  Only \" + vCenterMinApiVersion + \" or newer is supported\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Get information about vCenter appliance\n\t\t//  This api is available in vCenter version 6.7 or greater\n\t\tif( output.vcenter.version >= \"6.7\")\n\t\t\toutput.appliance = _this.getApplianceInfo();\n\n\t\tdcs = this.fetchManagedObjects('Datacenter', {\n\t\t\tname: 'name',\n\t\t\tvmFolder: 'folder_morid',\n\t\t\thostFolder: 'host_morid'\n\t\t});\n\n\t\tif (mors) {\n\t\t\toutput.cmdb_ci_vcenter_datacenter = [ ];\n\t\t\tmors.forEach(function(mor) { morMap[mor.morid] = 1; });\n\t\t\tdcs.forEach(function(dc) { if (morMap[dc.morid]) output.cmdb_ci_vcenter_datacenter.push(dc); });\n\t\t} else\n\t\t\toutput.cmdb_ci_vcenter_datacenter = dcs;\n\n\t\tif ('' + probe.getParameter('datacenters_only') != 'true') {\n\t\t\t// Now get the list of objects that exist in each datacenter\n\t\t\toutput.cmdb_ci_vcenter_datacenter.forEach(\n\t\t\t\tfunction(dc) {\n\t\t\t\t\tdc.folders = walkFolderTrees(dc.mo, {\n\t\t\t\t\t\tname: 'name',\n\t\t\t\t\t\tdatastoreFolder: { name: 'name' },\n\t\t\t\t\t\thostFolder: { name: 'name' },\n\t\t\t\t\t\tnetworkFolder: { name: 'name' },\n\t\t\t\t\t\tvmFolder: { name: 'name' }\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\tgetHosts(output.cmdb_ci_vcenter_datacenter);\n\t\t\tgetOtherVMs(_this.serviceInstance, output.cmdb_ci_vcenter_datacenter);\n\t\t}\n\n\t\t// Stringify the results, dropping anything named 'mo' (these are vijava ManagedObjects)\n\t\tthis.output = JSON.stringify(output, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterDatacentersProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction getHosts(dcs) {\n\n\tvar clusters = [ ],\n\t\thosts = [ ],\n\t\tpools = [ ];\n\n\toutput.hosts = hosts;\n\n\tdcs.forEach(\n\t\tfunction(dc) {\n\t\t\textractClusters(dc.folders.hostFolder);\n\t\t});\n\n\tclusters.forEach(\n\t\tfunction(cluster) {\n\n\t\t\tcluster.host && cluster.host.forEach(\n\t\t\t\tfunction(host) {\n\t\t\t\t\thosts.push(host.morid);\n\t\t\t\t});\n\n\t\t\textractPools(cluster.resourcePool);\n\t\t});\n\n\toutput.pools = pools;\n\n\tfunction extractPools(pool) {\n\t\tif (pool) {\n\t\t\tpools.push(pool.morid);\n\t\t\tpool.resourcePool.forEach(\n\t\t\t\tfunction(pool) {\n\t\t\t\t\textractPools(pool);\n\t\t\t\t});\n\t\t}\n\t}\n\n\tfunction extractClusters(folder) {\n\t\tfolder.childEntity.forEach(function (child) {\n\t\t\tif (child.type == 'Folder')\n\t\t\t\textractClusters(child);\n\t\t\telse\n\t\t\t\tclusters.push(_this.getPropsForManagedObject(child.mo, computeMap));\n\t\t});\n\t}\n}\n//////////////////////////////////////////////////////////////////////////\nfunction getOtherVMs(serviceInstance, dc) {\n\tvar rootFolder = serviceInstance.getRootFolder();\n\tvar managedEntities = vim25.mo.InventoryNavigator(rootFolder).searchManagedEntities('VirtualMachine');\n\n\tfor (var i = 0; i < managedEntities.length; i++) {\n            var obj = processVirtualMachine(managedEntities[i]);\n            var parent = obj.propvals.get('parent');\n            if (vmInsideVMFolder.indexOf(obj.vm.morid) == -1 && parent == null) {\n                //vm is not present in vmFolder.Add it to vmFolder of 1st datacenter\n                dc[0].folders.vmFolder.childEntity.push(obj.vm);\n            }\n        }\n}\n\nfunction processVirtualMachine(virtualMachine) {\n\tvar nic,\n\tprops = ['name', 'parent'];\n\t\n\tvar propvals = virtualMachine.getPropertiesByPaths(props);\n\tvar o = {};\n\tvar e = propvals.keys();\n\n\twhile (e.hasMoreElements()) {\n\t\tvar key = e.nextElement();\n\t\tvar prop = propvals.get(key);\n\n\t\tif (prop instanceof Packages.java.lang.Integer ||\n\t\t\tprop instanceof Packages.java.lang.Short ||\n\t\t\tprop instanceof Packages.java.lang.String ||\n\t\t\tprop instanceof Packages.java.lang.Long ||\n\t\t\tprop instanceof Packages.java.lang.Boolean)\n\t\t\to[key] = '' + prop;\n\t}\n\to.morid = '' + virtualMachine.getMOR().val;\n\to.type = 'VirtualMachine';\n\n\treturn {\n\t\t'vm': o,\n\t\t'propvals': propvals\n\t};\n}\n\nfunction fetchvCenter() {\n\tvar dm = {\n\t\t\t'content.about.name': 'name',\n\t\t\t'content.about.osType': 'os_type',\n\t\t\t'content.about.version': 'version',\n\t\t\t'content.about.fullName': 'fullname',\n\t\t\t'content.about.apiVersion': 'api_version',\n\t\t\t'content.about.instanceUuid': 'instance_uuid'\n\t\t},\n\t\tvCenter = _this.getPropsForManagedObject(_this.serviceInstance, dm);\n\n\tvCenter.url = '' + _this.serverConnection.getUrl();\n\n\treturn vCenter;\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction walkFolderTrees(root, dataMap) {\n\n\tvar name, vms,\n\t\tfolders = _this.getPropsForManagedObject(root, dataMap);\n\n\tfor (name in dataMap) {\n\t\tif (name == 'propNames')\n\t\t\tcontinue;\n\n\t\tfolders[name].childEntity = walkFolderTree(folders[name].mo);\n\t}\n\n\treturn folders;\n\n\tfunction walkFolderTree(root) {\n\n\t\tvar childEntity = { childEntity: [ { name: 'name' } ] },\n\t\t\tfolder = _this.getPropsForManagedObject(root, childEntity),\n\t\t\tnewChildren = [ ];\n\n\t\tfolder.childEntity.forEach(\n\t\t\tfunction(child) {\n\t\t\t\tif (child.type != 'VirtualApp')\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\tif (child.type == 'VirtualMachine')\n\t\t\t\t\tvmInsideVMFolder.push(child.morid);\n\t\t\t\tif (child.type == 'Folder' || child.type == 'StoragePod')\n\t\t\t\t\tchild.childEntity = walkFolderTree(child.mo);\n\t\t\t\telse if (child.type == 'VirtualApp')\n\t\t\t\t\twalkVirtualAppTree(child, newChildren);\n\t\t\t});\n\n\t\treturn newChildren;\n    }\n\n\tfunction walkVirtualAppTree(root, parentChildren) {\n\t\tvar childEntity = { resourcePool: [ { } ], vm: [ { name: 'name' } ]},\n\t\t\tvirtualApp = _this.getPropsForManagedObject(root.mo, childEntity);\n\n\t\tvirtualApp.resourcePool.forEach(\n\t\t\tfunction(child) {\n\t\t\t\tchild.childEntity = walkVirtualAppTree(child, parentChildren);\n\t\t\t}\n\t\t);\n\n\t\tvirtualApp.vm.forEach(\n\t\t\tfunction(child) {\n\t\t\t\tparentChildren.push(child);\n\t\t\t\tvmInsideVMFolder.push(child.morid);\n\t\t\t}\n\t\t);\n\t}\n}\t\n\n})();",
      "sys_id": "31ebed618f071200c2fe0b5437bdee97"
    },
    {
      "script": "String.prototype.startsWith =function(prefix){\n   return (this.substr(0,prefix.length)==prefix);\n}\n\nString.prototype.endsWith = function(s) {\n   if (!s)\n      return false;\n   \n   if (this.length < s.length)\n      return false;\n   \n   return (this.substr(this.length - s.length, s.length) == s);\n}\n\nString.prototype.trimLeft =function(){\n   return this.replace(/^\\s*/,\"\");\n}\n\nString.prototype.trimRight =function(){\n   return this.replace(/\\s*$/,\"\");\n}\n\nString.prototype.trim =function(){\n   return this.trimRight().trimLeft();\n}\n\nString.prototype.replaceAll = function(from, to) {\n   var str = this;\n   from = from.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n   return str.replace(new RegExp(from, 'g'), to);\n}",
      "sys_id": "373cd430c32121002d031f051eba8fa6"
    },
    {
      "script": "var UCSRestXmlApiClient = Class.create();\n\n/*\n This is the implementation of Cisco UCS XML/API by using GlideHTTPClient as part\n of solution for horizontal discovery that will perfromed by horizontal discovery pattern.\n GlideHTTPClient using Appache Http Clinet as core element for http conversations\n */\nUCSRestXmlApiClient.prototype = {\n\n    initialize: function(ucsHost) {\n        ms.log(\"UCSRestXmlApiClient: Starting initialize\");\n        this.host = ucsHost;\n        this.Document = Packages.org.w3c.dom.Document;\n        this.PostMethod = Packages.org.apache.commons.httpclient.methods.PostMethod;\n        this.RequestEntity = Packages.org.apache.commons.httpclient.methods.RequestEntity;\n        this.StringRequestEntity = Packages.org.apache.commons.httpclient.methods.StringRequestEntity;\n        this.GlideHTTPCient = Packages.com.glide.communications.HTTPClient;\n        this.httpClient = new this.GlideHTTPCient();\n        this.sessionCookie = null;\n        this.userName = \"\";\n        this.password = \"\";\n        var ciType = \"cmdb_ci_ucs_equipment\";\n        this.ucsCredentials = this.getApplicativeCredentialsByCiType(ciType);\n\n    },\n\n    /*\n     This function performing login to UCS\n     and saving the cookie as local member in order to use it for the next commands\n     */\n\n    login: function () {\n\n        for (var i=0 ; i < this.ucsCredentials.length; i++) {\n            this.userName = this.ucsCredentials[i].userName;\n            this.password = this.ucsCredentials[i].password;\n            ms.log(\"UCSRestXmlApiClient: Using credentials, userName: \" + this.userName + \" password: ********\");\n            var xmlCommand = \"<aaaLogin inName=\\\"\" + this.userName + \"\\\" inPassword=\\\"\" + this.password + \"\\\" />\";\n            var ucsResponse = this.__sendUcsRequest(xmlCommand);\n            if ( ucsResponse.isSuccess ) {\n                var GlideXmlUtil = Packages.com.glide.util.XMLUtil;\n                var xmlDoc = GlideXmlUtil.parse(ucsResponse.xmlResponse);\n                var outCookie = xmlDoc.getDocumentElement().getAttribute(\"outCookie\");\n                this.sessionCookie = outCookie;\n                return this.sessionCookie;\n            }\n        }\n        ms.log(\"UCSRestXmlApiClient: Credentials for CI \" + ciType + \" not found, check the credentials definition \");\n        return \"CREDENTIALS_NOT_FOUND\";\n    },\n\n    /**\n     This function performing logout from UCS in order to inform that current cookie is expired.\n     */\n\n    logout: function () {\n        var xmlCommand = \"<aaaLogout inCookie=\\\"<real_cookie>\\\" />\";\n        var ucsResponse = this.__sendUcsRequest(xmlCommand);\n        if (ucsResponse.isSuccess) {\n            return ucsResponse.xmlResponse;\n        } else {\n            ms.log(ucsResponse.xmlResponse);\n            return \"COMMAND_FAILED\";\n        }\n    },\n\n    /**\n     This function performing any UCS commands in valid XML format.\n     each command should arrive with place holder <real_cookie> in order to change it to the current cookie\n     */\n    sendCommand: function(xmlCommand) {\n        var ucsResponse  = this.__sendUcsRequest(xmlCommand);\n        if (ucsResponse.isSuccess) {\n            return ucsResponse.xmlResponse;\n        } else {\n            ms.log(ucsResponse.xmlResponse);\n            return \"COMMAND_FAILED\";\n        }\n    },\n\n    /*\n     This is the private and core fucntion that called by other functions in order to perform\n     UCS commands.\n\n     Example of input command:\n     <configResolveClass cookie=\"<real_cookie>\" inHierarchical=\"false\" classId=\"equipmentChassis\"/>\n\n     input: xmlCommand\n\n     Json object that represent the status of the performed command.\n     In case of success the isSuccess is true and xmlResponse contains the xml response\n     In case od fail the isSuccess is false and xmlResponse contains the xml error response\n     output: result: { isSuccess , xmlResponse }\n\n     */\n    __sendUcsRequest: function (xmlCommand) {\n        var COOKIE_PLACE_HOLDER = \"<real_cookie>\";\n\n        if ((xmlCommand.indexOf(COOKIE_PLACE_HOLDER) > -1) && !JSUtil.nil(this.sessionCookie)) {\n            xmlCommand = xmlCommand.replace(COOKIE_PLACE_HOLDER,this.sessionCookie);\n        }\n\n        var xmlEntity = new this.StringRequestEntity(xmlCommand, \"application/xml\", \"UTF-8\");\n        var postMethod = new this.PostMethod(\"https://\" + this.host + \"/nuova\");\n        postMethod.setRequestEntity(xmlEntity);\n\n        var logMessage = \"UCSRestXmlApiClient: Sending command to UCS: \" + xmlCommand;\n        if (logMessage.indexOf('aaaLogin') !== -1)\n            logMessage = logMessage.replace(this.password, '********');\n\n        ms.log(logMessage);\n\n        var status = this.httpClient.executeMethod(postMethod);\n        var body = postMethod.getResponseBodyAsString();\n        postMethod.releaseConnection();\n        ms.log(\"UCSRestXmlApiClient: The UCS response is: \" + body);\n\t\t\n\t\tvar hasError = this.__checkForError(body);\n\t\t\n        var result = {};\n\n        var isSuccess = true;\n        if (200 <= status && status <= 202 && !hasError) {\n\n            ms.log(\"Request successful, status is: \" + status);\n            if(body.indexOf(\"<error\") >= 0)\n                isSuccess = false;\n            result = {\n                isSuccess: isSuccess,\n                xmlResponse: body\n            };\n\n        } else {\n            isSuccess = false;\n            ms.log(\"Request failed, status is: \" + status);\n            result = {\n                isSuccess: isSuccess,\n                xmlResponse: body\n            };\n        }\n        return result;\n    },\n\n\t__checkForError: function(body) {\n\t\tvar hasError = body.indexOf('errorCode=') != -1;\n\t\t\n\t\tif (hasError) {\n\t\t\tif(body.indexOf('errorDescr=') != -1) {\n\t\t\t\tvar patt = new RegExp(\"errorDescr=\\\".*?\\\"\");\n\t\t\t\tvar match = patt.exec(body);\n\t\t\t\tvar errorDescription = match[0];\n\t\t\t\t\n\t\t\t\tms.log(\"Request failed, \" + errorDescription);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar patt1 = new RegExp(\"errorCode=\\\"([0-9]*)\\\"\");\n\t\t\t\tvar match1 = patt1.exec(body);\n\t\t\t\tvar errorCode = match1[1];\n\t\t\t\t\n\t\t\t\tms.log(\"Request failed, Error Code: \" + errorCode);\n\t\t\t}\n\t\t}\n\t\treturn hasError;\n\t},\n\t\n\t/*\n     This fucntion providing Applicative credentials by ciType\n     input ciType\n     output list of credentials\n     */\n    getApplicativeCredentialsByCiType: function(ciType) {\n        var credList = [];\n        var CredentialsProviderFactory = Packages.com.snc.commons.credentials.CredentialsProviderFactory;\n        var credProvider = CredentialsProviderFactory.getCredentialsProvider();\n        var iterator = credProvider.iterator(null, null, null, null);\n        while (iterator.hasNext()) {\n            var midCred = iterator.next();\n            var currentCiType = midCred.getType().getDbString();\n            if (JSUtil.nil(currentCiType) || !ciType.equals(currentCiType))\n                continue;\n            var currentUser = midCred.getUsername();\n            var currentPassword = midCred.getPassword();\n            credList.push({\n                userName : currentUser,\n                password : currentPassword\n            });\n        }\n\n        return credList;\n    },\n\n    type: \"UCSRestXmlApiClient\"\n};\n",
      "sys_id": "3d34b3c593301200f81a35bb357ffb22"
    },
    {
      "script": "var WindowsInstalledSoftwareLegacy = Class.create();\n\nWindowsInstalledSoftwareLegacy.prototype = {\n\t/**\n     * Runs the probe instance\n     */    \n    process : function(output, related_data) {  \n\t\trelated_data.packages = [];\n\t\t\n\t\tvar registry = output.Registry;\n        if (JSUtil.nil(registry))\n            return;\n        \n        var softwareList = this.getSoftware(registry);\n\n        for (var sw in softwareList)\n            related_data.packages.push(softwareList[sw]);\n\t\t\n\t\tvar osPackage = {};\n\t\trelated_data.osPackage = this._setOSIDs(osPackage, registry);\n\t\trelated_data.caption = output.Win32_OperatingSystem.Caption;\n\t\trelated_data.osVersion = output.Win32_OperatingSystem.Version;\n\t\t\n\t\tvar iePkgObj = this.getIEPackage(registry);\n\t\tif (JSUtil.notNil(iePkgObj))\n            related_data.packages.push(iePkgObj);\n\t},\n\t\n\tgetSoftware: function(registry) {\n        var softwareList = {};\n        var productIds = this.getProductIds(registry, softwareList); //get product ID as well as software entries.\n        var officeLic = this.getOfficeLicenses(registry);\n\n        var softwareReg = [];\n        softwareReg.push(\"HKEY_LOCAL_MACHINE.Software.Microsoft.Windows.CurrentVersion.Uninstall\");\n        softwareReg.push(\"HKEY_LOCAL_MACHINE.Software.Wow6432Node.Microsoft.Windows.CurrentVersion.Uninstall\");\n\n        for (var i = 0; i < softwareReg.length; i++) {\n            var node = this.findRegistryNode(registry, softwareReg[i]);\n            if (!node)\n                continue;\n\n            this.parseSoftware(node, softwareList, productIds, officeLic);\n        }\n\n\t\tthis.updateAdobeAcrobat(registry, softwareList);\n\t\t\n        return softwareList;\n    },\n\t\n    parseSoftware: function(node, softwareList, productIds, officeLic) {\n        var nodeArray = g_array_util.ensureArray(node.entry);\n        for (var dataKey = 0; dataKey < nodeArray.length; dataKey++) {\n            var displayName = this.findNodeValueWithAttribute(nodeArray[dataKey], \"DisplayName\");\n            var parentDisplayName = this.findNodeValueWithAttribute(nodeArray[dataKey], \"ParentDisplayName\");\n            var displayVersion = this.findNodeValueWithAttribute(nodeArray[dataKey], \"DisplayVersion\");\n            var publisher = this.findNodeValueWithAttribute(nodeArray[dataKey], \"Publisher\");\n            var uninstallString = this.findNodeValueWithAttribute(nodeArray[dataKey], \"UninstallString\");\n            var installDate = this.findNodeValueWithAttribute(nodeArray[dataKey], \"InstallDate\");\n            var msiID = this.parseMsiId(uninstallString);\n\n            if (!displayName)\n                continue;\n\n            var uniqueName = this.getUniqueName(displayName, displayVersion);\n\t\t\t\n            // Sometimes we encounter two entries of that have the same name, but one has the msi_id and the\n            // other one doesn't. In which case we want to give it another chance matching the office license.\n            if (softwareList[uniqueName]) {\n                if (JSUtil.nil(msiID) || JSUtil.notNil(softwareList[uniqueName].msi_id)) {\n\t\t\t\t\t//populate detailed information \n\t\t\t\t\tsoftwareList[uniqueName].part_of = parentDisplayName;\n\t\t\t\t\tsoftwareList[uniqueName].install_date = installDate;\n                    continue;\n\t\t\t\t}\n            }\n\n            if (displayName == \"detectedInvalidXMLCharacter\") {\n                this.log(\"Detected an invalid character in registry for \" + displayName , \n                        'Windows - Installed Software Sensor', this.getEccQueueId(), null);\n                continue;\n            }\n\t\t\t\n            softwareList[uniqueName] = {};\n            softwareList[uniqueName].name = displayName;\n            softwareList[uniqueName].version = displayVersion;\n            softwareList[uniqueName].vendor = publisher;\n            softwareList[uniqueName].part_of = parentDisplayName;\n            softwareList[uniqueName].uninstall_string = uninstallString;\n            softwareList[uniqueName].install_date = installDate;\n\t\t\t\n\t\t\tif (/Acrobat/.test(displayName) && !JSUtil.nil(uninstallString) && (uninstallString.indexOf(\"{\") >= 0)&&(uninstallString.indexOf(\"}\") >= 0)) {\n\t\t\t\tvar editionString = uninstallString.split(\"{\")[1];\n\t\t\t\t\teditionString = editionString.split(\"}\")[0];\n\t\t\t\t\tif (!JSUtil.nil(editionString)) {\n\t\t\t\t\t\tvar splitEdition = editionString.split(\"-\");\n\t\t\t\t\t\tif (splitEdition.length >= 4)\n\t\t\t\t\t\t\tsoftwareList[uniqueName].edition = splitEdition[3];\n\t\t\t\t\t}\n\t\t\t\tsoftwareList.adobe_acrobat = softwareList[uniqueName];\n\t\t\t}\n\n            // If product id is non-existent, don't bother since the following info is for creating licenses.\n            // And without a product id, we just wouldn't do it.\n            if (JSUtil.nil(productIds[uniqueName]))\n                continue;\n\n            softwareList[uniqueName].product_id = productIds[uniqueName];\n\n            if (JSUtil.nil(msiID) || JSUtil.nil(officeLic[msiID]))\n                continue;\n\n            softwareList[uniqueName].msi_id = msiID;\n            softwareList[uniqueName].digital_product_id = officeLic[msiID].digitalproductid;\n        }\n\n        return softwareList;\n    },\n\n    parseMsiId: function(str) {\n        var msiID = \"\";\n\n        if (str && str.toLowerCase().indexOf(\"msiexec\") > -1) {\n            var start = str.indexOf(\"{\");\n            var finalString = str.substring(start+1);\n            var end = finalString.indexOf(\"}\");\n            msiID = finalString.substring(0, end);\n        }\n\n        return msiID;\n    },\n\t\n\tgetIEPackage: function(registry) {\n\t\tvar regKey = \"HKEY_LOCAL_MACHINE.Software.Microsoft.Internet Explorer\";\n        var node = this.findRegistryNode(registry, regKey);\n        var svcVersion = this.findNodeValueWithAttribute(node, \"svcVersion\");\n\t\tvar version = this.findNodeValueWithAttribute(node, \"Version\");\n\t\t\n\t\t// Check if we can detect IE\n\t\tif (JSUtil.nil(svcVersion) && JSUtil.nil(version))\n\t\t    return;\t\n\t\t\n\t\tvar iePackage = {};\n        iePackage.name = \"Internet Explorer\";\n        iePackage.vendor = \"Microsoft\";\n\t\t\n\t\t// Version should work for IE 4.0+. svcVersion is new to IE 10. \n\t    iePackage.version = svcVersion ? svcVersion : version;\n\t\t\n\t\tregKey = \"HKEY_LOCAL_MACHINE.Software.Microsoft.Internet Explorer.Registration\";\n        node = this.findRegistryNode(registry, regKey);\n\t\tvar productId = this.findNodeValueWithAttribute(node, \"ProductId\");\n\t\t\n\t\tif (!JSUtil.nil(productId)) \n\t\t\tiePackage.product_id = productId;\n\t\t\t\n        return iePackage;\n    },\n\n    _setOSIDs: function(osPackage, registry) {\n        var node = this.findRegistryNode(registry, \n                \"HKEY_LOCAL_MACHINE.Software.Microsoft.Windows.CurrentVersion\");\n        var node2 = this.findRegistryNode(registry, \n                \"HKEY_LOCAL_MACHINE.Software.Microsoft.Windows NT.CurrentVersion\");\n\n        if (!node || !node2)\n            return osPackage;\n\n        var prodId = this.findNodeValueWithAttribute(node, \"ProductId\");\n\n        if (JSUtil.nil(prodId) || prodId == \"\") //Try it again at a diff location (like for Vista)...                \n            prodId = this.findNodeValueWithAttribute(node2, \"ProductId\");\n\n        var dProdId = this.findNodeValueWithAttribute(node2, \"DigitalProductID\");\n\n        osPackage.product_id = prodId;\n        osPackage.digital_product_id = dProdId;\n\n        return osPackage;\n    },\n\n    getProductIds: function(registry, softwareList) {\n        var prodIdReg = [];\n        prodIdReg.push(\"HKEY_LOCAL_MACHINE.Software.Microsoft.Windows.CurrentVersion.Installer.UserData\");\n        prodIdReg.push(\"HKEY_LOCAL_MACHINE.Software.Wow6432Node.Microsoft.Windows.CurrentVersion.Installer.UserData\");\n\n        var productIds = {};\n        for (var i = 0; i < prodIdReg.length; i++) {\n            var node = this.findRegistryNode(registry, prodIdReg[i]);\n            if (!node)\n               continue;\n\n            productIds = this.parseProductIds(node, productIds, softwareList);\n        }\n\n        return productIds;\n    },\n\n    parseProductIds: function(node, productIds, softwareList) {\n        var nodeArray = g_array_util.ensureArray(node.entry);\n        for (var dataKey=0; dataKey < nodeArray.length; dataKey++) {\n            var products = this.findNodeWithAttribute(nodeArray[dataKey], \"Products\");\n            if (!products)\n                continue;\n\n            var nodeArray2 = g_array_util.ensureArray(products.entry);\n            for (var dataKey2 = 0; dataKey2 < nodeArray2.length; dataKey2++) {\n                var installProperties = this.findNodeWithAttribute(nodeArray2[dataKey2], \"InstallProperties\");\n                var publisher = this.findNodeValueWithAttribute(installProperties, \"Publisher\");\n                var pid = this.findNodeValueWithAttribute(installProperties, \"ProductID\");\n                var name = this.findNodeValueWithAttribute(installProperties, \"DisplayName\");\n                var version = this.findNodeValueWithAttribute(installProperties, \"DisplayVersion\");\n\n                if (!name)\n                    continue;\n\n                var validPID = true;\n                if (pid == null || pid.length == 0 || pid.toLowerCase() == \"none\")\n                    validPID = false;\n\n                // As it turned out, sometimes customers don't have their software in the uninstall resgtries (due to \n                // improper imaging or deliberate efforts), but we should still fish it out this Products registries \n                // first.\n                var uniqueName = this.getUniqueName(name, version);\n                if (!softwareList[uniqueName]) {\n                    softwareList[uniqueName] = {};\n                    softwareList[uniqueName].name    = name;\n                    softwareList[uniqueName].version = version ;\n                    softwareList[uniqueName].vendor  = publisher;\n                    if (validPID)\n                        softwareList[uniqueName].product_id  = pid;\n                }\n\n                if (validPID)\n                    productIds[uniqueName] = pid;\n            }\n        }\n\n        return productIds;\n    },\n\n    getOfficeLicenses: function(registry) {\n        officeLicenseReg = [];\n        officeLicenseReg.push(\"HKEY_LOCAL_MACHINE.Software.Microsoft.Office\");\n        officeLicenseReg.push(\"HKEY_LOCAL_MACHINE.Software.Wow6432Node.Microsoft.Office\");\n\n        var officeLicenses = {};\n        for (var i = 0; i < officeLicenseReg.length; i++) {\n            var node = this.findRegistryNode(registry, officeLicenseReg[i]);\n            if (!node)\n                continue;\n\n            officeLicenses = this.parseOfficeLicense(node, officeLicenses);\n        }\n\n        return officeLicenses;\n    },\n\n    parseOfficeLicense: function(node, officeLicenses) {\n        var nodeArray = g_array_util.ensureArray(node.entry);\n        for (var dataKey = 0; dataKey < nodeArray.length; dataKey++) {\n            var registrations = this.findNodeWithAttribute(nodeArray[dataKey], \"Registration\");\n\n            if (!registrations)\n                continue;\n\n            var nodeArray2 = g_array_util.ensureArray(registrations.entry);\n            for (var dataKey2 = 0; dataKey2 < nodeArray2.length; dataKey2++) {\n                var productID = this.findNodeValueWithAttribute(nodeArray2[dataKey2], \"ProductID\");\n                var digitalProductID = this.findNodeValueWithAttribute(nodeArray2[dataKey2], \"DigitalProductID\");\n\n\n                var uuid = new String(nodeArray2[dataKey2]['@key']);\n\n                if (uuid.substring(0, 1) == \"{\")\n                    uuid = uuid.substring(1, uuid.length-1);\n\n                officeLicenses[uuid] = {};\n                officeLicenses[uuid].productid = productID;\n                officeLicenses[uuid].digitalproductid = digitalProductID;\n            }\n        }\n\n        return officeLicenses;\n    },\n\t\n    // Find the proper edition for Adobe Acrobat (pro vs standard)\n    updateAdobeAcrobat: function(registry, softwareList) {\n        // Did we find adobe acrobat?  If not, just skip this.\n        if (JSUtil.nil(softwareList.adobe_acrobat))\n            return;\n\n        // There are multiple \"*\" in the key so we need to iterate through\n        var users_node = this.findRegistryNode(registry, \"HKEY_USERS\");\n        if (!users_node) {\n            delete softwareList.adobe_acrobat;\n            return;\n        }\n        var users_node_array = g_array_util.ensureArray(users_node.entry);\n        for (var dataKey=0; dataKey < users_node_array.length; dataKey++) {\n            var tracks = this.findRegistryNode(users_node_array[dataKey], \"SOFTWARE.Adobe.Adobe Acrobat\");\n            if (!tracks) {\n                delete softwareList.adobe_acrobat;\n                return;\n            }\n            var tracks_array = g_array_util.ensureArray(tracks.entry);\n            for (var dataKey2 = 0; dataKey2 < tracks_array.length; dataKey2++) {\n                var entitlement_node = this.findRegistryNode(tracks_array[dataKey2], \"AVEntitlement\");\n                var entitlementLevel = this.findNodeValueWithAttribute(entitlement_node, \"iEntitlementLevel\");\n\n                if (!JSUtil.nil(entitlementLevel) && (entitlementLevel == 200 || entitlementLevel == 300)) {\n                    softwareList.adobe_acrobat.edition = entitlementLevel;\n                    return;\n                }\n            }\n\n        }\n    },\n\t\n\n    getUniqueName: function(name, version) {\n        return name + \" \" + version;\n    },\n\t\n\t/********************************************** \n     * Manage the Windows installed software xml\n     *\n     * Example payload:\n     *   <results probe_time=\"6313\">\n     *     <result>\n     *       <Registry>\n     *         <entry key=\"HKEY_LOCAL_MACHINE\">\n     *           <entry key=\"Software\">\n     *             <entry key=\"Microsoft\">\n     *               <entry key=\"Windows\">\n     *                 <entry key=\"Name\">\n     *                   <value>Just a name</value>\n     *                 </entry>\n     *               </entry>\n     *             </entry>\n     *           </entry>\n     *         </entry>\n     *       </Registry>\n     *     </entry>\n     *   </results>\n     * \n     *   // To find the value of the key called \"name\", here's how these methods can be used.\n     *   // registry is a variable representing the payload\n     *   var node = findRegistryNode(registry, \"HKEY_LOCAL_MACHINE.Software.Microsoft\");\n     *   var name = findNodeValueWithAttribute(node, \"Name\");\n     *********************************************/\n    findRegistryNode: function(currNode, regName){\n        var node = currNode;\n        var names = regName.split(\".\");\n\n        for (var i=0; i<names.length; i++) {\n            node = this.findNodeWithAttribute(node, names[i]);\n            if (!node)\n                return null;\n        }\n\n        return node;\n    },\n\n    findNodeWithAttribute: function(currNode, attrName) {\n        if (JSUtil.nil(currNode))\n            return \"\";\n\n        var nodeArray = g_array_util.ensureArray(currNode.entry);\n        for (var i=0; i<nodeArray.length; i++)\n            if (nodeArray[i]['@key'] == attrName)\n                return nodeArray[i];\n\n        return null;\n    },\n\n    findNodeValueWithAttribute: function(currNode, attrName) {\n        if (JSUtil.nil(currNode))\n            return \"\";\n\n        var nodeArray = g_array_util.ensureArray(currNode.entry);\n \n        for (var i=0; i<nodeArray.length; i++) {  \n\t\t\t\n            if (nodeArray[i]['@key'] == attrName) {         \n                // WMI - expected output a non-null json object { '@type': \"xxx\", '#text': \"returned value\" }\n                if (JSUtil.notNil(nodeArray[i].value) && JSUtil.notNil(nodeArray[i].value['#text']))             \n                    //return the #text field, ignoring the @type field value\n                    return nodeArray[i].value['#text']; \n                else                \n                    // Powershell - expected output\n                    return nodeArray[i].value;\t\t  \n\t\t    } // end if \n\n        } // end for\n\n        return \"\";\n    },\n\t\n\ttype: \"WindowsInstalledSoftwareLegacy\"\n};",
      "sys_id": "3ec5e196732300102535b7385ef6a763"
    },
    {
      "script": "var RequestAuthInternal = Class.create();\nRequestAuthInternal.prototype = {\n    initialize: function() {\n    },\n\n    type: 'RequestAuthInternal',\n    \n\tgenerateAuth: function(requestAuthenticator) {\n\t\t//requestAuthenticator object is java class signer\n\t\tthis.custom(requestAuthenticator);\n\t\treturn this.callAuthDataGeneration(requestAuthenticator, true);\n\t},\n\t\n\tcustom: function (requestAuthenticator) {\n\t},\n\t\n\tcallAuthDataGeneration: function(requestAuthenticator, locally) {\n\t\tif (locally) \n\t\t\treturn requestAuthenticator.generateAuth();\n\t\n\t\treturn requestAuthenticator.generateAuthRemotely();\n\t},\n\t\n};\n\n\t",
      "sys_id": "431e983fff13330001d3cd6bd53bf1d6"
    },
    {
      "script": "var GenerateWQLScriptPS1 = Class.create();\n\nGenerateWQLScriptPS1.prototype = {\n\n    initialize : function(namespace, wql, format_list,change_wql) {\n        this.namespace = namespace;\n        this.wql = wql;\n\t\tthis.format_list = format_list;\n\t\tthis.change_wql = change_wql;\n    },\n\t\n\tgenerateScript: function(isLocalhost) {\n\t\tvar scriptValue;\n\t\tif (this.change_wql) {\n\t\t\tscriptValue = this.change_wql;\n\t\t}else {\n\t\t\tscriptValue = \"gwmi -query \\\"\" + this.wql + \"\\\"\";\n\t\t}\n\t\tif (this.namespace)\n\t\t\tscriptValue += \" -namespace \\\"\" + this.namespace + \"\\\"\";\n\t\tif (!isLocalhost)\n\t\t\tscriptValue += \" -cred $cred\";\n\t\t\n\t\tif (this.format_list) {\n\t\t\tscriptValue += \" -computername $computer\";\n\t\t\tscriptValue += \" | \" + this.format_list + \"\\n\";\n\t\t}\n\t\telse {\n\t\t\tscriptValue += \" -computername $computer\\n\";\n\t\t}\n\t\t\n\t\treturn scriptValue;\n    },\n\n    type: \"GenerateWQLScriptPS1\"\n}",
      "sys_id": "44cb75427f1002003d9fbb87adfa9141"
    },
    {
      "script": "var VMWarevCenterVMTagsProbe = Class.create();\n\n(function() {\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterVMTagsProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\n\t\tvar\tvmMorIds = '' + probe.getParameter('mor_ids');\n\n\t\t// Call for discovering the tags information\n\t\tvar output = this.getTagsForResources(vmMorIds);\n\n\t\t// If any error received\n\t\tif (output.error) {\n\t\t\tthis.setError(output.error);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.output = JSON.stringify(output, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterVMTagsProbe'\n});\n\n})();\n",
      "sys_id": "44d40559674c330018da6c706785ef4c"
    },
    {
      "script": "var JsonCi;\n \n/*\n * JsonCi is a replacement for the Ci class.  JsonCi allows a developer to\n * build a web of JavaScript objects which will be written to the database\n * with references intact.  Circular references can't be represented in JSON,\n * which means an arbitrary web of objects can't be returned from a probe.\n * This code de-circularizes a JavaScript object so it can be stringified,\n * parsed and the re-circularized easily.\n * Decircularize/recircularize might be useful outside of JsonCi.  Consider\n * moving the code to a standalone include?\n */\n(function() {\n\nJsonCi = {\n\tdecircularize: decircularize\n};\n\n/*\n * A (kind of) simple function to serialize an object.  The name comes from the fact\n * that you can't blindly serialize circular references.  This function will walk the\n * object's graph, serializing as it goes.  If we encounter an object that we've\n * already serialized (completely or partially) we'll create an object identifier for\n * it.  We write that into the serialization stream instead of trying to serialize\n * the first object again. This function returns the serialized object.  The original\n * object can be re-created by calling reattach() \n *\n * One possible improvement in this function: De-circularized object references are\n * stored in the object itself as a special string value (the special value is\n * anything that starts with \"$^\".)  When parsing, any string value is assumed to be\n * an object reference if it matches the ID of a previous object.  It would be better\n * to store the IDs externally rather than use this magic prefix.\n *\n * This function returns a string which is expected to be passed to reattach()\n * (in the system script include \"JsonCi\".)\n * This means that we're not restricted to JSON if we need to change the implementation.\n */\nfunction decircularize(o, replacer)\n{\n\tvar name,\n\t\tobjects = { },\n\t\tobjectIdName = '$objectName$',\n\t\tnextId = 1,\n\t\tdeferred = [ ],\n\t\toutput = { '$^1': o };\n\n\ttry {\n\t\tdecirc(o, 0);\n\t\twhile (deferred.length)\n\t\t\tdecirc(deferred.pop(), 0, 1);\n\t}\n\tcatch(e) {\n\t\tms.log(e.toString());\n\t}\n\n\tfor (name in objects)\n\t\tdelete objects[name][objectIdName];\n\n\treturn JSON.stringify(output);\n\n\tfunction decirc(o, depth, ignoreName) {\n\n\t\t// If we've previously encountered 'o', it's decircularized by\n\t\t// returning the object identifier. If we haven't encountered it\n\t\t// just keep going - at that point we have a simple reference,\n\t\t// not a circular reference.  Note that the object ID is implicit\n\t\t// for simple references.  When re-attaching we need to create\n\t\t// the same IDs for the same objects.\n\t\tvar id = o[objectIdName];\n\t\tif (id) {\n\t\t\tif (!ignoreName)\n\t\t\t\treturn id;\n\t\t}\n\t\telse {\n\t\t\t// Generate an ID for the current object, add it to the object.\n\t\t\t// I'd prefer to create a map, but it would need to be keyed by\n\t\t\t// the object, which Rhino doesn't support.\n\t\t\tid = '$^' + nextId.toString(36);\n\t\t\to[objectIdName] = id;\n\t\t\tobjects[id] = o;\n\t\t\tnextId++;\n\t\t}\n\n\t\t// The path this function will take through the object graph won't necessarily\n\t\t// be the path you'd expect.  If you have two sets of objects which reference\n\t\t// each other (e.g. VMs and ESX servers) it can bounce back and forth between\n\t\t// them, recursing further each time, causing a Java stack overflow.  When I\n\t\t// saw this the stack depth was around 5000.  I don't want to defer more than\n\t\t// I need to, but it's better to err on the side of caution - the penalty for\n\t\t// deferring the recursion is fairly small.\n\t\t// Deferring means that we'll stop recursing and create an object ID for an\n\t\t// object which we haven't previously seen.  The object will be saved and\n\t\t// serialized as the root of its own graph later (if necessary).\n\t\tif (depth == 100) {\n\t\t\toutput[id] = o;\n\t\t\tdeferred.push(o);\n\t\t\treturn id;\n\t\t}\n\n\t\t// Walk over an object, decircularizing references as we go.\n\t\t// Keys are sorted so we can ensure we that we will reattach\n\t\t// in the same order as we decircularized.\n\t\tObject.keys(o).sort().forEach(function(name) {\n\t\t\tvar val = o[name];\n\n\t\t\t// Support for a replacer function, similar to JSON.stringify().\n\t\t\tif (replacer)\n\t\t\t\tval = o[name] = replacer(name, val);\n\n\t\t\tif ((typeof val == 'object') && (val !== null)) {\n\t\t\t\tif (val instanceof Packages.java.lang.Object)\n\t\t\t\t\to[name] = undefined;\n\t\t\t\telse\n\t\t\t\t\to[name] = decirc(val, depth + 1);\n\t\t\t}\n\t\t});\n\n\t\treturn o;\n\t}\n}\n\n})();",
      "sys_id": "544bff02930b02007d8a705bb47ffbeb"
    },
    {
      "script": "var RequestAuthSampleMidCustomSigner = Class.create();\nRequestAuthSampleMidCustomSigner.prototype = Object.extend(new RequestAuthInternal(), {\n     \n    initialize:function() {\n\t\tRequestAuthInternal.prototype.initialize.call(this);\n    },\n    \n\t/*Override generateAuth if you are writing your own custom signer.\n\t* It is a sample method to understand how to sign using custom authenticator.\n\t*/\n\tgenerateAuth: function(requestAuthenticator) {\n\t\t\n\t\t//read the request data into instance variables\n\t\tthis.enableDebug(true);\n\t\tthis.readRequestData(requestAuthenticator);\n\t\t\n\t\t//sign the data\n\t\tvar signature = this.generateSignature();\n        var authorizationValue = this.KEY_TYPE + \" \" + this.accountName + \":\" + signature;\n\t\t\n\t\tvar httpRequestSignedData = new Packages.com.snc.core_automation_common.auth.HttpRequestAuthedData();\n        httpRequestSignedData.addHeader( \"Authorization\", authorizationValue);\n        httpRequestSignedData.setStatus(\"SUCCESS\"); //available status values :SUCCESS, FAIL, SKIPPED;\n        httpRequestSignedData.setDirective(\"HEADER\"); //use \"QUERY\" if signed data needs to be sent in query parameters\n        return httpRequestSignedData;\n\t},\n\t\n\tgetStringToSign: function() {\n        var stringToSign = \"\";\n\t\t\n\t\tvar headers = this.getObjectFromMap(this.headerMap);\n\t\tvar headerKeys =  Object.keys(headers);\n\t\tvar headerValue;\n\t\t\n\t\theaderKeys.forEach(function(key) {\n            headerValue = headers[key];\n\t\t\tif(headerValue){\n\t\t\t\tstringToSign += key+\":\"+headerValue+ \"\\n\"; //\"\\n\" is random terminal\n\t\t\t\tif(this.debugMode)\n\t\t\t\t\tms.log(\"Header Key:\"+key+\" Value:\"+headerValue);\n\t\t\t}\n        }.bind(this));\n\t\t\n\t\tvar queryParams = this.getObjectFromMap(this.queryParamMap);\n\t\tvar qpKeys = Object.keys(queryParams);\n\t\tvar qpValue;\n\t\t\n\t\tqpKeys.forEach(function(key) {\n            qpValue = queryParams[key];\n\t\t\tif(qpValue){\n\t\t\t\tstringToSign += key+\":\"+qpValue+ \"\\n\"; //\"\\n\" is random terminal\n\t\t\n\t\t\t\tif(this.debugMode)\t\n\t\t\t\t\tms.log(\"Request Param Key:\"+key+\" Value:\"+qpValue);\n\t\t\t}\n        }.bind(this));\n\t\t\n\t\tif(this.debugMode)\n\t\t\tms.log(\"String to Sign:\"+stringToSign);\n\t\t\t\n        return stringToSign;\n    },\n\t\n\tgenerateSignature: function() {\n        var Mac = Packages.javax.crypto.Mac;\n        var SecretKeySpec = Packages.javax.crypto.spec.SecretKeySpec;\n        var StringUtil = Packages.com.glide.util.StringUtil;\n        var JavaString = Packages.java.lang.String;\n        \n        var algorithm = \"HmacSHA256\";\n        var dataToSign = new JavaString(this.getStringToSign());\n        \n        var mac = Mac.getInstance(\"HmacSHA256\");\n        var secretKey = new SecretKeySpec(StringUtil.base64DecodeAsBytes(this.secretKey), \"HmacSHA256\");\n        mac.init(secretKey);\n        return StringUtil.base64Encode(mac.doFinal(dataToSign.getBytes(\"UTF-8\")));\n    },\n    \n\t/*read request data into instance variables.\n\t* It is a sample method to understand how to read request data\n\t*/\n\treadRequestData: function(requestAuthenticator){\n\t\tvar requestData = requestAuthenticator.getHttpRequestData();\n        this.endpoint = requestData.getEndpoint();\n        this.method = requestData.getHttpMethod().toUpperCase();\n        this.path = this.getPathFromEndpointURL();\n\t\t\n\t\tif(this.debugMode){\n\t\t\tms.log(\"Method:\"+this.method+\" Endpoint:\"+this.endpoint);\n\t\t}\n\t\n        this.queryParamMap = requestData.getQueryParamMap();\n\t\t\n\t\tthis.headerMap = requestData.getHeaderMap();\n\t\t\n        this.payload = requestData.getContent();\n\t\t\n\t\tthis.reqData = requestAuthenticator.getHttpRequestData();\n        // get credential fields if needed, these attributes are different based on credential type\n        var credential = requestAuthenticator.getRequestAuthCredential();\n\t\t//this.accountName = credential.getAttribute(\"access_key\");\n        //this.consumer_key = credential.getAttribute(\"consumer_key\");\n       // this.access_token = credential.getAttribute(\"access_token\");\n       // this.access_token_secret = credential.getAttribute(\"access_token_secret\");\n\t},\n    \n    getObjectFromMap: function(map) {\n        var myObj = {};\n        var iterator = map.keySet().iterator();\n        while (iterator.hasNext()){\n            var key = iterator.next();\n            myObj[key.toLowerCase()] = map.get(key);\n        }\n        return myObj;\n    },\n\t\n\tdebugMode : false,\n\t\n\tenableDebug: function(flag) {\n\t\tthis.debugMode = flag;\n\t},\n\t\n\ttype: 'RequestAuthSampleMidCustomSigner'\n    \n    \n});",
      "sys_id": "63a7021d87633300dee3caf736cb0b3d"
    },
    {
      "script": "/**\n * Parses the output of the \"fcinfo.exe\" command into JS objects, based on command arguments.\n * \n * @since fuji\n * @author roy.laurie\n *\n ** \n * @param {} options Configuration options.\n */\nvar DiscoveryFcInfoParser = function(options) {\n\t// save any configuration options\n};\n\nDiscoveryFcInfoParser.prototype.type = 'DiscoveryFcInfoParser';\n\n/**\n * Parses the output of the \"fcinfo /details\" command and creates a JS object for each\n * row of data provided.\n * @return [] An array of table objects in the format\n */\nDiscoveryFcInfoParser.prototype.parseDetails = function(fcinfoOutputLines) {\n\tvar output = []; // returned\n\tvar currentTable = {};\n\tvar hasFields = false; // keeps track of currentTable status\n\t\n\t// iterate over each trimmed line, new tables via blank lines, and populating the output accordingly.\n\tfor (var l = 0; l < fcinfoOutputLines.length; ++l) {\n\t\tvar line = fcinfoOutputLines[l].trim();\n\t\t\n\t\t// empty lines signify new table\n\t\tif (line.length === 0) {\n\t\t\t// push the previous table into the output obj\n\t\t\tif (hasFields)\n\t\t\t\toutput.push(currentTable);\n\n\t\t\t// create a new table and set it as current\n\t\t\tcurrentTable = {};\n\t\t\thasFields = false;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// table header - create a new current table\n\t\tvar matches = line.match(/^(\\w+): (.*)$/);\n\t\tif (matches === null)\n\t\t\tcontinue;\n\t\t\n\t\t// table field - append the data to the current table\n\t\tcurrentTable[matches[1].trim()] = matches[2].trim(); \n\t\thasFields = true;\n\t}\n\t\n\t// push the last table into output\n\tif (currentTable !== null && hasFields)\n\t\toutput.push(currentTable);\n\t\n\treturn output;\n};\n\n/**\n * @return [] An array of ports in the format: {\n *   { adapter, Type, State, Speed, WWN, PortWWN }\n */\nDiscoveryFcInfoParser.prototype.parsePorts = function(fcinfoOutputLines) {\n\tvar output = [];\n\tvar currentAdapterName = null;\n\t\n\tvar addedEntry = false;\n\tfor (var i = 0; i < fcinfoOutputLines.length; ++i) {\n\t\tvar line = fcinfoOutputLines[i].trim();\n\t\t\n\t\tvar matches = line.match(/^(.+?), num: \\d+/); // adapter header. 1 => adapter name\n\t\tif (matches !== null) {\t\t\t\n\t\t\tcurrentAdapterName = matches[1];\n\t\t\taddedEntry = false;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// handle parsing rows\n\t\tvar columns = line.split(/,/);\n\t\tif (columns.length != 5)\n\t\t\tcontinue;\n\t\t\n\n\t\tif (addedEntry) {\n\t\t\toutput[output.length-1].targetWWNS.push({ WWN: columns[3].trim(), PortWWN: columns[4].trim()});\n\t\t}\n\t\telse {\t\n\t\toutput.push({\n\t\t\tadapter: currentAdapterName,\n\t\t\tType: columns[0].trim(),\n\t\t\tState: columns[1].trim(),\n\t\t\tSpeed: columns[2].trim(),\n\t\t\tWWN: columns[3].trim(),\n\t\t\tPortWWN: columns[4].trim(),\n\t\t\ttargetWWNS: []\n\t\t});\n\t\taddedEntry = true;\n\t\t}\n\t}\n\t\n\treturn output;\n};\n\n/**\n * @return [] An array of adapters in the format: {\n *   { adapter: string, devices: [ DeviceName, B, T, L, mappings: [ FcId, WWNN, RemoteWWN, L ] ] }\n */\nDiscoveryFcInfoParser.prototype.parseFcpMap = function(fcinfoOutputLines) {\n\tvar output = []; // returned\n\tvar currentAdapter = null;\n\tvar currentDevice = null;\n\t\n\t// iterate over each trimmed line\n\tfor (var i = 0; i < fcinfoOutputLines.length; ++i) {\n\t\tvar line = fcinfoOutputLines[i].trim();\n\t\t\n\t\t// example catalog header:\n\t\t// com.qlogoic-QLE2562-0: num: 2\n\t\tvar matches = line.match(/^(.+?): num: \\d+/); // adapter header. 1=> adapter name\n\t\tif (matches !== null) {\n\t\t\tif (currentAdapter !== null)\n\t\t\t\toutput.push(currentAdapter);\n\t\t\t\n\t\t\tcurrentAdapter = { adapter: matches[1].trim(), devices: [] };\n\t\t\tcurrentDevice = null;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// if this is the storage device table, parse the next line - incrementing i\n\t\tif (line.match(/^\\(DeviceName,/) !== null) {\n\t\t\tvar nextLine = fcinfoOutputLines[++i].trim();\n\t\t\t // remove the enclosing ( )\n\t\t\tnextLine = nextLine.substring(1, nextLine.length - 1);\n\t\t\t// split into columns. column names match output\n\t\t\tvar columns = nextLine.split(/,/); \n\t\t\t// create device\n\t\t\tcurrentDevice = {\n\t\t\t\tDeviceName: columns[0].trim(),\n\t\t\t\tB: columns[1].trim(),\n\t\t\t\tT: columns[2].trim(),\n\t\t\t\tL: columns[3].trim(),\n\t\t\t\tmappings: null // initialized later\n\t\t\t};\n\t\t\t\n\t\t\tcurrentAdapter.devices.push(currentDevice);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// parse each mapping row, initializing currentDevice.mappings on the header row\n\t\tif (line.match(/^\\(.*\\)$/) !== null) {\n\t\t\t// if this is the mapping header line, setup the array, then iterate\n\t\t\tif (currentDevice.mappings === null) {\n\t\t\t\tcurrentDevice.mappings = [];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t // remove the enclosing ( )\n\t\t\tline = line.substring(1, line.length - 1);\n\t\t\t// split into columns. column names match output\n\t\t\tvar columns = line.split(/,/); \n\t\t\t// create the mapping. column names match original output\n\t\t\tcurrentDevice.mappings.push({\n\t\t\t\tFcId: columns[0].trim(),\n\t\t\t\tWWN: columns[1].trim(),\n\t\t\t\tPortWWN: columns[2].trim(),\n\t\t\t\tL: columns[3].trim()\n\t\t\t});\n\t\t}\n\t}\n\t\n\tif (currentAdapter !== null)\n\t\toutput.push(currentAdapter);\n\t\n\treturn output;\n};",
      "sys_id": "6553d09237603100dcd445cbbebe5d24"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n \nvar VMWarevCenterESXHostsStorageProbe = Class.create();\n\n(function() {\n\nvar _this,\n\ttrimRegex = /^\\s+|\\s+$/g,\n\tnics = [ ],\n\thbas = [ ],\n\tfcPorts = [ ],\n\tdisks = [ ],\n\tfcDisks = [ ],\n\tiscsiDisks = [ ];\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterESXHostsStorageProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name,\n\t\t\tleftOverMors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\t// The payload size can vary widely for this probe.  I had\n\t\t\t// originally set this to 175 as a conservative estimate based\n\t\t\t// on internal testing, but I have since seen environments where\n\t\t\t// a page size of 5 results in payloads of 2.5 MB.\n\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 5,\n\t\t\thostMorIds = leftOverMors.splice(0, pageSize),\n\t\t\toriginalData = [ ],\n\t\t\tresults = {\n\t\t\t\tcmdb_ci_network_adapter: nics,\n\t\t\t\tcmdb_ci_storage_hba: hbas,\n\t\t\t\tcmdb_ci_fc_port: fcPorts,\n\t\t\t\tcmdb_ci_disk: disks,\n\t\t\t\tcmdb_ci_fc_disk: fcDisks,\n\t\t\t\tcmdb_ci_iscsi_disk: iscsiDisks\n\t\t\t},\n\t\t\tvnicMap = [ {\n\t\t\t\tDevice: 'device',\n\t\t\t\tSpec: {\n\t\t\t\t\tExternalId: 'id',\n\t\t\t\t\tMac: 'mac',\n\t\t\t\t\tIp: {\n\t\t\t\t\t\tDhcp: 'dhcp',\n\t\t\t\t\t\tIpAddress: 'ip',\n\t\t\t\t\t\tSubnetMask: 'subnetMask'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ],\n\t\t\tnicMap = {\n\t\t\t\tPnic: [ {\n\t\t\t\t\tDevice: 'device',\n\t\t\t\t\tMac: 'mac',\n\t\t\t\t\tSpec: {\n\t\t\t\t\t\tIp: {\n\t\t\t\t\t\t\tDhcp: 'dhcp',\n\t\t\t\t\t\t\tIpAddress: 'ip',\n\t\t\t\t\t\t\tSubnetMask: 'subnetMask'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ],\n\t\t\t\tConsoleVnic: vnicMap,\n\t\t\t\tVnic: vnicMap\n\t\t\t},\n\t\t\thostMap = {\n\t\t\t\tdatastore: [ { } ],\n\t\t\t\tconfig: {\n\t\t\t\t\tnetwork: nicMap,\n\t\t\t\t\tstorageDevice: {\n\t\t\t\t\t\tScsiLun: [{\t\t\t // The list of SCSI logical units available on the host. \n\t\t\t\t\t\t\tCanonicalName: 'name',  // Canonical name of the SCSI logical unit.\n\t\t\t\t\t\t\t// Disk partition or extent identifiers refer to this name when referring to a disk.\n\t\t\t\t\t\t\t// Use this property to correlate a partition or extent to a specific SCSI disk.\n\t\t\t\t\t\t\tCapacity: {\n\t\t\t\t\t\t\t\tBlock: 'blocks',\n\t\t\t\t\t\t\t\tBlockSize: 'blockSize'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tkey: 'key',\n\t\t\t\t\t\t\tUuid: 'uuid',\t\t\t// Universally unique identifier for the LUN used to identify ScsiLun across multiple servers.\n\t\t\t\t\t\t\tDisplayName: 'displayName',\n\t\t\t\t\t\t\tModel: 'model',\n\t\t\t\t\t\t\tVendor: 'vendor'\n\t\t\t\t\t\t}],\n\t\t\t\t\t\t// a storage entity that represents a topological path from a host bus adapter to a SCSI logical unit.\n\t\t\t\t\t\t// Each path is unique although each host bus adapter/SCSI logical unit pair can have multiple paths.\n\t\t\t\t\t\tMultipathInfo: {\t\t// The multipath configuration that controls multipath policy for ScsiLuns.\n\t\t\t\t\t\t\t// This data object exists only if path information is available and is configurable. \n\t\t\t\t\t\t\tLun: [ {\t\t\t// List of logical units that can be configured for multipathing. \n\t\t\t\t\t\t\t\tId: 'key',\t\t\t// Identifier of LogicalUnit.  Use this id to configure LogicalUnit multipathing policy\n\t\t\t\t\t\t\t\tLun: 'lun',\t\t\t// SCSI device corresponding to logical unit.\n\t\t\t\t\t\t\t\tPath: [ {\t\t\t// Array of paths available to access this LogicalUnit. \n\t\t\t\t\t\t\t\t\tAdapter: 'adapter',\t// The host bus adapter at one endpoint of this path. \n\t\t\t\t\t\t\t\t\tLun: 'lun',\n\t\t\t\t\t\t\t\t\tTransport: {\t\t// Transport information for the target end of the path. \n\t\t\t\t\t\t\t\t\t\tNodeWorldWideName: 'wwnn',\t// FC: The world wide node name of the target. \n\t\t\t\t\t\t\t\t\t\tPortWorldWideName: 'wwpn',\t// FC: The world wide port name of the target. \n\t\t\t\t\t\t\t\t\t\tIScsiName: 'iqn'\t\t\t// iSCSI: The iSCSI name of the target. \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tHostBusAdapter: [{\t\t // The list of host bus adapters available on the host. \n\t\t\t\t\t\t\tKey: 'key',\t\t\t   // The linkable identifier. \n\t\t\t\t\t\t\tModel: 'model',\t\t\t // The model name of the host bus adapter. \n\t\t\t\t\t\t\tIScsiName: 'name',\t\t\t// ISCSI: The iSCSI name of this host bus adapter.\n\t\t\t\t\t\t\tConfiguredStaticTarget: [{\t// ISCSI: The configured iSCSI static target entries.\n\t\t\t\t\t\t\t\tAddress: 'address'\t\t\t// The IP address or hostname of the storage device.\n\t\t\t\t\t\t\t}],\n\t\t\t\t\t\t\tDevice: 'device',\t\t\t// The device name of host bus adapter.\n\t\t\t\t\t\t\tNodeWorldWideName: 'wwnn',\t// FC: The world wide node name for the adapter.\n\t\t\t\t\t\t\tPortType: 'portType',\t\t\t // FC: The type of the fiber channel port.\n\t\t\t\t\t\t\tPortWorldWideName: 'wwpn',\t// FC: The world wide port name for the adapter.\n\t\t\t\t\t\t\tSpeed: 'speed'\t\t\t\t// FC: The current operating speed of the adapter in bits per second.\n\t\t\t\t\t\t}],\n\t\t\t\t\t\tscsiTopology: {\t\t\t\t// Storage topology view of SCSI storage devices. This data object exists only if storage topology information is available.\n\t\t\t\t\t\t\tadapter: [ {\t\t\t\t// The list of SCSI interfaces.\n\t\t\t\t\t\t\t\tadapter: 'adapter',\t\t\t// The link to data for this SCSI interface.\n\t\t\t\t\t\t\t\ttarget: [ {\t\t\t\t\t// The list of targets to which the SCSI interface is associated.\n\t\t\t\t\t\t\t\t\ttransport: {\t\t\t\t// SCSI Transport information about the target.\n\t\t\t\t\t\t\t\t\t\tNodeWorldWideName: 'wwnn',\t// FC: The world wide node name of the target.\n\t\t\t\t\t\t\t\t\t\tPortWorldWideName: 'wwpn',\t// FC: The world wide port name of the target.\n\t\t\t\t\t\t\t\t\t\tIScsiName: 'iqn'\t\t\t// iSCSI: The iSCSI name of the target.\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlun: [ {\t\t\t\t\t// The list of SCSI logical units with which a target is associated.\n\t\t\t\t\t\t\t\t\t\tlun: 'lun',\t\t\t\t\t// The logical unit number of the SCSI logical unit\n\t\t\t\t\t\t\t\t\t\tscsiLun: 'key'\t\t\t\t// The link to data for this SCSI logical unit.\n\t\t\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\t/*\n\t\tSample data.  Truncated for brevity, so possibly inconsistent:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\"morid\": \"host-1033\",\n\t\t\t\t\"datastore\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"Datastore\",\n\t\t\t\t\t\"morid\": \"datastore-1183\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"Datastore\",\n\t\t\t\t\t\"morid\": \"datastore-184\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"config\": {\n\t\t\t\t  \"network\": {\n\t\t\t\t\t\"Pnic\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"device\": \"vmnic0\",\n\t\t\t\t\t\t\"mac\": \"\",\n\t\t\t\t\t\t\"Spec\": {\n\t\t\t\t\t\t  \"Ip\": {\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t  },\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"device\": \"vmnic1\",\n\t\t\t\t\t\t\"mac\": \"\",\n\t\t\t\t\t\t\"Spec\": {\n\t\t\t\t\t\t  \"Ip\": {\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t],\n\t\t\t\t\t\"ConsoleVnic\": [\n\t\t\t\t\t],\n\t\t\t\t\t\"Vnic\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"device\": \"vmk0\",\n\t\t\t\t\t\t\"Spec\": {\n\t\t\t\t\t\t  \"mac\": \"00:00:00:00:00:99\",\n\t\t\t\t\t\t  \"Ip\": {\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  },\n\t\t\t\t  \"storageDevice\": {\n\t\t\t\t\t\"ScsiLun\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"name\": \"mpx.vmhba0:C0:T0:L0\",\n\t\t\t\t\t\t\"uuid\": \"0005000000766d686261303a303a30\",\n\t\t\t\t\t\t\"displayName\": \"Local HL-DT-ST CD-ROM (mpx.vmhba0:C0:T0:L0)\",\n\t\t\t\t\t\t\"model\": \"DVD-ROM GDR-D10N\",\n\t\t\t\t\t\t\"vendor\": \"HL-DT-ST\"\n\t\t\t\t\t  },\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"name\": \"mpx.vmhba1:C0:T0:L0\",\n\t\t\t\t\t\t\"Capacity\": {\n\t\t\t\t\t\t  \"blocks\": 1146734896,\n\t\t\t\t\t\t  \"blockSize\": 512\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"uuid\": \"0000000000766d686261313a303a30\",\n\t\t\t\t\t\t\"displayName\": \"Local VMware Disk (mpx.vmhba1:C0:T0:L0)\",\n\t\t\t\t\t\t\"model\": \"Block device    \",\n\t\t\t\t\t\t\"vendor\": \"VMware  \"\n\t\t\t\t\t  }\n\t\t\t\t\t],\n\t\t\t\t\t\"MultipathInfo\": {\n\t\t\t\t\t  \"Lun\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  \"id\": \"0000000000766d686261313a303a30\",\n\t\t\t\t\t\t  \"lun\": \"key-vim.host.ScsiDisk-0000000000766d686261313a303a30\",\n\t\t\t\t\t\t  \"Path\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t  \"adapter\": \"key-vim.host.BlockHba-vmhba1\",\n\t\t\t\t\t\t\t  \"lun\": \"key-vim.host.MultipathInfo.LogicalUnit-0000000000766d686261313a303a30\",\n\t\t\t\t\t\t\t  \"Transport\": {\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  ]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  \"id\": \"0005000000766d686261303a303a30\",\n\t\t\t\t\t\t  \"lun\": \"key-vim.host.ScsiLun-0005000000766d686261303a303a30\",\n\t\t\t\t\t\t  \"Path\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t  \"adapter\": \"key-vim.host.BlockHba-vmhba0\",\n\t\t\t\t\t\t\t  \"lun\": \"key-vim.host.MultipathInfo.LogicalUnit-0005000000766d686261303a303a30\",\n\t\t\t\t\t\t\t  \"Transport\": {\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  ]\n\t\t\t\t\t\t}\n\t\t\t\t\t  ]\n\t\t\t\t\t},\n\t\t\t\t\t\"HostBusAdapter\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"key\": \"key-vim.host.BlockHba-vmhba0\",\n\t\t\t\t\t\t\"model\": \"631xESB\\/632xESB IDE Controller\",\n\t\t\t\t\t\t\"ConfiguredStaticTarget\": [\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"device\": \"vmhba0\"\n\t\t\t\t\t  },\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"key\": \"key-vim.host.BlockHba-vmhba1\",\n\t\t\t\t\t\t\"model\": \"Smart Array P400\",\n\t\t\t\t\t\t\"ConfiguredStaticTarget\": [\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"device\": \"vmhba1\"\n\t\t\t\t\t  },\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"key\": \"key-vim.host.BlockHba-vmhba32\",\n\t\t\t\t\t\t\"model\": \"631xESB\\/632xESB IDE Controller\",\n\t\t\t\t\t\t\"ConfiguredStaticTarget\": [\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"device\": \"vmhba32\"\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of hosts we're going to explore\n\t\thostMorIds.forEach(\n\t\t\tfunction(hostMor) {\n\t\t\t\tvar host,\n\t\t\t\t\tmor = new vim25.ManagedObjectReference();\n\n\t\t\t\ttry {\n\t\t\t\t\t// Create a managed object for the current host, fetch data for its storage devices from vCenter.\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.HostSystem.html\n\t\t\t\t\tmor.setType('HostSystem');\n\t\t\t\t\tmor.setVal(hostMor.morid || hostMor);\n\t\t\t\t\thost = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\thost = _this.getPropsForManagedObject(host, hostMap);\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(host));\n\n\t\t\t\t\t// Fixup the data.  \n\t\t\t\t\tfixHostSystem(host);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing HostSystem ' + (hostMor.morid || hostMor) + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (debug)\n\t\t\tresults.originalData = originalData.map(JSON.parse);\n\n\t\t// We fetched at most pageSize hosts.  Send back the IDs of remaining hosts so the\n\t\t// sensor can fire another probe.\n\t\tif (leftOverMors.length)\n\t\t\tresults.leftOverMors = leftOverMors;\n\n\t\t// Stringify the results, dropping anything named 'mo' (these are vijava ManagedObjects)\n\t\tthis.output = JSON.stringify(results, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterESXHostsStorageProbe'\n});\n\nfunction fixHostSystem(esx) {\n\tvar config = esx.config,\n\t\tstorageDevice = config.storageDevice,\n\t\tnetwork = config.network,\n\t\thbaRecs = { },\n\t\thbaMap = { },\n\t\tscsiLuns = { },\n\t\tlunMap = { };\n\n\tesx.datastore = esx.datastore.map(function(ds) { return ds.morid; });\n\n\tnetwork.Pnic.forEach(function(nic) { createNic(esx, nic, false); });\n\tnetwork.Vnic.forEach(function(nic) { createNic(esx, nic, true); });\n\tnetwork.ConsoleVnic.forEach(function(nic) { createNic(esx, nic, true); });\n\n\tstorageDevice.HostBusAdapter.forEach(createHba);\n\t// Map scsi luns so we can get capacity & canonical name\n\tstorageDevice.ScsiLun.forEach(function(scsiLun) { scsiLuns[scsiLun.uuid] = scsiLuns[scsiLun.key] = scsiLun; });\n\tstorageDevice.MultipathInfo && storageDevice.MultipathInfo.Lun.forEach(createMultipathLun);\n\tstorageDevice.scsiTopology && storageDevice.scsiTopology.adapter && createPassThruLuns(storageDevice.scsiTopology.adapter);\n\n\tfunction createHba(hba) {\n\t\tvar rec,\n\t\t\tkey = hba.key;\n\n\t\thbaMap[key] = hba;\n\n\t\tif (!hba.wwnn)\n\t\t\treturn;\n\n\t\tif (!hbaRecs[key]) {\n\t\t\trec = {\n\t\t\t\tname: hba.device,\n\t\t\t\tdevice_id: hba.device,\n\t\t\t\twwnn: hba.wwnn,\n\t\t\t\tcomputerMorid: esx.morid,\n\t\t\t\tmodel_id: hba.model\n\t\t\t};\n\n\t\t\thbaRecs[key] = rec;\n\t\t\trec.idx = hbas.push(rec) - 1;\n\t\t}\n\n\t\trec = hbaRecs[key];\n\t\tfcPorts.push({\n\t\t\twwpn: hba.wwpn,\n\t\t\twwnn: hba.wwnn,\n\t\t\tspeed: hba.speed,\n\t\t\tcontroller: rec.idx\n\t\t});\n\t}\n\n\tfunction createMultipathLun(lun) {\n\t\tvar paths = lun.Path;\n\n\t\tif (!paths || !paths[0])\n\t\t\treturn;\n\n\t\tpaths && paths.forEach(function(path) {\n\t\t\tif (!path) return;                // Just in case...\n\n\t\t\tvar target,\n\t\t\t\ttransport = path.Transport,\n\t\t\t\thba = hbaMap[path.adapter],\n\t\t\t\tiqn = transport.iqn,\n\t\t\t\twwnn = transport.wwnn,\n\t\t\t\twwpn = transport.wwpn;\n\n\t\t\tcreateLun(lun, hba, wwnn, wwpn, iqn);\n\t\t});\n\t}\n\n\tfunction createPassThruLuns(adapters) {\n\t\tadapters.forEach(function(adapter) {\n\t\t\tvar hba = hbaMap[adapter.adapter];\n\n\t\t\tadapter.target && adapter.target.forEach(function(target) {\n\t\t\t\tvar transport = target.transport,\n\t\t\t\t\tiqn = transport && transport.iqn,\n\t\t\t\t\twwnn = transport && transport.wwnn,\n\t\t\t\t\twwpn = transport && transport.wwpn;\n\n\t\t\t\tif (!target.lun || !transport || (!wwpn && !iqn))\n\t\t\t\t\treturn;\n\n\t\t\t\ttarget.lun.forEach(function(lun) { createLun(lun, hba, wwnn, wwpn, iqn); });\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction createLun(lun, hba, wwnn, wwpn, iqn) {\n\t\tvar rec, iScsiTarget,\n\t\t\tlist = disks,\n\t\t\tscsiLun = scsiLuns[lun.key],\n\t\t\tcapacity = scsiLun && scsiLun.Capacity;\n\n\t\t// The vSphere API uses one of two object types to represent a SCSI logical unit, depending on the device type.\n\t\t// * Disks containing file system volumes or parts of volumes for hosts or raw disks for virtual machines.\n\t\t// To represent disks, the ESX Server creates a HostScsiDisk object, which inherits properties from the ScsiLun base class.\n\t\t// * Other SCSI devices, for example SCSI passthrough devices for virtual machines. To represent one of these devices,\n\t\t// the ESX Server creates a ScsiLun object.\n\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.host.ScsiLun.html\n\t\tif (!capacity || !capacity.blockSize) // Capacity is on HostScsiDisk, meaning the device isn't a SCSI passthrough device.\n\t\t\treturn;\n\n\t\trec = lunMap[scsiLun.name] ||\n\t\t\t{\n\t\t\tcomputer: esx.morid,\n\t\t\tsize_bytes: (capacity.blocks * capacity.blockSize) || 0,\n\t\t\tdevice_id: scsiLun.name,\n\t\t\tcorrelation_id: scsiLun.uuid,\n\t\t\tname: scsiLun.displayName || scsiLun.name,\n\t\t\tvendor: scsiLun.vendor ? scsiLun.vendor.replace(trimRegex, '') : undefined,\n\t\t\tmodel: scsiLun.model ? scsiLun.model.replace(trimRegex, '') : undefined,\n\t\t\tdatastores: esx.datastore\n\t\t};\n\n\t\t// Set this here so we'll update existing records - the lun in multipathinfo is a vmware key and\n\t\t// we need to update it from scsiTopology.\n\t\trec.device_lun = lun.lun;\n\n\t\tif (iqn) {\n\t\t\tlist = iscsiDisks;\n\t\t\trec.iqn = iqn;\n\t\t\trec.device_lun = lun.lun; // Documented as 'SCSI device corresponding to logical unit. '\n\t\t\trec.device_interface = 'iscsi';\n\t\t\trec.storage_type = 'network';\n\t\t\tif (hba) {\n\t\t\t\trec.initiator_iqn = hba.name;\n\t\t\t\tiScsiTarget = hba.ConfiguredStaticTarget;\n\t\t\t\tiScsiTarget = iScsiTarget && iScsiTarget[0];\n\t\t\t\trec.target_ip = iScsiTarget && iScsiTarget.address;\n\t\t\t}\n\t\t} else if (wwnn) {\n\t\t\tlist = fcDisks;\n\t\t\trec.device_interface = 'fc';\n\t\t\trec.storage_type = 'network';\n\n\t\t\trec.targets = rec.targets || { };\n\t\t\trec.targets[wwnn] = rec.targets[wwnn] || { };\n\t\t\trec.targets[wwnn][wwpn] = 1;\n\n\t\t\tif (hba) {\n\t\t\t\trec.initiators = rec.initiators || { };\n\t\t\t\trec.initiators[hba.wwnn] = rec.initiators[hba.wwnn] || { };\n\t\t\t\trec.initiators[hba.wwnn][hba.wwpn] = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!lunMap[scsiLun.name]) {\n\t\t\tlist.push(rec);\n\t\t\tlunMap[scsiLun.name] = rec;\n\t\t}\n\t}\n}\n\nfunction createNic(esx, nic, virtual) {\n\tvar spec = nic.Spec,\n\t\tip = spec && spec.Ip;\n\n\tnics.push({\n\t\tname: nic.device,\n\t\tmac_address: nic.mac || (spec && spec.mac),  // Ugh. Data is different for virtual vs. physical\n\t\tip_address: (ip && ip.ip) || undefined,\n\t\tnetmask: (ip && ip.subnetMask) || undefined,\n\t\tcmdb_ci: esx.morid,\n\t\tvirtual: virtual ? 1 : undefined,\n\t\tdhcp_enabled: ip && ip.dhcp ? 1 : undefined\n\t});\n}\n\n})();",
      "sys_id": "6c522b788f731200c2fe0b5437bdee99"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\nvar VMWarevCenterDatastoresProbe = Class.create();\n\n(function() {\n\nvar _this, debug,\n\toriginalData = [ ],\n\tgigabyte = 1024*1024*1024,\n\thostmounts = [ ],\n\tdatastores = [ ],\n\tdisks = [ ],\n\tdatastoreMapByMorId = { },\n\tpods = [ ],\n\toutput = {\n\t\tcmdb_ci_vcenter_datastore: datastores,\n\t\tvcenter_datastore_hostmount: hostmounts,\n\t\tcmdb_ci_vcenter_datastore_disk: disks\n\t},\n\thostDiskDataMap = {\n\t\tconfig: {\n\t\t\tstorageDevice: {\n\t\t\t\tscsiLun: [{\n\t\t\t\t\tCanonicalName: 'name',\n\t\t\t\t\tuuid: 'uuid',\n\t\t\t\t\tcapacity: {\n\t\t\t\t\t\tBlock: 'blocks',\n\t\t\t\t\t\tBlockSize: 'blockSize'\n\t\t\t\t\t}\n\t\t\t\t}]\n\t\t\t}\n\t\t}\n\t};\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterDatastoresProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name,\n\t\t\tleftOverMors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\t// Average measured size of a datastore (with mounts and disks) is\n\t\t\t// 1000 bytes.  Default page size of 500 leaves us well below the\n\t\t\t// 5 MB limit.\n\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 500,\n\t\t\tdatastoreMorIds = leftOverMors.splice(0, pageSize),\n\t\t\tstoragepodMap = {\n\t\t\t\tchildEntity: [ { name: 'name' } ],\n\t\t\t\tsummary: {\n\t\t\t\t\tcapacity: 'capacity',\n\t\t\t\t\tfreeSpace: 'freespace',\n\t\t\t\t\tname: 'name'\n\t\t\t\t}\n\t\t\t},\n\t\t\tdatastoreMap = {\n\t\t\t\tsummary: {\n\t\t\t\t\taccessible: function(value, o) { o.accessible = !!value.isAccessible(); },\n\t\t\t\t\tcapacity: 'capacity',\n\t\t\t\t\tfreeSpace: 'freespace',\n\t\t\t\t\tname: 'name',\n\t\t\t\t\ttype: 'type',\n\t\t\t\t\turl: 'url'\n\t\t\t\t},\n\t\t\t\t'capability.perFileThinProvisioningSupported': 'thin',\n\t\t\t\tvm: [ { } ],\n\t\t\t\thost: [ {\n\t\t\t\t\t\tmountInfo: {\n\t\t\t\t\t\t\taccessible: 'accessible',\n\t\t\t\t\t\t\taccessMode: 'accessMode'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tkey: { }\n\t\t\t\t\t} ],\n\t\t\t\tinfo: {\n\t\t\t\t\tvmfs: {\n\t\t\t\t\t\tuuid: 'uuid',\n\t\t\t\t\t\tlocal: 'local',\n\t\t\t\t\t\textent: [ {\n\t\t\t\t\t\t\tdiskName: 'diskname',\n\t\t\t\t\t\t\tpartition: 'partition'\n\t\t\t\t\t\t} ]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdatamap = {\n\t\t\t\tStoragePod: storagepodMap,\n\t\t\t\tDatastore: datastoreMap\n\t\t\t};\n\n\t\tdebug = ('' + probe.getParameter('debug')) == 'true';\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\t/*\n\t\tSample data.  Truncated for brevity, so possibly inconsistent:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"type\": \"Datastore\",\n\t\t\t\t\"morid\": \"datastore-170\",\n\t\t\t\t\"summary\": {\n\t\t\t\t  \"accessible\": false,\n\t\t\t\t  \"capacity\": 1099511627776,\n\t\t\t\t  \"freespace\": 824633720832,\n\t\t\t\t  \"name\": \"SANLAB1DS_DC0_C0_0\",\n\t\t\t\t  \"type\": \"VMFS\",\n\t\t\t\t  \"url\": \"ds:\\/\\/\\/vmfs\\/volumes\\/527018c7-5acd-a0b9-ec8e-56c691d9c139\\/\"\n\t\t\t\t},\n\t\t\t\t\"thin\": true,\n\t\t\t\t\"vm\": [\n\n\t\t\t\t],\n\t\t\t\t\"host\": [\n\t\t\t\t  {\n\t\t\t\t\t\"mountInfo\": {\n\t\t\t\t\t  \"accessible\": true,\n\t\t\t\t\t  \"accessMode\": \"readWrite\"\n\t\t\t\t\t},\n\t\t\t\t\t\"key\": {\n\t\t\t\t\t  \"type\": \"HostSystem\",\n\t\t\t\t\t  \"morid\": \"host-1405\",\n\t\t\t\t\t  \"config\": {\n\t\t\t\t\t\t\"storageDevice\": {\n\t\t\t\t\t\t  \"scsiLun\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t  \"name\": \"mpx.vmhba0:C0:T0:L0\",\n\t\t\t\t\t\t\t  \"uuid\": \"0005000000766d686261303a303a30\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t  \"name\": \"mpx.vmhba1:C0:T0:L0\",\n\t\t\t\t\t\t\t  \"uuid\": \"0000000000766d686261313a303a30\",\n\t\t\t\t\t\t\t  \"capacity\": {\n\t\t\t\t\t\t\t\t\"blocks\": 1146734896,\n\t\t\t\t\t\t\t\t\"blockSize\": 512\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  ]\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"mountInfo\": {\n\t\t\t\t\t  \"accessible\": true,\n\t\t\t\t\t  \"accessMode\": \"readWrite\"\n\t\t\t\t\t},\n\t\t\t\t\t\"key\": {\n\t\t\t\t\t  \"type\": \"HostSystem\",\n\t\t\t\t\t  \"morid\": \"host-799\",\n\t\t\t\t\t  \"config\": {\n\t\t\t\t\t\t\"storageDevice\": {\n\t\t\t\t\t\t  \"scsiLun\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t  \"name\": \"mpx.vmhba0:C0:T0:L0\",\n\t\t\t\t\t\t\t  \"uuid\": \"0005000000766d686261303a303a30\"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t  \"name\": \"mpx.vmhba1:C0:T0:L0\",\n\t\t\t\t\t\t\t  \"uuid\": \"0000000000766d686261313a303a30\",\n\t\t\t\t\t\t\t  \"capacity\": {\n\t\t\t\t\t\t\t\t\"blocks\": 1146734896,\n\t\t\t\t\t\t\t\t\"blockSize\": 512\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t  ]\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"info\": {\n\t\t\t\t  \"vmfs\": {\n\t\t\t\t\t\"uuid\": \"527018c7-5acd-a0b9-ec8e-56c691d9c139\",\n\t\t\t\t\t\"extent\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"diskname\": \"mpx.vmhba1:C0:T0:L0\",\n\t\t\t\t\t\t\"partition\": 3\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of datastores we're going to explore\n\t\tdatastoreMorIds.forEach(\n\t\t\tfunction(ds) {\n\t\t\t\ttry {\n\t\t\t\t\tvar mor = new vim25.ManagedObjectReference();\n\n\t\t\t\t\t// Create a managed object for the current datastore, fetch data for it and its\n\t\t\t\t\t// host mounts and disks from vCenter.\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.Datastore.html\n\t\t\t\t\tmor.setType(ds.type);\n\t\t\t\t\tmor.setVal(ds.morid);\n\t\t\t\t\tds = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\tds = _this.getPropsForUnknownType(ds, datamap);\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(ds));\n\n\t\t\t\t\tfixDatastore(ds);\n\t\t\t\t\tdatastores.push(ds);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing ' + ds.type + ' ' + ds.morid + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\tpods.forEach(function(pod) {\n\t\t\tpod.stores = pod.childEntity.map(function(ds) { return datastoreMapByMorId[ds.morid]; });\n\t\t\tpod.childEntity = undefined;\n\t\t});\n\n\t\t// We fetched at most pageSize datastores.  Send back the IDs of remaining datastores so the\n\t\t// sensor can fire another probe.\n\t\tif (leftOverMors.length)\n\t\t\toutput.leftOverMors = leftOverMors;\n\n\t\tif (debug)\n\t\t\toutput.originalData = originalData.map(JSON.parse);\n\t\t\n\t\t// Stringify the results, dropping anything named 'mo' (these are vijava ManagedObjects)\n\t\tthis.output = JsonCi.decircularize(output, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterDatacentersProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixDatastore(ds) {\n\tvar name,\n\t\textent = ds.info.vmfs.extent,\n\t\thostdisks = { },\n\t\thostKeys = [ ];\n\n\tdelete ds.info;\n\n\tfor (name in ds.summary)\n\t\tds[name] = ds.summary[name];\n\tdelete ds.summary;\n\n\tds.capacity = (ds.capacity / gigabyte) | 0;\n\tds.freespace = (ds.freespace / gigabyte) | 0;\n\n\tif (ds.type == 'StoragePod') {\n\t\tds.clustered = true;\n\t\tdelete ds.type;\n\t\tpods.push(ds);\n\t\treturn;\n\t}\n\n\tdatastoreMapByMorId[ds.morid] = ds;\n\tds.host.forEach(\n\t\tfunction(hostMount) {\n\t\t\thostKeys.push(hostMount.key);\n\t\t\thostMount.host = hostMount.key.morid;\n\t\t\thostMount.accessible = hostMount.mountInfo.accessible;\n\t\t\thostMount.access_mode = hostMount.mountInfo.accessMode;\n\t\t\thostMount.datastore = ds;\n\t\t\thostmounts.push(hostMount);\n\t\t\tdelete hostMount.key;\n\t\t\tdelete hostMount.mountInfo;\n\t\t});\n\n\textent && extent.forEach(function(disk, idx) {\n\t\tvar dsd, lun;\n\n\t\twhile (!hostdisks.hasOwnProperty(disk.diskname) && hostKeys.length)\n\t\t\tgetDisksForHost(hostKeys.pop());\n\n\t\tlun = hostdisks[disk.diskname];\n\n\t\tif (lun) {\n\t\t\tdsd = {\n\t\t\t\tdatastore: ds,\n\t\t\t\tname: disk.diskname,\n\t\t\t\tcorrelation_id: lun.uuid,\n\t\t\t};\n\t\t\tif (lun.capacity)\n\t\t\t\tdsd.size_bytes = lun.capacity.blockSize * lun.capacity.blocks;\n\n\t\t\tdisks.push(dsd);\n\t\t} else\n\t\t\t_this.probe.appendWarning('Couldn\\'t find disk for datastore ' + ds.name + ' extent '+ disk.diskname);\n\t});\n\n\tds.vm.forEach(\n\t\tfunction(vm, idx) {\n\t\t\tds.vm[idx] = vm.morid;\n\t\t});\n\n\tfunction getDisksForHost(key) {\n\t\tvar host, hostConfig,\n\t\t\tmor = new vim25.ManagedObjectReference();\n\n\t\tmor.setType(key.type);\n\t\tmor.setVal(key.morid);\n\t\thost = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\thostConfig = _this.getPropsForManagedObject(host, hostDiskDataMap);\n\n\t\tif (debug)\n\t\t\toriginalData.push(JSON.stringify(hostConfig));\n\n\t\thostConfig.config.storageDevice.scsiLun.forEach(\n\t\t\tfunction(lun) {\n\t\t\t\thostdisks[lun.name] = lun;\n\t\t\t});\n\t}\n}\n\n})();",
      "sys_id": "6c5fb0ef93c31200c2fe705bb47ffbaa"
    },
    {
      "script": "/**\n * Expose the SSHProviderTerminal Java API\n */\n\nvar SSHProviderTerminal = Packages.com.snc.sw.providers.SSHProviderTerminal;\nvar DiscoveryProviderFactory = Packages.com.snc.sw.providers.DiscoveryProviderFactory;\nvar ProviderType = Packages.com.snc.sw.dto.ProviderType;\nvar AuthenticationFailureException = Packages.com.snc.sw.exception.AuthenticationFailureException;\n/**\n * Java imports\n */\nvar URL = Packages.java.net.URL;\nvar HashMap = Packages.java.util.HashMap;\nvar Map = Packages.java.util.Map;\nvar List = Packages.java.util.List;\nvar ArrayList = Packages.java.util.ArrayList;\n\n/**\n * Service-now.com imports\n */\nvar MIDServer = Packages.com.service_now.mid.MIDServer;\nvar Credential = Packages.com.snc.automation_common.integration.creds.Credential;\nvar CredentialType = Packages.com.snc.automation_common.integration.creds.CredentialType;\nvar MIDScript = Packages.com.service_now.mid.script.MIDScript;\nvar MIDScriptType = Packages.com.service_now.mid.script.MIDScriptType;\nvar IPAddressUtil = Packages.com.glide.util.IPAddressUtil;\nvar SOURCE = Packages.com.glide.util.IConstants.SOURCE;\nvar escape = Packages.com.glide.util.StringUtil.escapeTitle;\nvar nil = Packages.com.glide.util.StringUtil.nil;\n",
      "sys_id": "7427eb5293d10200084135bb357ffb5d"
    },
    {
      "script": "var GenerateWMIScriptJS = Class.create();\r\n\r\nGenerateWMIScriptJS.prototype = {\r\n\r\n    initialize : function(fields) {\r\n        this.fields = fields;\r\n    },\r\n\r\n    generateScript: function() {\r\n        var wmiFields = this.fields.split(\",\");\r\n\r\n\tvar scriptValue = \"var scanner = getScanner();\\n\" +\r\n                          \"if (scanner) {\\n\";\r\n\r\n\tfor (var i = 0; i < wmiFields.length; i++) {\r\n            var path = wmiFields[i];\r\n            path = path.replace(/'/g, \"\");\r\n            path = path.replace(/\\\\/g, '\\\\\\\\');\r\n            scriptValue +=\t\"    scanner.addFetch('\" + path + \"');\\n\";\r\n        }\r\n\r\n        scriptValue += \"    scanner.fetch();\\n\" +\r\n                       \"}\\n\";\r\n\r\n\treturn scriptValue;\r\n    },\r\n\r\n    type: \"GenerateWMIScriptJS\"\r\n}",
      "sys_id": "78d5b1d20a000483009c638af616cd41"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n \nvar VMWarevCenterESXHostsProbe = Class.create();\n\n(function() {\n\nvar _this,\n\toutput = { },\n\tIPHost = Packages.com.snc.commons.networks.IPHost,\n\tdsMap = { 'summary.capacity': 'capacity' },\n\tdsSizes = { },\n\tdvpgDatamap = {\n\t\tconfig: {\n\t\t\tdistributedVirtualSwitch: { }\n\t\t}\n\t};\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterESXHostsProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name,\n\t\t\tleftOverMors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\t// Average measured size of a host is 1400 bytes, but the page\n\t\t\t// size for the storage probe varies widely.  That page size is\n\t\t\t// set to 5 for safety.  I'm defaulting this to 10 just to keep\n\t\t\t// the number of host probes similar to the number of storage\n\t\t\t// probes.\n\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 10,\n\t\t\thostMorIds = leftOverMors.splice(0, pageSize),\n\t\t\toriginalData = [ ],\n\t\t\tresults = { cmdb_ci_esx_server: [ ] },\n\t\t\thostMap = {\n\t\t\t\tname: 'name',\n\t\t\t\tsummary: {\n\t\t\t\t\thardware: {\n\t\t\t\t\t\tuuid: 'correlation_id',\n\t\t\t\t\t\tcpuMhz: 'cpu_speed',\n\t\t\t\t\t\tmodel: 'model_id',\n\t\t\t\t\t\tmemorySize: 'ram',\n\t\t\t\t\t\tnumCpuPkgs: 'cpu_count',\n\t\t\t\t\t\tnumCpuCores: 'cpu_core_count',\n\t\t\t\t\t\tvendor: 'manufacturer', \n\t\t\t\t\t\tcpuModel: 'cpu_type',\n\t\t\t\t\t\t\n\t\t\t\t\t},\n\t\t\t\t\tmanagementServerIp : 'vcenter_ip'\n\t\t\t\t},\n\t\t\t\thardware: {\n\t\t\t\t\tcpuPkg: [ { vendor: 'cpu_manufacturer' } ],\n\t\t\t\t\tSystemInfo: {\n\t\t\t\t\t\tOtherIdentifyingInfo: [ {\n\t\t\t\t\t\t\tIdentifierType: {\n\t\t\t\t\t\t\t\tKey: 'key'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tIdentifierValue: 'value'\n\t\t\t\t\t\t}]\n\t\t\t\t\t},\n\t\t\t\t\tcpuInfo: {\n\t\t\t\t\t\tnumCpuThreads: 'logical_processor'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'config.product.fullName': 'os_version',\n\t\t\t\t'config.hyperThread.active': 'hyper_threading',\n\t\t\t\truntime: {\n\t\t\t\t\tbootTime: 'start_date',\n\t\t\t\t\tpowerState: 'power_state',\n\t\t\t\t\tconnectionState: 'connection_state',\n\t\t\t\t\tinMaintenanceMode: 'maintenance'\n\t\t\t\t},\n\t\t\t\tnetwork: [ { } ],\n\t\t\t\tdatastore: [ { } ],\n\t\t\t\tvm: [ { } ],\n\t\t\t\tparent: { },\n\t\t\t};\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\t/*\n\t\tSample data.  Truncated for brevity, so possibly inconsistent:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\"morid\": \"host-1025\",\n\t\t\t\t\"name\": \"DC0_C14_H4\",\n\t\t\t\t\"summary\": {\n\t\t\t\t  \"hardware\": {\n\t\t\t\t\t\"correlation_id\": \"33393138-3335-5553-4537-32324e35394b\",\n\t\t\t\t\t\"cpu_speed\": 2999,\n\t\t\t\t\t\"model_id\": \"ProLiant DL380 G5\",\n\t\t\t\t\t\"ram\": 17175269376,\n\t\t\t\t\t\"cpu_count\": 2,\n\t\t\t\t\t\"cpu_core_count\": 4,\n\t\t\t\t\t\"manufacturer\": \"HP\",\n\t\t\t\t\t\"cpu_type\": \"Intel(R) Xeon(R) CPU            5160  @ 3.00GHz\"\n\t\t\t\t  }\n\t\t\t\t},\n\t\t\t\t\"hardware\": {\n\t\t\t\t  \"cpuPkg\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"cpu_manufacturer\": \"intel\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t  \"cpu_manufacturer\": \"intel\"\n\t\t\t\t\t}\n\t\t\t\t  ],\n\t\t\t\t  \"SystemInfo\": {\n\t\t\t\t\t\"OtherIdentifyingInfo\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"IdentifierType\": {\n\t\t\t\t\t\t  \"key\": \"AssetTag\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"value\": \" unknown\"\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  }\n\t\t\t\t},\n\t\t\t\t\"install_status\": false,\n\t\t\t\t\"os_version\": \"VMware ESX 5.0.0 build-5.0.0.19\",\n\t\t\t\t\"network\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"Network\",\n\t\t\t\t\t\"morid\": \"network-7\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"DistributedVirtualPortgroup\",\n\t\t\t\t\t\"morid\": \"dvportgroup-9\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"datastore\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"Datastore\",\n\t\t\t\t\t\"morid\": \"datastore-63\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"Datastore\",\n\t\t\t\t\t\"morid\": \"datastore-1177\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"vm\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\t\"morid\": \"vm-5812\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\t\"morid\": \"vm-4443\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"parent\": {\n\t\t\t\t  \"type\": \"ClusterComputeResource\",\n\t\t\t\t  \"morid\": \"domain-c105\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of hosts we're going to explore\n\t\thostMorIds.forEach(\n\t\t\tfunction(host) {\n\t\t\t\tvar table,\n\t\t\t\t\tmor = new vim25.ManagedObjectReference();\n\n\t\t\t\ttry {\n\t\t\t\t\t// Create a managed object for the current host, fetch data for it from vCenter.\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.HostSystem.html\n\t\t\t\t\tmor.setType('HostSystem');\n\t\t\t\t\tmor.setVal(host.morid || host);\n\t\t\t\t\thost = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\thost = _this.getPropsForManagedObject(host, hostMap);\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(host));\n\n\t\t\t\t\tfixHost(host);\n\t\t\t\t\tresults.cmdb_ci_esx_server.push(host);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing HostSytem ' + host + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\tif (debug)\n\t\t\tresults.originalData = originalData.map(JSON.parse);\n\t\t\n\t\t// We fetched at most pageSize hosts.  Send back the IDs of remaining hosts so the\n\t\t// sensor can fire another probe.\n\t\tif (leftOverMors.length)\n\t\t\tresults.leftOverMors = leftOverMors;\n\n\t\tthis.output = JSON.stringify(results, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterESXHostsProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixHost(host) {\n\tvar name, mor, dvpg,\n\t\tips = new IPHost(host.name).resolveAddress(),\n\t\thardware = host.hardware,\n\t\tsi = hardware && hardware.SystemInfo,\n\t\toi = si && si.OtherIdentifyingInfo,\n\t\truntime = host.runtime;\n\t\n\tfor (name in host.summary.hardware)\n\t\thost[name] = host.summary.hardware[name];\n\thost.vcenter_ip =  host.summary.vcenter_ip;\n\tdelete host.summary;\n\n\tif (ips.length > 0)\n\t\thost.ip_address = '' + ips[0].toString();\n\t\n\thost.cpu_core_count /= host.cpu_count;\n\n\thost.cpu_manufacturer = host.hardware.cpuPkg[0].cpu_manufacturer;\n\n\tif (oi) {\n\t\toi.forEach(function(id) {\n\t\t\tvar fieldname,\n\t\t\t\tval = id.value,\n\t\t\t\tkey = id.IdentifierType;\n\n\t\t\tif (val && (key.key == 'ServiceTag'))\n\t\t\t\thost.serial_number = val;\n\t\t});\n\t}\n\t\n\thost.logical_processor = hardware.cpuInfo.logical_processor;\n\t\n\tdelete host.hardware;\n\t\n\thost.start_date = runtime.start_date;\n\thost.power_state = runtime.power_state;\n\thost.connection_state = runtime.connection_state;\n\thost.install_status = runtime.maintenance ? '3' : '1';// Maintenance = 3, Installed = 1\n\t\n\tdelete host.runtime;\n\n\thost.ram = (host.ram/(1024*1024)) | 0;\n\n\thost.cluster = [ host.parent.morid ];\n\tdelete host.parent;\n\n\thost.network.forEach(\n\t\tfunction(network) {\n\t\t\tif (network.type == 'DistributedVirtualPortgroup') {\n\t\t\t\tmor = new vim25.ManagedObjectReference();\n\t\t\t\tmor.setType(network.type);\n\t\t\t\tmor.setVal(network.morid);\n\t\t\t\tdvpg = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\tdvpg = _this.getPropsForManagedObject(dvpg, dvpgDatamap);\n\t\t\t\tif (dvpg.config && dvpg.config.distributedVirtualSwitch)\n\t\t\t\t\thost.cmdb_ci_vcenter_dvs = dvpg.config.distributedVirtualSwitch.morid;\n\t\t\t}\n\t\t});\n\n\textractMORs(host.datastore);\n\textractMORs(host.network);\n\textractMORs(host.vm);\n\t\n\thost.disk_space = 0;\n\thost.datastore.forEach(\n\t\tfunction(ds) {\n\t\t\thost.disk_space += (getDatastoreCapacity(ds) / (1024*1024*1024));\n\t\t});\n\n\t// Bitwise OR with 0 is an easy way to ensure the value is an int, but it only works\n\t// on 32 bit integers.  We're OK because disk_space is in GB, but this won't work\n\t// if we change it to bytes.\n\thost.disk_space = host.disk_space | 0;\n\n\tif(host.start_date != null) {\n\t\t// Get the ESX server's boot time in its local time\n\t\tvar esxLocalTime = host.start_date.toZonedDateTime();\n\n\t\t// Convert the ESX server's local time to UTC time\n\t\tvar esxUtcTime = esxLocalTime.withZoneSameInstant(Packages.java.time.ZoneId.of(\"UTC\"));\n\t\t\n\t\t// Format the UTC time to a string representation of GlideDateTime\n\t\tvar format = Packages.java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\t\thost.start_date = esxUtcTime.format(format);\n\t}\n\n\tfunction extractMORs(a) {\n\t\ta.forEach(function(o, idx) { a[idx] = o.morid; });\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction getDatastoreCapacity(dsMorId) {\n\tvar mor, ds;\n\t\n\tif (!dsSizes.hasOwnProperty(dsMorId)) {\n\t\tmor = new vim25.ManagedObjectReference();\n\t\tmor.setType('Datastore');\n\t\tmor.setVal(dsMorId);\n\t\tds = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\tds = _this.getPropsForManagedObject(ds, dsMap);\n\t\t\n\t\tdsSizes[dsMorId] = ds.capacity || 0;\n\t}\n\t\n\treturn dsSizes[dsMorId];\n}\n\n})();",
      "sys_id": "7c6ff0ef93c31200c2fe705bb47ffb32"
    },
    {
      "script": "var GenerateWMIScriptPS1 = Class.create();\n\nGenerateWMIScriptPS1.prototype = {\n\n    initialize : function(fields, shouldFilterHotfix) {\n        this.fields = fields;\n        this.shouldFilterHotfix = shouldFilterHotfix;\n    },\n\n    generateScript: function() {\n        var wmiFieldsString = this.fields;\n        var filterHotfix = this.shouldFilterHotfix;\n        var scriptValue = \"\";\n\n        scriptValue += \"filterHotfix('\" + filterHotfix + \"');\\n\";\n\n        var wmiFields = wmiFieldsString.split(\",\");\n        for (var i = 0; i < wmiFields.length; i++)\n            scriptValue += \"addFetch('\" + wmiFields[i]+ \"');\\n\";\n\n        scriptValue += \"fetch -computer $computer -cred $cred;\\n\";\n        return scriptValue;\n    },\n\n    type: \"GenerateWMIScriptJS\"\n}",
      "sys_id": "7ca74e780a0004830163988cbd58df6d"
    },
    {
      "script": "/**\n * Parses raw probe output that has been sectioned off by one or more section headers.\n * Section output will be parsed as an array of lines (raw), JSON, or IndentedMarkup.\n *\n * @since fuji\n * @author roy.laurie\n *\n ** Constructor\n * @param {} options Configuration options. Valid keys as follows:\n *   sectionHeaderRegex: RegExp The pattern used to separate sections. Default format example: [[==PROBE:section_name==]]\n *   jsonSections: string[] An array of section names to parse as JSON.\n *   indentedMarkup: string[] An array of sections names to parse as Indented Markup (lazy json)\n */\nvar DiscoveryProbeOutputSectionParser = function(options) {\n\tthis._sectionHeaderRegex = DiscoveryProbeOutputSectionParser._DEFAULT_SECTION_HEADER_REGEX;\n\tthis._jsonSections = [];\n\tthis._indentedMarkupSections = [];\n\t\n\tif (typeof options === 'undefined')\n\t\treturn;\n\tif (typeof options.sectionHeaderRegex !== 'undefined')\n\t\tthis._sectionHeaderRegex = options.sectionHeaderRegex;\n\tif (typeof options.jsonSections !== 'undefined')\n\t\tthis._jsonSections = options.jsonSections;\n\tif (typeof options.indentedMarkupSections !== 'undefined')\n\t\tthis._indentedMarkupSections = options.indentedMarkupSections;\n\n\tthis._strictMarkupSections = options.strictMarkupSections || [];\n};\n\nDiscoveryProbeOutputSectionParser._DEFAULT_SECTION_HEADER_REGEX = /\\[\\[==PROBE:(\\w+)==\\]\\]/;\n\nDiscoveryProbeOutputSectionParser.prototype.type = 'DiscoveryProbeOutputSectionParser';\n\n/**\n * @param string output\n * @return { string sectionName: {}|[],.. }\n */\nDiscoveryProbeOutputSectionParser.prototype.parse = function(output) {\n\tvar sections = output.split(this._sectionHeaderRegex);\n\tvar results = {};\n\n\tfor (var i = 1; i < sections.length; i += 2) {\n\t\tvar key = sections[i];\n\t\tvar content = sections[i+1].trim();\n\t\tvar result = null;\n\t\t\n\t\t// determine how to parse the section; json, indented markup, raw (line array)\n\t\tif (JSUtil.contains(this._jsonSections, key) && content)\n\t\t\tresult = JSON.parse(content);\n\t\telse if (JSUtil.contains(this._indentedMarkupSections, key))\n\t\t\tresult = this._parseIndentedMarkup(content);\n\t\telse if (JSUtil.contains(this._strictMarkupSections, key))\n\t\t\tresult = this._parseStrictIndentedMarkup(content);\n\t\telse\n\t\t\tresult = this._parseLines(content);\n\t\t\n\t\tresults[key] = result;\n\t}\n\t\n\treturn results;\n};\n\n/**\n * @return string[] Each trimmed line of the output.\n */\nDiscoveryProbeOutputSectionParser.prototype._parseLines = function(output) {\n\tvar lines = output.split(/\\n/);\n\tvar result = [];\n\n\tfor (var j = 0; j < lines.length; ++j)\n\t\tresult.push(lines[j].trim());\n\t\n\treturn result;\n};\n\n/**\n * @return {} Parsed as Indented Markup\n */\nDiscoveryProbeOutputSectionParser.prototype._parseIndentedMarkup = function(output) {\n\tvar indentedMarkupParser = new DiscoveryIndentedMarkup({ pluralRoot: true });\n\tvar result = indentedMarkupParser.parse(output);\n\treturn result;\n};\n\n/**\n * @return {} Parsed as Indented Markup\n */\nDiscoveryProbeOutputSectionParser.prototype._parseStrictIndentedMarkup = function(output) {\n\tvar indentedMarkupParser = new DiscoveryStrictIndentedMarkup({ pluralRoot: true });\n\tvar result = indentedMarkupParser.parse(output);\n\treturn result;\n};\n",
      "sys_id": "7ca7e99037203100dcd445cbbebe5d48"
    },
    {
      "script": "// Discovery class\n\n/**\n * Parses the output of ifconfig.\n */\nvar IDSensorUtil = Class.create();\n\nIDSensorUtil.prototype = {\n    getAdapters: function(output, skipStr, partsExpr, ipv4Expr, ipv6Expr, macAddressFunc) {\n        var adapters = {};\n        partsExpr.lastIndex = 0;\n        var parts;\n\n        while ((parts = partsExpr.exec(output)) !== null) {\n            var adapterName = parts[1].split(\":\")[0];\n            var adapterOpts = parts[2];\n\n            if (JSUtil.notNil(skipStr) && adapterOpts.match(skipStr))\n                continue;\n\n            // See if we already have the NIC - if not, we'll create one when we have an IP address to\n            // associate with it\n            var adapter = adapters[adapterName];\n\n            // Get the IPV4 address info\n            ipv4Expr.lastIndex = 0;\n            while ((networkInfo = ipv4Expr.exec(adapterOpts)) != null) {\n                if (!SncIPAddressV4.get(networkInfo[1]) || networkInfo[1] == \"0.0.0.0\" ||\n                    networkInfo[1] == \"255.255.255.255\" || networkInfo[1] == \"127.0.0.1\")\n                    continue;\n\n                if (!adapter) {\n                    adapter = this.createAdapter(adapterName, macAddressFunc(parts[0].replace(/\\n\\n/mg, \"\\n\").replace(/\\n\\s+/mg, \" \"), adapterName, networkInfo[1]));\n                    adapters[adapterName] = adapter;\n                }\n\n                var netmask = networkInfo[2];\n                if (!isNaN(netmask))\n                    // convert cidr prefix to decimal dotted format\n                    netmask = this.cidrToMask(netmask);\n\n                this.addIP(adapter, networkInfo[1], 4, netmask);\n            }\n\n            // Get IPV6 addresses\n            if (JSUtil.notNil(ipv6Expr)) {\n                ipv6Expr.lastIndex = 0;\n                while ((ipv6Info = ipv6Expr.exec(adapterOpts)) != null) {\n                    var ipv6 = SncIPAddressV6.get(ipv6Info[1]);\n                    if (!ipv6 || ipv6.isLocalhost() || ipv6.isUnspecified())\n                        continue;\n                    if (!adapter) {\n                        adapter = this.createAdapter(adapterName, macAddressFunc(parts[0].replace(/\\n\\n/mg, \"\\n\").replace(/\\n\\s+/mg, \" \"), adapterName, ipv6Info[1]));\n                        adapters[adapterName] = adapter;\n                    }\n                    this.addIP(adapter, ipv6Info[1], 6, ipv6Info[2]);\n                }\n            }\n\n            // Finished fetching IP addresses - if we have one, set the adapter values to the first ones in the list\n            if (adapter) {\n                adapter.ip_address = (adapter.ip_addresses.length > 0) ? adapter.ip_addresses[0].ip_address : null;\n                adapter.netmask = (adapter.ip_addresses.length > 0) ? adapter.ip_addresses[0].netmask : null;\n            }\n        }\n\n        var adapterList = [];\n        for (var nicName in adapters)\n            adapterList.push(adapters[nicName]);\n        return adapterList;\n    },\n\n    getAdapterGateways: function(output, adapters, gwExpr) {\n        var default_gateway;\n        gwExpr.lastIndex = 0;\n        var parts;\n\n        while ((parts = gwExpr.exec(output)) !== null) {\n            for (var n in adapters) {\n                if (adapters[n].name == parts[2]) {\n                    adapters[n].ip_default_gateway = parts[1];\n                    default_gateway = parts[1];\n                }\n            }\n        }\n        return default_gateway;\n    },\n\n    getAdapterRoutes: function(output, adapters) {\n        var routeExpr = /^([0-9]\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s+(?:\\S+\\s+){3}(\\S+)$/gm;\n        // e.g.\n        // Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\n        // 0.0.0.0         10.4.15.1       0.0.0.0         UG    0      0        0 eth0\n        // 10.4.15.0       0.0.0.0         255.255.255.192 U     0      0        0 eth0\n        // ...\n\n        var parts;\n        routeExpr.lastIndex = 0;\n        while ((parts = routeExpr.exec(output)) !== null) {\n            var destination = parts[1];\n            var netmask = parts[3];\n            var flags = parts[4];\n            var ifName = parts[5];\n\n            if (IPCollectionUtil.isPrivateIPAddress(destination)) {\n                for (var n in adapters) {\n                    if (ifName != adapters[n].name)\n                        continue;\n\n                    if (!adapters[n].hasOwnProperty('routes'))\n                        adapters[n].routes = {\n                            ifRoutes: [],\n                            gwRoutes: []\n                        };\n\n                    var route = {\n                        dest_ip_network: destination + '/' + this.maskToCidr(netmask)\n                    };\n                    if (flags.indexOf('G') == -1) {\n                        route.router_interface = ifName;\n                        adapters[n].routes.ifRoutes.push(route);\n                    } else {\n                        route.next_hop_ip_address = parts[2];\n                        route.route_interface = ifName;\n                        adapters[n].routes.gwRoutes.push(route);\n                    }\n                    break;\n                }\n            }\n        }\n    },\n\n    getAdapterRoutesIproute: function(output, adapters) {\n        var routeExpr = /^(\\S+)\\s+(?:via\\s+(\\S+)\\s+){0,1}(?:dev\\s+(\\S+))/gm;\n        var parts;\n        routeExpr.lastIndex = 0;\n        while ((parts = routeExpr.exec(output)) !== null) {\n            var destination = parts[1];\n            var netmask;\n            var gateway = parts[2];\n            var ifName = parts[3];\n\n            if (destination === 'default') {\n                destination = '0.0.0.0';\n                netmask = '0';\n            } else if (destination.indexOf(\"/\") != -1) {\n                var split = destination.split(\"/\");\n                destination = split[0];\n                netmask = split[1];\n            } else\n                netmask = '32';\n\n            if (IPCollectionUtil.isPrivateIPAddress(destination)) {\n                for (var n in adapters) {\n                    if (ifName != adapters[n].name)\n                        continue;\n\n                    if (!adapters[n].hasOwnProperty('routes'))\n                        adapters[n].routes = {\n                            ifRoutes: [],\n                            gwRoutes: []\n                        };\n\n                    var route = {\n                        dest_ip_network: destination + '/' + netmask\n                    };\n                    if (gateway) {\n                        route.next_hop_ip_address = gateway;\n                        route.route_interface = ifName;\n                        adapters[n].routes.gwRoutes.push(route);\n                    } else {\n                        route.router_interface = ifName;\n                        adapters[n].routes.ifRoutes.push(route);\n                    }\n                    break;\n                }\n            }\n        }\n    },\n\n    // Takes a netmask (e.g. '255.255.255.255') and returns the cidr representation (e.g. '32')\n    maskToCidr: function(mask) {\n        var cidr = 0;\n        var parts = mask.split('.');\n        for (var i = 0; i < parts.length; i++) {\n            part = Number(parts[i]);\n            while (0x80 == (part & 0x80)) {\n                ++cidr;\n                part = part << 1 & 0xff;\n            }\n        }\n        return (String(cidr));\n    },\n\n    cidrToMask: function(cidr) {\n        if (isNaN(cidr))\n            return null;\n\n        var cidrInt = parseInt(cidr);\n        if (cidrInt < 0 || cidrInt > 32)\n            return null;\n\n        var div = Math.floor(cidrInt / 8);\n        var rem = cidrInt % 8;\n        var res = [0, 0, 0, 0];\n        var i = 0;\n        for (; i < div; i++)\n            res[i] = 255;\n\n        if (i < 4)\n            res[i] = 256 - Math.pow(2, 8 - rem);\n\n        return res.join('.');\n    },\n\n    addIP: function(adapter, address, version, netmask) {\n        if (!adapter)\n            return;\n\n        var ip = {};\n        ip.ip_address = address;\n        ip.ip_version = version;\n        ip.netmask = netmask;\n        adapter.ip_addresses.push(ip);\n    },\n\n    createAdapter: function(name, macAddress) {\n        var adapter = {};\n        adapter.name = name;\n        adapter.mac_address = macAddress;\n        adapter.ip_addresses = [];\n        return adapter;\n    },\n\n    type: \"IDSensorUtil\"\n};",
      "sys_id": "7f33ea069f71210054679ff3367fcf41"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n\nvar VMWarevCenterClustersProbe = Class.create();\n\n(function() {\n\nvar _this,\n\tstatusMap = { green: 2, yellow: 3, red: 4 },\n\thosts = [ ],\n\tpools = [ ],\n\tclusters = [ ],\n\tdrsVMOverrides = [ ],\n\tmoMap = { };\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterClustersProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name,\n\t\t\tleftOverMors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\t// Average measured size of a cluster with associated hosts and resource\n\t\t\t// pools is 600 bytes.  Default page size of 1000 leaves us well below\n\t\t\t// the 5 MB limit.\n\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 1000,\n\t\t\tclusterMorIds = leftOverMors.splice(0, pageSize),\n\t\t\toriginalData = [ ],\n\t\t\tresults = {\n\t\t\t\thosts: hosts,\n\t\t\t\tpools: pools,\n\t\t\t\tclusters: clusters,\n\t\t\t\tdrsVMOverrides: drsVMOverrides\n\t\t\t},\n\t\t\tparent = { name: 'name' },\n\t\t\tresourceMap = {\n\t\t\t\tname: 'name',\n\t\t\t\tparent: { },\n\t\t\t\tconfig: {\n\t\t\t\t\tcpuAllocation: {\n\t\t\t\t\t\treservation: 'cpu_reserved_mhz',\n\t\t\t\t\t\tlimit: 'cpu_limit_mhz',\n\t\t\t\t\t\texpandableReservation: 'cpu_expandable',\n\t\t\t\t\t\tshares: { shares: 'cpu_shares' }\n\t\t\t\t\t},\n\t\t\t\t\tmemoryAllocation: {\n\t\t\t\t\t\treservation: 'mem_reserved_mb',\n\t\t\t\t\t\tlimit: 'mem_limit_mb',\n\t\t\t\t\t\texpandableReservation: 'mem_expandable',\n\t\t\t\t\t\tshares: { shares: 'mem_shares' }\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tvm: [ { } ]\n\t\t\t},\n\t\t\tcomputeMap = {\n\t\t\t\thost: [ { name: 'name' } ],\n\t\t\t\tresourcePool: resourceMap\n\t\t\t},\n\t\t\tclusterMap = {\n\t\t\t\tname: 'name',\n\t\t\t\tparent: parent,\n\t\t\t\tsummary: {\n\t\t\t\t\teffectiveCpu: 'effectivecpu',\n\t\t\t\t\teffectiveMemory: 'effectivememory',\n\t\t\t\t\tnumEffectiveHosts: 'effectivehosts',\n\t\t\t\t\tnumHosts: 'numhosts',\n\t\t\t\t\ttotalCpu: 'totalcpu',\n\t\t\t\t\ttotalMemory: 'totalmemory',\n\t\t\t\t\tnumCpuCores: 'numcpucores',\n\t\t\t\t\tnumCpuThreads: 'numcputhreads',\n\t\t\t\t\toverallStatus: 'host_cluster_status'\n\t\t\t\t},\n\t\t\t\t//This block fetches the DRS settings for the cluster and the VMs that override the cluster DRS behaviour.\n\t\t\t\tconfigurationEx: {\n\t\t\t\t\tdrsConfig: {\n\t\t\t\t\t\tdefaultVmBehavior: 'drs_behavior',\n\t\t\t\t\t\tenabled: 'drs_enabled',\n\t\t\t\t\t\tvmotionRate: 'drs_vmotion_rate'\n\t\t\t\t\t},\n\t\t\t\t\tdrsVmConfig: [{\n\t\t\t\t\t\tbehavior: 'drs_behavior',\n\t\t\t\t\t\tenabled: 'drs_enabled',\n\t\t\t\t\t\tkey: { }\n\t\t\t\t\t}]\n\t\t\t\t},\n\t\t\t\thost: [ { } ],\n\t\t\t\tresourcePool: resourceMap\n\t\t\t},\n\t\t\tdataMap = {\n\t\t\t\tComputeResource: computeMap,\n\t\t\t\tClusterComputeResource: clusterMap,\n\t\t\t\tResourcePool: resourceMap\n\t\t\t},\n\t\t\tfixers = {\n\t\t\t\tComputeResource: fixHost,\n\t\t\t\tClusterComputeResource: fixCluster,\n\t\t\t\tResourcePool: fixResourcePool\n\t\t\t};\n\n\t\tparent.parent = parent;\n\t\tresourceMap.resourcePool = [ resourceMap ];\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\t/*\n\t\tSample data.  Truncated for brevity, so possibly inconsistent:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"type\": \"ClusterComputeResource\",\n\t\t\t\t\"morid\": \"domain-c105\",\n\t\t\t\t\"name\": \"DC0_C14\",\n\t\t\t\t\"parent\": {\n\t\t\t\t  \"type\": \"Folder\",\n\t\t\t\t  \"morid\": \"group-h4\",\n\t\t\t\t  \"name\": \"host\",\n\t\t\t\t  \"parent\": {\n\t\t\t\t\t\"type\": \"Datacenter\",\n\t\t\t\t\t\"morid\": \"datacenter-2\",\n\t\t\t\t\t\"name\": \"DC0\",\n\t\t\t\t\t\"parent\": {\n\t\t\t\t\t  \"type\": \"Folder\",\n\t\t\t\t\t  \"morid\": \"group-d1\",\n\t\t\t\t\t  \"name\": \"Datacenters\"\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t},\n\t\t\t\t\"summary\": {\n\t\t\t\t  \"effectivecpu\": 95968,\n\t\t\t\t  \"effectivememory\": 119744,\n\t\t\t\t  \"effectivehosts\": 8,\n\t\t\t\t  \"numhosts\": 8,\n\t\t\t\t  \"totalcpu\": 95968,\n\t\t\t\t  \"totalmemory\": 137402155008,\n\t\t\t\t  \"numcpucores\": 32,\n\t\t\t\t  \"numcputhreads\": 32\n\t\t\t\t},\n\t\t\t\t\"host\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\t\"morid\": \"host-1025\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\t\"morid\": \"host-113\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"resourcePool\": {\n\t\t\t\t  \"type\": \"ResourcePool\",\n\t\t\t\t  \"morid\": \"resgroup-106\",\n\t\t\t\t  \"name\": \"Resources\",\n\t\t\t\t  \"parent\": {\n\t\t\t\t\t\"type\": \"ClusterComputeResource\",\n\t\t\t\t\t\"morid\": \"domain-c105\"\n\t\t\t\t  },\n\t\t\t\t  \"config\": {\n\t\t\t\t\t\"cpuAllocation\": {\n\t\t\t\t\t  \"cpu_reserved_mhz\": 95968,\n\t\t\t\t\t  \"cpu_limit_mhz\": 95968,\n\t\t\t\t\t  \"cpu_expandable\": true,\n\t\t\t\t\t  \"shares\": {\n\t\t\t\t\t\t\"cpu_shares\": 4000\n\t\t\t\t\t  }\n\t\t\t\t\t},\n\t\t\t\t\t\"memoryAllocation\": {\n\t\t\t\t\t  \"mem_reserved_mb\": 119744,\n\t\t\t\t\t  \"mem_limit_mb\": 119744,\n\t\t\t\t\t  \"mem_expandable\": true,\n\t\t\t\t\t  \"shares\": {\n\t\t\t\t\t\t\"mem_shares\": 163840\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  },\n\t\t\t\t  \"resourcePool\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"type\": \"ResourcePool\",\n\t\t\t\t\t  \"morid\": \"resgroup-1917\",\n\t\t\t\t\t  \"name\": \"DC0_C14_RP0\",\n\t\t\t\t\t  \"parent\": {\n\t\t\t\t\t\t\"type\": \"ResourcePool\",\n\t\t\t\t\t\t\"morid\": \"resgroup-106\"\n\t\t\t\t\t  },\n\t\t\t\t\t  \"config\": {\n\t\t\t\t\t\t\"cpuAllocation\": {\n\t\t\t\t\t\t  \"cpu_reserved_mhz\": 0,\n\t\t\t\t\t\t  \"cpu_limit_mhz\": -1,\n\t\t\t\t\t\t  \"cpu_expandable\": true,\n\t\t\t\t\t\t  \"shares\": {\n\t\t\t\t\t\t\t\"cpu_shares\": 4000\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"memoryAllocation\": {\n\t\t\t\t\t\t  \"mem_reserved_mb\": 0,\n\t\t\t\t\t\t  \"mem_limit_mb\": -1,\n\t\t\t\t\t\t  \"mem_expandable\": true,\n\t\t\t\t\t\t  \"shares\": {\n\t\t\t\t\t\t\t\"mem_shares\": 163840\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t}\n\t\t\t\t\t  },\n\t\t\t\t\t  \"resourcePool\": [\n\t\t\t\t\t  ]\n\t\t\t\t\t}\n\t\t\t\t  ]\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of clusters we're going to explore\n\t\tclusterMorIds.forEach(\n\t\t\tfunction(cluster) {\n\t\t\t\ttry {\n\t\t\t\t\tvar table,\n\t\t\t\t\t\tclusterType = cluster.type,\n\t\t\t\t\t\tmor = new vim25.ManagedObjectReference();\n\n\t\t\t\t\t// Create a managed object for the current cluster, fetch data for it and its\n\t\t\t\t\t// resource pools from vCenter.\n\t\t\t\t\t// The \"cluster\" may be a ComputeResource or a ClusterComputerResource.\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp?topic=%2Fcom.vmware.wssdk.apiref.doc%2Fvim.ComputeResource.html,\n\t\t\t\t\t// http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.ClusterComputeResource.html and\n\t\t\t\t\t// http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.ResourcePool.html\n\t\t\t\t\tmor.setType(cluster.type);\n\t\t\t\t\tmor.setVal(cluster.morid);\n\t\t\t\t\tcluster = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\tcluster = _this.getPropsForUnknownType(cluster, dataMap);\n\n\t\t\t\t\tif (typeof dataMap[clusterType] == 'string')\n\t\t\t\t\t\tclusterType = dataMap[clusterType];\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(cluster));\n\n\t\t\t\t\t// Fixup the data.\n\t\t\t\t\tfixers[clusterType](cluster);\n\n\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing ' + cluster.type + ' ' + cluster.morid + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\t// We've fetched all the clusters and resource pools. Calculate resource pool paths.\n\t\ttry {\n\t\t\tgetPoolPaths();\n\t\t} catch (e) {\n\t\t\tthis.probe.appendWarning('Caught exception when calculating pool paths: ' + e.toString());\n\t\t}\n\n\t\tif (debug)\n\t\t\tresults.originalData = originalData.map(JSON.parse);\n\n\t\t// We fetched at most pageSize clusters.  Send back the IDs of remaining clusters so the\n\t\t// sensor can fire another probe.\n\t\tif (leftOverMors.length)\n\t\t\tresults.leftOverMors = leftOverMors;\n\n\t\t// Stringify the results, dropping anything named 'mo' (these are vijava ManagedObjects)\n\t\tthis.output = JsonCi.decircularize(results, function(key, value) { if (key != 'mo') return value; });\n\t},\n\n\ttype : 'VMWarevCenterClustersProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction getPoolPaths() {\n\n\tpools.forEach(setPath);\n\tclusters.forEach(function(cluster) { delete cluster.parent; });\n\n\tfunction setPath(pool) {\n\n\t\tvar path = getPath(pool);\n\t\t// The first item in the path is a root node that we don't want to incude in the path\n\t\tpath.splice(0, 1);\n\t\t// The third (now second) item is the (invisible) clusters folder.\n\t\tpath.splice(1, 1);\n\t\tpool.fullpath = path.join(' | ');\n\n\t\tdelete pool.parent;\n\t}\n\n\tfunction getPath(mo) {\n\t\tvar fullpath,\n\t\t\tparent = moMap[mo.parent.morid];\n\t\tif (!parent)\n\t\t\treturn [ mo.name ];\n\t\tfullpath = getPath(parent);\n\t\tfullpath.push(mo.name);\n\t\treturn fullpath;\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction mapParent(mo) {\n\tif (mo && mo.morid) {\n\t\tmoMap[mo.morid] = mo;\n\t\tmapParent(mo.parent);\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixCluster(cluster, ownerName, hostMorid) {\n\tvar name;\n\n\tmapParent(cluster);\n\n\tcluster.cmdb_ci_vcenter_folder = cluster.parent.morid;\n\n\tif (!ownerName)\n\t\tclusters.push(cluster);\n\n\tcluster.cmdb_ci_esx_server = cluster.host.map(\n\t\tfunction(host) {\n\t\t\t// The cluster sensor triggers host probes.  I need the list of hosts for this.\n\t\t\thosts.push(host.morid);\n\t\t\treturn host.morid;\n\t\t});\n\tdelete cluster.host;\n\n\tfixResourcePool(cluster.resourcePool, ownerName || cluster.name, hostMorid, cluster.morid);\n\tdelete cluster.resourcePool;\n\n\tfor (name in cluster.summary)\n\t\tcluster[name] = cluster.summary[name];\n\n\t//Check if the drs config block exists in the datamap.\n\tvar vmOverride, clusterConfig,\n\t\tconfigurationEx = cluster.configurationEx,\n\t\tdrsConfig = configurationEx && configurationEx.drsConfig,\n\t\tdrsVmConfigs = configurationEx && configurationEx.drsVmConfig;\n\n\t//Add the cluster drs config info to the cluster json\n\tif (drsConfig) {\n\t\tfor (name in drsConfig)\n\t\t\tcluster[name] = drsConfig[name];\n\t}\n\n\t//Add the overridden VMs drs config info to the cluster json.\n\t//Add VMs drs behavior only if cluster drs enabled is true.\n\tif (cluster.drs_enabled) {\n\t\tdrsVmConfigs.forEach(function(drsVmConfig) {\n\t\t\tvar vmOverride = {\n\t\t\t\tcluster: cluster.morid,\n\t\t\t\tvm_morid: drsVmConfig.key.morid,\n\t\t\t\tdrs_enabled: drsVmConfig.drs_enabled,\n\t\t\t\tdrs_behavior: drsVmConfig.drs_behavior\n\t\t\t};\n\t\t\tdrsVMOverrides.push(vmOverride);\n\t\t});\n\t}\n\n\tdelete cluster.configurationEx;\n\n\tcluster.host_cluster_status = statusMap[cluster.host_cluster_status] || 1;\n\tdelete cluster.summary;\n\n\tdelete cluster.type;\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixHost(host) {\n\tfixCluster(host, host.host[0].name, host.host[0].morid);\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixResourcePool(pool, ownerName, hostMorid, clusterMorid) {\n\tvar name;\n\n\tif (pool.type == 'VirtualApp')\n\t\treturn;\n\n\tmoMap[pool.morid] = pool;\n\n\tpools.push(pool);\n\n\tpool.owner = ownerName;\n\tpool.owner_morid = clusterMorid;\n\tpool.host_morid = hostMorid;\n\n\tpool.resourcePool.forEach(function(innerPool) {\n\t\tpool.containedPools = pool.containedPools || [ ];\n\t\tpool.containedPools.push(innerPool);\n\t\tfixResourcePool(innerPool, ownerName, hostMorid, clusterMorid);\n\t});\n\tdelete pool.resourcePool;\n\n\tpool.vm.forEach(function(vm, idx) { pool.vm[idx] = vm.morid; });\n\tfor (name in pool.config.cpuAllocation)\n\t\tpool[name] = pool.config.cpuAllocation[name];\n\tfor (name in pool.config.memoryAllocation)\n\t\tpool[name] = pool.config.memoryAllocation[name];\n\n\tpool.cpu_shares = pool.config.cpuAllocation.shares.cpu_shares;\n\tpool.mem_shares = pool.config.memoryAllocation.shares.mem_shares;\n\n\tdelete pool.shares;\n\tdelete pool.config;\n\tdelete pool.type;\n}\n\n})();\n",
      "sys_id": "804e7c738fd75200c2fe0b5437bdeeca"
    },
    {
      "script": "/**\n * Expose the VMWare Java API\n */\nvar vim = Packages.com.vmware.vim;\nvar vim25 = Packages.com.vmware.vim25;\n\n/**\n * Java imports\n */\nvar URL = Packages.java.net.URL;\nvar HashMap = Packages.java.util.HashMap;\nvar Map = Packages.java.util.Map;\nvar Calendar = Packages.java.util.Calendar;\n\n/**\n * Service-now.com imports\n */\nvar MIDServer = Packages.com.service_now.mid.MIDServer;\nvar Credential = Packages.com.service_now.mid.creds.Credential;\nvar Credentials = Packages.com.service_now.mid.services.Credentials;\nvar CredentialType = Packages.com.service_now.mid.creds.CredentialType;\nvar ICredentialsIterator = Packages.com.service_now.mid.creds.ICredentialsIterator;\nvar ICredentialsProvider = Packages.com.service_now.mid.creds.ICredentialsProvider;\nvar ThreadManager = Packages.com.service_now.mid.queue_worker.ThreadManager;\nvar MIDScript = Packages.com.service_now.mid.script.MIDScript;\nvar MIDScriptType = Packages.com.service_now.mid.script.MIDScriptType;\nvar IPAddressUtil = Packages.com.glide.util.IPAddressUtil;\nvar CustomizationPassword = Packages.com.service_now.mid.probe.vmware.CustomizationPassword;\n\nvar SOURCE = Packages.com.glide.util.IConstants.SOURCE;\n\nvar escape = Packages.com.glide.util.StringUtil.escapeTitle;\nvar nil = Packages.com.glide.util.StringUtil.nil;\n\n/**\n * Constants\n */\nvar VCENTER = \"vcenter\";\nvar INSTANCE = \"url\";\nvar HOST_SYSTEMS = \"hostSystems\";\nvar HOST_SYSTEM = \"hostSystem\";\nvar DATA_STORES = \"dataStores\";\nvar DATA_STORE = \"dataStore\";\nvar MO_RESOURCE_POOL = \"ResourcePool\"; // Managed object name in vSphere Java API\nvar MO_HOST_SYSTEM = \"HostSystem\"; // Managed object name in vSphere Java API\nvar DEFAULT_RESOURCE_POOL = \"Resources\";\nvar IGNORE_CERT = \"ignoreCert\";\nvar VIRTUAL_MACHINES = \"virtualMachines\";\nvar VIRTUAL_MACHINE = \"virtualMachine\";\nvar RESOURCE_POOLS = \"resourcePools\";\nvar NAME = \"name\";\nvar CPUS = \"cpus\";\nvar MEM_MB = \"memInMB\";\nvar UUID = \"uuid\";\nvar PATH = \"path\";\nvar POWER_STATUS = \"powerStatus\";\nvar TEMPLATE = \"template\";\nvar VIRTUAL_DISKS = \"virtualDisks\";\nvar VIRTUAL_DISK = \"virtualDisk\";\nvar CAPACITY_KB = \"capacityInKB\";\nvar LABEL = \"label\";\nvar SUMMARY = \"summary\";\nvar VIRTUAL_NICS = \"virtualNics\";\nvar VIRTUAL_NIC = \"virtualNic\";\nvar NETWORK = \"network\";\nvar MAC_ADDRESS = \"macAddress\";\nvar RESOURCE_POOL = \"resourcepool\";\nvar RESOURCE_POOL_OWNER = \"resourcepoolowner\";\n\nvar VM_NAME = \"vmname\";\nvar ACTION = \"action\";\nvar POWER_ON = \"powerOn\";\nvar POWER_OFF = \"powerOff\";\nvar Shut_Down_Guest = \"shutdownGuest\";\nvar CLONE = \"clone\";\nvar CLONE_NAME = \"clonename\";\n\nvar DOMAIN = \"domain\";\nvar HOSTNAME = \"hostname\";\nvar IP_ADDRESS = \"ipaddress\";\nvar NETMASK = \"netmask\";\nvar GATEWAY = \"gateway\";\nvar DNS = \"dns\";\nvar ADMIN_PASSWORD = \"adminPassword\";\nvar DOMAIN_ADMIN = \"domainAdmin\";\nvar DOMAIN_ADMIN_PASSWORD = \"domainAdminPassword\";\nvar FULLNAME = \"fullname\";\nvar ORGANIZATION = \"organization\";\nvar PRODUCT_KEY = \"productKey\";\nvar TIME_ZONE = \"timezone\";\nvar CONFIGURE_LINUX = \"Configure Linux\";\nvar CONFIGURE_WINDOWS = \"Configure Windows\";\n",
      "sys_id": "83ebeec1c0a8019a156932ff99e06b5f"
    },
    {
      "script": "var ObjectPolyfill;\n\n// Polyfills taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\nif (typeof Object.create != 'function') {\n  // Production steps of ECMA-262, Edition 5, 15.2.3.5\n  // Reference: http://es5.github.io/#x15.2.3.5\n  Object.create = (function() {\n    // To save on memory, use a shared constructor\n    function Temp() {}\n\n    // make a safe reference to Object.prototype.hasOwnProperty\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    return function (O) {\n      // 1. If Type(O) is not Object or Null throw a TypeError exception.\n      if (typeof O != 'object') {\n        throw TypeError('Object prototype may only be an Object or null');\n      }\n\n      // 2. Let obj be the result of creating a new object as if by the\n      //    expression new Object() where Object is the standard built-in\n      //    constructor with that name\n      // 3. Set the [[Prototype]] internal property of obj to O.\n      Temp.prototype = O;\n      var obj = new Temp();\n      Temp.prototype = null; // Let's not keep a stray reference to O...\n\n      // 4. If the argument Properties is present and not undefined, add\n      //    own properties to obj as if by calling the standard built-in\n      //    function Object.defineProperties with arguments obj and\n      //    Properties.\n      if (arguments.length > 1) {\n        // Object.defineProperties does ToObject on its first argument.\n        var Properties = Object(arguments[1]);\n        for (var prop in Properties) {\n          if (hasOwn.call(Properties, prop)) {\n            obj[prop] = Properties[prop];\n          }\n        }\n      }\n\n      // 5. Return obj\n      return obj;\n    };\n  })();\n}\n\nif (!Object.keys) {\n  Object.keys = (function() {\n    'use strict';\n    var hasOwnProperty = Object.prototype.hasOwnProperty,\n        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n        dontEnums = [\n          'toString',\n          'toLocaleString',\n          'valueOf',\n          'hasOwnProperty',\n          'isPrototypeOf',\n          'propertyIsEnumerable',\n          'constructor'\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    return function(obj) {\n      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n        throw new TypeError('Object.keys called on non-object');\n      }\n\n      var result = [], prop, i;\n\n      for (prop in obj) {\n        if (hasOwnProperty.call(obj, prop)) {\n          result.push(prop);\n        }\n      }\n\n      if (hasDontEnumBug) {\n        for (i = 0; i < dontEnumsLength; i++) {\n          if (hasOwnProperty.call(obj, dontEnums[i])) {\n            result.push(dontEnums[i]);\n          }\n        }\n      }\n      return result;\n    };\n  }());\n}\n",
      "sys_id": "8888482893010200e4e4705bb47ffb88"
    },
    {
      "script": "var RequestAuthAWSV4MIDSigner = Class.create();\n\nRequestAuthAWSV4MIDSigner.prototype = Object.extend(new RequestAuthInternal(), {\n\tinitialize:function() {\n\t\tRequestAuthInternal.prototype.initialize.call(this);\n\t},\n\ttype: 'RequestAuthAWSV4MIDSigner',\n\t\n\tcustom: function(requestAuthenticator) {\n\t\t//custom signing here\n\t\tvar credential = requestAuthenticator.getAuthCredential();\n\t\tvar qMap = requestAuthenticator.getQueryParamMap();\n\t\tvar reqData = requestAuthenticator.getHttpRequestData();\n\t}\n});\n\n\n",
      "sys_id": "890123c3ff0333000941cd6bd53bf189"
    },
    {
      "script": "/* jshint -W030 */\n\nms.include(\"VMWareIncludes\");\n\nvar AVMWareProbe = Class.create(),\n\tgetWWNString = Packages.com.service_now.mid.probe.VMWareProbe.getWWNString;\n\n(function() {\n\nvar serviceInstance, navigator, serverConnection,\n\tcommonTypes = {\n\t\tKeyValue: Packages.com.vmware.vim25.KeyValue,\n\t\tKeyAnyValue: Packages.com.vmware.vim25.KeyAnyValue,\n\t\tArrayOfKeyValue: Packages.com.vmware.vim25.ArrayOfKeyValue,\n\t\tArrayOfKeyAnyValue: Packages.com.vmware.vim25.ArrayOfKeyAnyValue,\n\t\tLicenseManagerEvaluationInfo: Packages.com.vmware.vim25.LicenseManagerEvaluationInfo,\n\t\tLicenseManagerLicenseInfo: Packages.com.vmware.vim25.LicenseManagerLicenseInfo\n\t},\n\tdrsDataObjectTypes = [\n\t\tPackages.com.vmware.vim25.ClusterHostGroup,\n\t\tPackages.com.vmware.vim25.ClusterVmGroup,\n\t\tPackages.com.vmware.vim25.ClusterVmHostRuleInfo,\n\t\tPackages.com.vmware.vim25.ClusterAffinityRuleSpec,\n\t\tPackages.com.vmware.vim25.ClusterAntiAffinityRuleSpec\n\t],\n\tkeyAnyValue = { key: 'key' },\n\tkeyValue = { key: 'key', value: 'value' },\n\tcommonTemplates = {\n\t\tKeyValue: keyValue,\n\t\tKeyAnyValue: keyAnyValue,\n\t\tArrayOfKeyValue: [ keyValue ],\n\t\tArrayOfKeyAnyValue: [ keyAnyValue ],\n\t\tLicenseManagerEvaluationInfo: { properties: [ keyAnyValue] },\n\t\tLicenseManagerLicenseInfo: {\n\t\t\tcostUnit: 'costUnit',\n\t\t\teditionKey: 'edition',\n\t\t\tlicenseKey: 'licenseKey',\n\t\t\tname: 'name',\n\t\t\ttotal: 'total',\n\t\t\tused: 'used',\n\t\t\tproperties: [ keyAnyValue]\n\t\t}\n\t},\n\tvcenterTimeout, _this;\n\nkeyAnyValue.value = keyAnyValue;\n\t\nAVMWareProbe.prototype = Object.extendsObject(AProbe, {\n\n\tfetchManagedObjects: fetchManagedObjects,\n\tgetPropsForManagedObject: getPropsForManagedObject,\n\tgetPropsForUnknownType: getPropsForUnknownType,\n\tgetPropsForDynamicData: getPropsForDynamicData,\n\tgetApplianceInfo: getApplianceInfo,\n\tgetTagsForResources: getTagsForResources,\n\t\n\tIPAddress : Packages.com.snc.commons.networks.IPAddress,\n\n    initialize : function(probe) {\n        this.probe = probe;\n        this.output = \"\";\n        this.createOutputRecord = true;\n\t\t_this = this;\n    },\n    \n    /**\n     * Runs the probe instance\n     */\n    run : function() {\n        this.init();\n        \n        // If we couldn't connect to the vCenter given, abort before even trying to run the probe code\n        if (!this.serviceInstance) {\n            this.cleanup();\n            return;\n        }\n    \n        // If something fails in the probe code and an unhandled exception is thrown, make sure we clean up\n        try {\n            this.process();\n        } catch (ex) {\n            ms.log(ex);\n\t\t\tms.log(ex.stack);\n            this.setError(ex);\n        } finally {\n            this.cleanup();\n        }\n    },\n\t\n    \n    /**\n      * Attempts to initialize the service instance to allow the process method to do its work\n      */\n    init : function() {\n        var source = this.getParameter(SOURCE);\n        // If it doesn't appear to be a URL, generate one\n        var host = (source.indexOf('https://') == -1) ? (this.IPAddress.fromString(source).isV4() ? \"https://\" + source : \"https://[\" + source +\"]\") : source;\n\n\t\t// Default to 10 seconds.  Login retry count is defaulted to 3, so by default\n\t\t// we could end up trying for 30 seconds per cred which seems sufficient but\n\t\t// not excessive.\n\t\tvcenterTimeout = parseInt(probe.getParameter('vcenter_timeout')) || 10000;\n\t\t\n\t\t/*\n\t\t*  Possible cases of the host\n\t\t*  - https://markit8dude\n\t\t*  - https://markit8dude:444\n\t\t*  - https://markit8dude/sdk\n\t\t*  - https://markit8dude:444/sdk\n\t\t*  If the venter port is specified, make sure it's used!\n\t\t*/\t\t\n\t\tvar vcenterPort = (this.hasParameter('vcenter_port')) ? this.getParameter('vcenter_port') : \"\"; \n\t\tif (vcenterPort != '') { \n\t\t\tif (host.indexOf('/sdk') > 0) //tentatively remove the /sdk if it exists\n\t\t\t\thost = host.replace('/sdk', ''); \t\t\t\t\t\t \t\t\t\t\t\t\n\t\t\t\n\t\t\t// if the host URL has 2 colons, it already has a port and we need to replace it \t\t\t\n\t\t\tvar hostArr = host.split(':');\n\t\t\tif (hostArr.length == 3) { \t\t\t\t\t\t\t\t\n\t\t\t\thostArr.pop();\n\t\t\t\thost = hostArr.join(':') + \":\" + vcenterPort;\n\t\t\t} else {\n\t\t\t\thost = host + \":\" + vcenterPort;\n\t\t\t}\n\t\t}\n\t\t\n        this.vmHost = (host.indexOf('/sdk') == -1) ? host + \"/sdk\" : host;\n        this.ignoreCert = this.getBooleanParameter(IGNORE_CERT, true);\n\n\t\tserviceInstance = this.serviceInstance = this._getServiceInstance();\n\t\tif (!serviceInstance)\n\t\t\treturn;\n\n\t\tnavigator = this.navigator = vim25.mo.InventoryNavigator(serviceInstance.getRootFolder());\n\t\tserverConnection = this.serverConnection = serviceInstance.getServerConnection();\n    },\n    \n    /**\n      * Abstract function to run the probe functionality - the derived probes should have a body for this\n      */\n    process : function() {\n    },\n    \n    /**\n     * Logs out of the ServiceInstance connected to vCenter and creates the output result records when\n     * we weren't able to connect so the error that is set gets propagated properly\n     */\n    cleanup : function() {\n        if (serverConnection)\n            serverConnection.logout();\n\n\t\t// This shouldn't be necessary because I just logged out, but during testing I saw a lot of zombie\n\t\t// sessions.  The zombie sessions seemed to be caused by Microsoft System Center Operations Manager,\n\t\t// but it doesn't hurt for me to be as safe as possible.\n\t\tserviceInstance = this.serviceInstance = 0;\n\t\tnavigator = this.navigator = 0;\n\t\tserverConnection = this.serverConnection = 0;\n\t\tvim25 = 0;\n\t\tvim = 0;\n\n\t\tif (this.createOutputRecord)\n            this.createOutputResult(this.output);\n\t},\n    \n    /**\n     * Attempts to obtain a ServiceInstance object using the given URL and credentials in the credentials\n     * table.\n     */\n\t_getServiceInstance : function() {\n\t\tvar serviceInstance, url, credentials, gotInvalidLogin, gotNoPermission, gotReadTimeout, fixedCred,\n\t\t\t_this = this,\n\t\t\tloginRetryCount = this.loginRetryCount || 3;\n\n\t\t// Just to be safe clamp the retryCount to the range 1 to 10.\n\t\tloginRetryCount = Math.max(1, Math.min(10, loginRetryCount));\n\n\t\ttry {\n\t\t\turl = new URL(this.vmHost);\n\n\t\t\tfixedCred = this.getParameter('fixed_credential_id');\n\t\t\t// Very occasionally we get invalid login errors when we shouldn't.  If we've gotten\n\t\t\t// past the datacenters probe then we know we had a valid credential, so it's probably\n\t\t\t// an error if we can no longer validate.  loginRetryCount will default to 3, so we're\n\t\t\t// going to retry 3 times before giving up.\n\t\t\t// I had originally planned to have the datacenters probe set loginRetryCount to 1 -\n\t\t\t// a failure there is much more likely to be legitimate.  But it is possible for that\n\t\t\t// failure to be incorrect and it doesn't cost much to retry.\n\t\t\twhile (!serviceInstance && loginRetryCount--) {\n\t\t\t\tif (fixedCred) {\n\t\t\t\t\tcredential = this.probe.getCredential(null, null, null);\n\t\t\t\t\ttryCredential(credential);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Loop through VMWare credentials - InvalidLogin exception is thrown for failed logons, if it isn't one of those, throw it\n\t\t\t\t\t// so we don't end up looping over and over if we have some real error\n\t\t\t\t\tcredentials = this.getCredentials(\"vmware\");\n\t\t\t\t\twhile (credentials.hasNext()) {\n\t\t\t\t\t\tvar credential = credentials.next();\n\t\t\t\t\t\tif (tryCredential(credential))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ex) {\n\t\t\tthis.setError(\"Unable to establish connection to \" + this.vmHost + \": \" + ex);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!serviceInstance) {\n\t\t\tif (gotInvalidLogin)\n\t\t\t\tthis.setError('No credential would validate for ' + this.vmHost);\n\t\t\telse if (gotNoPermission)\n\t\t\t\tthis.setError('No required permission(s) provided for the account credentials used to connect to ' + this.vmHost);\n\t\t\telse if (gotReadTimeout)\n\t\t\t\tthis.setError('Timeout trying to read from ' + this.vmHost);\n\t\t\telse\n\t\t\t\tthis.setError(\"Unable to establish connection to \" + this.vmHost);\n\t\t}\n\n\t\tfunction tryCredential(credential) {\n\t\t\ttry {\n\t\t\t\tserviceInstance = new vim25.mo.ServiceInstance(url, credential.getUsername(), credential.getPassword(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  _this.ignoreCert, vcenterTimeout, vcenterTimeout);\n\t\t\t\tcredentials.worked(_this.getParameter(\"probe\"));\n\t\t\t\treturn true;\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof vim25.InvalidLogin)\n\t\t\t\t\tgotInvalidLogin = true;\n\n\t\t\t\tif (ex instanceof vim25.NoPermission)\n\t\t\t\t\tgotNoPermission = true;\n\n\t\t\t\t// vCenter 5.5 changed the exception from InvalidLogin to RemoteException.  The \n\t\t\t\t// exception includes the text below in the description, thus, we need to look \n\t\t\t\t// for this exception as well in order to make sure we walk all the credentials.\n\t\t\t\tif (ex instanceof Packages.java.rmi.RemoteException)\n\t\t\t\t\tif ((ex + \"\").indexOf('exception:com.vmware.vim25.InvalidLogin') != -1) {\n\t\t\t\t\t\tgotInvalidLogin = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if ((ex + \"\").indexOf('exception:com.vmware.vim25.NoPermission') != -1) {\n\t\t\t\t\t\tgotNoPermission = true;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if ((ex + \"\").indexOf('java.net.SocketTimeoutException') != -1) {\n\t\t\t\t\t\tgotReadTimeout = true;\n\t\t\t\t\t\treturn true; // No sense trying other credentials if we are getting timeouts\n\t\t\t\t\t}\n\n\t\t\t\tif (!(ex instanceof vim25.InvalidLogin) && !(ex instanceof vim25.SystemError) && !(ex instanceof vim25.NoPermission))\n\t\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t// This was useful when debugging the zombie session problem.\n\t\tvar sessions = serviceInstance.getSessionManager().getSessionList();\n\t\tfor (var i = 0; i < sessions.length; i++) {\n\t\t\tvar session = sessions[i];\n\t\t\tms.log('IP address: ' + session.getIpAddress() + ', login time: ' + session.getLoginTime().getTime().toString() + ', last active: ' + session.getLastActiveTime().getTime().toString());\n\t\t}\n\t\t*/\n\n\t\treturn serviceInstance;\n\t},\n\n    _findObjectByMORid: function(type, morid) {\n        if (type == 'Datastore')\n            return this._findDatacenterObjectByMORid('datastore', morid);\n        else if (type == 'Network')\n            return this._findDatacenterObjectByMORid('network', morid);\n        \n        var rootFolder = this.serviceInstance.getRootFolder();\n        var objects = new vim25.mo.InventoryNavigator(rootFolder).searchManagedEntities(type);\n\n        for (var i = 0; i < objects.length; i++) {\n            var object = objects[i];\n\n            if ('' + object.getMOR().val == morid)\n                return object;\n        }\n\n        return null;\n    },\n\n    _findDatacenterObjectByMORid: function(type, morid) {\n        var rootFolder = this.serviceInstance.getRootFolder();\n        var datacenters = new vim25.mo.InventoryNavigator(rootFolder).searchManagedEntities('Datacenter');\n\n        for (var i = 0; i < datacenters.length; i++) {\n            var props = [type];\n            var o = datacenters[i].getPropertiesByPaths(props);\n\n            var objects = o.get(type);\n            for (var j = 0; j < objects.length; j++) {\n                var object = new vim25.mo.Network(this.serviceInstance.getServerConnection(), objects[j]);\n                if ('' + object.getMOR().val == morid)\n                    return object;\n            }\n        }\n\n        return null;\n    },\n           \n    type: \"AVMWareProbe\"\n});\n\n// Use vijava to fetch data for all objects of a given type from our vCenter.\n/////////////////////////////////////////////////////////////////////////\nfunction fetchManagedObjects(type, dataMap) {\n\n\tvar i, o,\n\t\tpropNames = Object.keys(dataMap),\n\t\tmos = navigator.searchManagedEntities(type),\n\t\tjs = [ ];\n\n\tfor (i = 0; i < mos.length; i++) {\n\t\to = getPropsForManagedObject(mos[i], dataMap, propNames);\n\t\tjs.push(o);\n\t}\n\t\n\treturn js;\n}\n\n/*\n * Use vijava to fetch data for a single managed object from our vCenter.\n *\n * The data to fetch is driven by the 'dataMaps' parameter.  In the simplest\n * case, dataMaps is a single object that gets primitive values from vCenter:\n *   { name: 'hostName' }\n * This says to get 'name' from 'mo' and to store it in 'hostName'.  The return\n * would be something like:\n *   { hostName: 'ESX 1' }\n * Nested objects can be retrieved by passing nested objects:\n *   {\n *      name: 'hostName',\n *      summary: { memorySize: 'ram' }\n *   }\n * In this case you can't choose the name of 'summary' in the result.  You'll get\n * something like:\n *  {\n *     hostName: 'ESX 1',\n *     summary: { ram: 4096 }\n *  }\n * Note that 'memorySize' is an integer, so it's returned as a number.\n * The nested object can itself contain nested objects.  If the returned data is going\n * to be an array, the datamap has to indicate this:\n *  {\n *     name: 'hostName',\n *     summary: { memorySize: 'ram' },\n *     hardware: {\n *        cpuPkg: [ { vendor: 'cpu_manf' } ]\n *     }\n *  }\n * This says to fetch 'hardware' for a managed object, then to fetch 'cpuPkg'\n * from hardware.  cpuPkg will be an array of objects.  From each object, get\n * the cpu's vendor.  The result will be something like:\n *  {\n *     hostName: 'ESX 1',\n *     summary: { ram: 4096 },\n *     hardware: {\n *        cpuPkg: [ { cpu_manf: 'Intel' }, { cpu_manf: 'Intel' } ]\n *     }\n *  }\n * Managed objects (both the original object and any nested objects which are managed)\n * will have a member named 'mo' which will have the MOR for the object.  If you only want\n * this MOR, specify an empty object:\n *  {\n *     name: 'hostName',\n *     summary: { memorySize: 'ram' },\n *     hardware: {\n *        cpuPkg: [ { vendor: 'cpu_manf' } ]\n *     },\n *     vm: [ { } ]\n *  }\n * Normally this function will use the member name to call a vijava function to get the value, so:\n *    name: 'hostName'\n * causes a call to getName() on vijava.  Unfortunately a handful of boolean values require 'is'\n * instead of 'get'.  Because of this, the value in the map can be a function:\n *  {\n *     template: function(value, o) { o.template = !!value.isTemplate(); }\n *  }\n * 'value' is the vijava object (assumed to be a simple value).  'o' is the JS object to stick\n * the result on.\n * Sometimes an array will contain objects of multiple types.  You can simply ask for any data\n * that you want off any of the types:\n *  {\n *     hardware: {\n *        device: [ {\n *           capacityInKB: 'capacity',\n *           macAddress: 'mac'\n *        } ]\n *     }\n *  }\n * If the hardware device is a hard disk it will fetch capacity.  If it's a NIC it will\n * fetch the MAC address.\n *\n * @param mo         a ManagedObjectReference or MOR ID (string)\n * @param dataMap    The data to get, as defined above\n * @param type       Requred when 'mo' is a string.  The manged object type.\n */\nfunction getPropsForManagedObject(mo, dataMap, type) {\n\n\tvar props, mor, o,\n\t\tpropNames = dataMap.propNames || Object.keys(dataMap);\n\n\tif (typeof mo == 'string') {\n\t\tmor = new vim25.ManagedObjectReference();\n\t\tmor.setType(type);\n\t\tmor.setVal(mo);\n\t\tmo = vim25.mo.util.MorUtil.createExactManagedEntity(this.serverConnection, mor);\n\t}\n\n\tmor = mo.getMOR();\n\to = {\n\t\tmo: mo,\n\t\ttype: '' + mor.getType(),\n\t\tmorid: '' + mor.getVal()\n\t};\n\n\tdataMap.propNames = propNames;\n\n\t// This isn't working - we're marking objects that we don't get\n\t// any values for as missing.  We don't use the information currently,\n\t// so don't worry about it.\n\t//if (propNames.length)\n\t//\to.noSuchObject = true;\n\n\ttry {\n\t\tprops = getProps(propNames);\n\t} catch (e) {\n\t\tpropNames.forEach(getProp);\n\t}\n\n\treturn o;\n\n\tfunction getProp(propName) {\n\t\tif (propName == 'propNames')\n\t\t\treturn;\n\n\t\ttry {\n\t\t\tgetProps([ propName ]);\n\t\t} catch (e) {\n\t\t\tms.log('Unable to get ' + propName);\n\t\t\tms.log(e.toString());\n\t\t\tms.log(e.stack);\n\t\t}\n\t}\n\n\tfunction getProps(propNames) {\n\t\tprops = mo.getPropertiesByPaths(propNames);\n\t\tpropNames.forEach(getVal);\n\t\t//o.noSuchObject = undefined;\n\t}\n\n\tfunction getVal(key) {\n\t\tvar prop,\n\t\t\tnewName = dataMap[key];\n\n\t\tif (!newName)\n\t\t\treturn;\n\n\t\tprop = props.get(key);\n\t\tgetValue(prop, key, o, newName);\n\t}\n}\n\n/*\n * Like getPropsForManagedObject, except you don't have to know the\n * type of the managed object.  You can pass in multiple datamaps for\n * multiple types of managed objects:\n *   {\n *      ComputeResource: computeMap,\n *      ClusterComputeResource: clusterMap\n *   }\n */\nfunction getPropsForUnknownType(mo, dataMaps) {\n\n\tvar name,\n\t\tmor = mo.getMOR(),\n\t\ttype = '' + mor.getType(),\n\t\tmap = dataMaps[type];\n\n\tif (!map) {\n\t\tfor (name in dataMaps) {\n\t\t\tif (typeof dataMaps[name] != 'string') {\n\t\t\t\tif (mo instanceof vim25.mo[name]) {\n\t\t\t\t\tdataMaps[type] = name;\n\t\t\t\t\tmap = name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof map == 'string')\n\t\tmap = dataMaps[map];\n\n\treturn getPropsForManagedObject(mo, map);\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction getPropsForDynamicData(dd, map) {\n\tvar o = { temp: 0 };\n\n\tgetValue(dd, 'temp', o, map);\n\n\treturn o.temp;\n}\n\n// value is a vCenter or Java object\n// key is the name of the vCenter object in its parent\n// o is a JS object\n// name is the name in the JS object, or an array, or an object\n//////////////////////////////////////////////////////////////////////////\nfunction getValue(value, key, o, name, parent) {\n\n\tvar template, mo;\n\n\ttry {\n\t\tif (typeof name == 'string')\n\t\t\tgetSimpleValue();\n\t\telse if (name instanceof Array)\n\t\t\to[key] = getArrayValue(value, name[0], name._filter);\n\t\telse if (typeof name == 'function')\n\t\t\tname(parent, o);\n\t\telse if (value)\n\t\t\to[key] = getObjectValue(value, name);\n\t} catch (e) {\n\t\tms.log('Unable to get ' + key + ' from ' + value);\n\t\tms.log(e.toString());\n\t\tms.log(e.stack);\n\t}\n\n\tfunction getSimpleValue() {\n\n\t\tif (value === null || value === undefined)\n\t\t\treturn;\n\n\t\tif (key == 'NodeWorldWideName' || key == 'PortWorldWideName')\n\t\t\to[name] = new Packages.java.lang.Long(value).toHexString(value);\n\t\telse if (value instanceof Packages.java.lang.String)\n\t\t\to[name] = '' + value;\n\t\telse if (value instanceof Packages.java.lang.Integer ||\n\t\t\t\t value instanceof Packages.java.lang.Short)\n\t\t\to[name] = +value;\n\t\telse if (value instanceof Packages.java.lang.Long) {\n\n\t\t\t// WWNs are 64 bit ints in the VMWare API.  JavaScript can only\n\t\t\t// represent 53 bit integers, so WWNs can't be stored in a JS\n\t\t\t// number.  I hate this special handling in an otherwise generic\n\t\t\t// function, but we try to keep numbers as numbers and vCenter\n\t\t\t// uses Longs in places where the 53 bit limitation doesn't matter.\n\t\t\tif (key == 'NodeWorldWideName' || key == 'PortWorldWideName')\n\t\t\t\to[name] = value.toHexString(value);\n\t\t\telse \n\t\t\t\to[name] = +value;\n\t\t\t\t\n\t\t} else if (value instanceof Packages.java.lang.Boolean) {\n\t\t\tvalue = '' + value;\n\t\t\to[name] = false;\n\t\t\tif (value == 'true')\n\t\t\t\to[name] = true;\n\t\t} else if (value instanceof vim25.ManagedObjectReference)\n\t\t\to[name] = ('' + value.getVal()) || 'no mor available';\n\t\telse if (value.length == 1)\n\t\t\tgetValue(value[0], key, o, name);\n\t\t// vim25.ManagedEntityStatus and vim25.DrsBehavior are both enumerations of string\n\t\t// values.  For some reason ManagedEntityStatus gets the correct value without\n\t\t// forcing conversion to a string. I'd prefer to simply always convert values of\n\t\t// an unknown type to a string but I'm afraid of what it might break.\n\t\telse if (value instanceof vim25.DrsBehavior || value instanceof vim25.HostSystemConnectionState || value instanceof vim25.HostSystemPowerState)\n\t\t\to[name] = value + '';\n\t\telse\n\t\t\to[name] = value;\n\t}\n\n\tfunction getObjectValue(obj, template) {\n\t\tvar mo, o, name, dest, member, commonTemplate, format;\n\n\t\ttry {\n\t\t\tif (obj instanceof vim25.ManagedObjectReference) {\n\t\t\t\tmo = new vim25.mo.ManagedEntity(serverConnection, obj);\n\t\t\t\to = getPropsForManagedObject(mo, template);\n\t\t\t} else if (obj instanceof Packages.java.lang.String)\n\t\t\t\treturn '' + obj;\n\t\t\telse if (obj instanceof Packages.java.lang.Integer ||\n\t\t\t\t\t\t value instanceof Packages.java.lang.Short ||\n\t\t\t\t\t     value instanceof Packages.java.lang.Long)\n\t\t\t\t\treturn +obj;\n\t\t\telse if (obj instanceof Packages.java.util.GregorianCalendar) {\n\n\t\t\t\t// Constant values from https://docs.oracle.com/javase/7/docs/api/constant-values.html#java.util.Calendar.ALL_STYLES\n\t\t\t\t// 1 = YEAR, 2 = MONTH, 5 = DAY_OF_MONTH, 10 = HOUR, 12 = MINUTE, 13 = SECOND\n\t\t\t\tformat = [ 1, '-', 2, '-', 5, 'T', 10, ':', 12, ':', 13, 'Z' ];\n\t\t\t\tformat.forEach(\n\t\t\t\t\tfunction(fmt, idx) {\n\t\t\t\t\t\tvar val;\n\t\t\t\t\t\tif (typeof fmt == 'number') {\n\t\t\t\t\t\t\tval = obj.get(fmt);\n\t\t\t\t\t\t\tif (fmt == 2)   // Month is 0 based - add 1 to get what people expect\n\t\t\t\t\t\t\t\tval++;\n\t\t\t\t\t\t\tif (fmt == 1)\n\t\t\t\t\t\t\t\tformat[idx] = val;  // Don't add leading 0s to year\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tformat[idx] = ('0' + val).substr(-2);   // Add leading 0s to all other numbers\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\treturn format.join('');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (name in commonTypes) {\n\t\t\t\t\tif (obj instanceof commonTypes[name])\n\t\t\t\t\t\ttemplate = commonTemplates[name];\n\t\t\t\t}\n\n\t\t\t\tif (template instanceof Array)\n\t\t\t\t\treturn getArrayValue(obj, template);\n\n\t\t\t\to = { };\n\t\t\t\t\n\t\t\t\tfor (var drsObjectType in drsDataObjectTypes) {\n\t\t\t\t\tif(obj instanceof drsDataObjectTypes[drsObjectType]) {\n\t\t\t\t\t\to['parent'] = '' + obj;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (typeof template == 'object') {\n\t\t\t\t\tfor (name in template) {\n\t\t\t\t\t\tdest = template[name];\n\t\t\t\t\t\tmember = obj['get' + capitalize(name)]();\n\t\t\t\t\t\tgetValue(member, name, o, dest, obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tms.log('Unable to get ' + template + ' from ' + obj);\n\t\t\tms.log(e.toString());\n\t\t\tms.log(e.stack);\n\t\t}\n\n\t\treturn o;\n\n\t\tfunction capitalize(s) { return s[0].toUpperCase() + s.substr(1); }\n\t}\n\n\tfunction getArrayValue(obj, template, filter) {\n\t\tvar i, o,\n\t\t\ta = [ ];\n\n\t\tfor (i = 0; obj && (i < obj.length); i++) {\n\t\t\to = getObjectValue(obj[i], template);\n\t\t\tif (!filter || filter(obj[i], o))\n\t\t\t\ta.push(o);\n\t\t}\n\n\t\treturn a;\n\t}\n}\n\n\n    // This function retrieves the vCenter appliance information.\n    //////////////////////////////////////////////////////////////////////////////////////\n\nfunction getApplianceInfo() {\n\tvar response;\n\tvar responseObj;\n\tvar postMethod;\n\tvar sessionKey;\n\tvar headers = {\n\t\t'Content-Type': 'application/json',\n\t\t'Accept': 'application/json'\n\t};\n\tvar source = probe.getParameter('source');\n\tvar postMethodType = 'POST';\n\tvar getMethodType = 'GET';\n\tvar getApplianceInfovCenterURL = this.IPAddress.fromString(source).isV4() ? 'https://' + source + '/rest/appliance/networking' : 'https://[' + source + ']/rest/appliance/networking'; \n\tvar GlideHTTPClient = Packages.com.glide.communications.HTTPClient;\n\tvar httpClient = new GlideHTTPClient();\n\n        /*\n        \tIn order to get the appliance information, first we've to establish a session with the\n        \trespctive vCenter in order to make further calls to it\n        \tURL: https:// {vCenter IP} /apiexplorer/#/session_\n\n        \tBelow method makes a REST call to the VMWare for creating a session and returns\n        \tthe response. Below is the sample output:\n        \t///////////////////////////////////////////////////////////////////////////////\n        \t\t{\n        \t\t\t\"response\": { \"status\":200,\"value\":\"bba9433e467d08d8593f21b566e18360\" }\n        \t\t}\n        \t///////////////////////////////////////////////////////////////////////////////\n        */\n\n\tresponse = setUpvCenterSession(httpClient, source);\n\tif(response.status == \"200\")\n        \tsessionKey = response.value;\n\n        if (!sessionKey)\n            return {\n                error: 'vCenter Message: ' + response\n            };\n        headers['vmware-api-session-id'] = sessionKey;\n\n        responseObj = triggerRESTCall(httpClient, getApplianceInfovCenterURL, getMethodType, headers);\n\n        if (responseObj.hasOwnProperty('error'))\n            return {\n                error: 'vCenter Message: ' + responseObj.error\n            };\n\n        return responseObj;\n\n    }\n\n// This function retrieves the tags information for the provided set of mor ids.\n//////////////////////////////////////////////////////////////////////////////////////\n// INPUT: [ \"vm-2323\", \"vm-1324\", \"vm-865\" ]\n//\n// OUTPUT:\n//\t\t[\n//\t\t\t{\n//\t\t\t\t\"vm_mor_id\": \"vm-4564\",\t\t//mor_id of the vm\n//\t\t\t\t\"key\": \"Dev_lab\",\t\t\t//tag category name\n//\t\t\t\t\"value\": \"User\",\t\t\t//tag name\n//\t\t\t\t\"source\": \"tags\"\n//\t\t\t}\n//\t\t]\n//////////////////////////////////////////////////////////////////////////////////////\nfunction getTagsForResources(morIDs) {\n\n\tvar body;\n\tvar response;\n\tvar responseObj;\n\tvar postMethod;\n\tvar sessionKey;\n\tvar bodyContent = {};\n\tvar outputToProbe = [];\n\tvar tagsDatamap = {\n\t\t\t\t\t\ttaggedVMs: [],\n\t\t\t\t\t\tresourceInfo: {},\n\t\t\t\t\t\ttagsInfo: {},\n\t\t\t\t\t\ttagCategoryInfo: {}\n\t\t\t\t\t};\n\tvar uniqueTags = [];\n\tvar uniqueCategories = [];\n\tvar headers = {\n\t\t'Content-Type': 'application/json',\n\t\t'Accept': 'application/json'\n\t};\n\tvar source = probe.getParameter('source');\n\tvar postMethodType = 'POST';\n\tvar getMethodType = 'GET';\n\tvar getTagInfovCenterURL = this.IPAddress.fromString(source).isV4() ? 'https://'+ source +'/rest/com/vmware/cis/tagging/tag/id:' : 'https://['+ source +']/rest/com/vmware/cis/tagging/tag/id:';\n\tvar getTagCategoryInfovCenterURL = this.IPAddress.fromString(source).isV4() ? 'https://'+ source +'/rest/com/vmware/cis/tagging/category/id:' : 'https://['+ source +']/rest/com/vmware/cis/tagging/category/id:';\n\tvar getTagsForVMsvCenterURL = this.IPAddress.fromString(source).isV4() ? 'https://'+ source +'/rest/com/vmware/cis/tagging/tag-association?~action=list-attached-tags-on-objects' : 'https://['+ source +']/rest/com/vmware/cis/tagging/tag-association?~action=list-attached-tags-on-objects';\n\tvar resourceMorIDs = JSON.parse(morIDs);\n\tvar GlideHTTPClient = Packages.com.glide.communications.HTTPClient;\n\tvar httpClient = new GlideHTTPClient();\n\n        /*\n        \tIn order to get the tags information, first we've to establish a session with the\n        \trespctive vCenter in order to make further calls to it\n        \tURL: https:// {vCenter IP} /apiexplorer/#/session_\n\n        \tBelow method makes a REST call to the VMWare for creating a session and returns\n        \tthe response. Below is the sample output:\n        \t///////////////////////////////////////////////////////////////////////////////\n        \t\t{\n        \t\t\t\"response\": { \"status\":200,\"value\":\"bba9433e467d08d8593f21b566e18360\" }\n        \t\t}\n        \t///////////////////////////////////////////////////////////////////////////////\n        */\n\n\tresponse = setUpvCenterSession(httpClient, source);\n\tif(response.status == \"200\")\n        \tsessionKey = response.value;\n\n\t// If no credentials worked then we return the response with the error message\n\tif (!sessionKey)\n\t\treturn { error: 'vCenter Message: ' + response };\n\n\t// Setting the sessionKey to the header variable in order to use it in further REST calls\n\theaders['vmware-api-session-id'] = sessionKey;\n\n\t/*\n\t\tOnce the session key is received, we now trigger a REST call to fetch the tags used for\n\t\tthe list of resources provided by using the list of mor ids passed.\n\n\t\tBelow is the sample output:\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t\t{\n\t\t\t\t\"response\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"tag_ids\":[\n\t\t\t\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:22c1d0af-84f0-4b5a-a412-58ead2dc04c5:GLOBAL\",\n\t\t\t\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:7b5419c6-4a60-4e83-a89b-c3a896424d41:GLOBAL\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"object_id\":{\n\t\t\t\t\t\t\t\t\"id\":\"vm-4564\",\n\t\t\t\t\t\t\t\t\"type\":\"VirtualMachine\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"tag_ids\":[\n\t\t\t\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:c75576d3-2cea-4dd5-9875-ea602d83b7ad:GLOBAL\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\"object_id\":{\n\t\t\t\t\t\t\t\t\"id\":\"vm-5228\",\n\t\t\t\t\t\t\t\t\"type\":\"VirtualMachine\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t}\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t*/\n\t//Build the body content for making the REST call\n\tbodyContent.object_ids = resourceMorIDs.map(function(id) { return { id: id.morid, type: id.type }; });\n\n\tbody = {\n\t\tcontent: JSON.stringify(bodyContent),\n\t\ttype: 'application/json',\n\t\tcharSet: 'UTF-8'\n\t};\n\n        responseObj = triggerRESTCall(httpClient, getTagsForVMsvCenterURL, postMethodType, headers, body);\n\n\tif (responseObj.hasOwnProperty('error'))\n\t\treturn { error: 'vCenter Message: ' + responseObj.error };\n\n\tuniqueTags = extractUniqueTagIDs(responseObj.response);\n\n\t/*\n\t\tFor the list of associated tags, below we discover further information about the\n\t\ttag categories, tags and build a data map that is further used to refine the data\n\n\t\tSample data for \"tagsDatamap\" variable is\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t\t{\n\t\t\t\t\"taggedVMs\":[\n\t\t\t\t\t\"vm-4564\"\n\t\t\t\t],\n\t\t\t\t\"resourceInfo\":{\n\t\t\t\t\t\"vm-4564\":[\n\t\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:22c1d0af-84f0-4b5a-a412-58ead2dc04c5:GLOBAL\",\n\t\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:7b5419c6-4a60-4e83-a89b-c3a896424d41:GLOBAL\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"tagsInfo\":{\n\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:22c1d0af-84f0-4b5a-a412-58ead2dc04c5:GLOBAL\":{\n\t\t\t\t\t\t\t\t\"name\":\"User\",\n\t\t\t\t\t\t\t\t\"categoryID\":\"urn:vmomi:InventoryServiceCategory:6ac3d15f-807b-4081-a1bf-89209bc1c7ed:GLOBAL\"\n\t\t\t\t\t},\n\t\t\t\t\t\"urn:vmomi:InventoryServiceTag:7b5419c6-4a60-4e83-a89b-c3a896424d41:GLOBAL\":{\n\t\t\t\t\t\t\t\t\"name\":\"Dev_app\",\n\t\t\t\t\t\t\t\t\"categoryID\":\"urn:vmomi:InventoryServiceCategory:6ac3d15f-807b-4081-a1bf-89209bc1c7ed:GLOBAL\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t   \"tagCategoryInfo\":{\n\t\t\t\t\t   \"urn:vmomi:InventoryServiceCategory:6ac3d15f-807b-4081-a1bf-89209bc1c7ed:GLOBAL\":\"Dev_lab\"\n\t\t\t\t}\n\t\t\t}\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t*/\n\tresponseObj = responseObj.response;\n\tresponseObj.forEach(function(obj){\n\t\ttagsDatamap.taggedVMs.push(obj.object_id.id);\n\t\ttagsDatamap.resourceInfo[obj.object_id.id] = obj.tag_ids;\n\t});\n\n\t//Getting the Information for each tag\n\tuniqueTags.forEach(function(tagId){\n\t\tvar tagCategoryID;\n\t\t/*\n\t\t\tTrigger the REST call to retrieve the information about a tag when tag id is provided\n\n\t\t\tBelow is the sample output:\n\t\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t\t\t{\n\t\t\t\t\t\"response\":{\n\t\t\t\t\t\t\t\"category_id\":\"urn:vmomi:InventoryServiceCategory:6ac3d15f-807b-4081-a1bf-89209bc1c7ed:GLOBAL\",\n\t\t\t\t\t\t\t\"name\":\"User\",\n\t\t\t\t\t\t\t\"description\":\"System Administrator\",\n\t\t\t\t\t\t\t\"id\":\"urn:vmomi:InventoryServiceTag:22c1d0af-84f0-4b5a-a412-58ead2dc04c5:GLOBAL\",\n\t\t\t\t\t\t\t\"used_by\":[]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t*/\n            responseObj = triggerRESTCall(httpClient, (getTagInfovCenterURL + tagId), getMethodType, headers);\n\n\t\tif (responseObj.hasOwnProperty('response')) {\n\n\t\t\t//Extracting the Category ID to fetch their information\n\t\t\tresponse = responseObj.response;\n\t\t\ttagCategoryID = response.category_id;\n\n\t\t\t//Adding Tags and it's information to the 'tagsDatamap' variable\n\t\t\ttagsDatamap.tagsInfo[response.id] = {\n\t\t\t\tname: response.name,\n\t\t\t\tcategoryID: tagCategoryID\n\t\t\t};\n\n\t\t\tif (uniqueCategories.indexOf(tagCategoryID) == -1)\n\t\t\t\tuniqueCategories.push(tagCategoryID);\n\t\t}\n\t});\n\n\tuniqueCategories.forEach(function(categoryId){\n\t\t/*\n\t\t\tTrigger the REST call to retrieve the information about a tag category when category id is provided\n\n\t\t\tBelow is the sample output:\n\t\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t\t\t{\n\t\t\t\t\t\"response\":{\n\t\t\t\t\t\t\t\"associable_types\":[],\n\t\t\t\t\t\t\t\"name\":\"Dev_lab\",\n\t\t\t\t\t\t\t\"description\":\"\",\n\t\t\t\t\t\t\t\"id\":\"urn:vmomi:InventoryServiceCategory:6ac3d15f-807b-4081-a1bf-89209bc1c7ed:GLOBAL\",\n\t\t\t\t\t\t\t\"used_by\":[],\n\t\t\t\t\t\t\t\"cardinality\":\"MULTIPLE\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t*/\n            responseObj = triggerRESTCall(httpClient, (getTagCategoryInfovCenterURL + categoryId), getMethodType, headers);\n\n\t\tif (responseObj.hasOwnProperty('response')) {\n\n\t\t\t//Adding category and it's name to the 'tagsDatamap' variable\n\t\t\tresponse = responseObj.response;\n\t\t\ttagsDatamap.tagCategoryInfo[response.id] = response.name;\n\n\t\t}\n\t});\n\n\t/*\n\t\tOnce \"tagsDatamap\" is constructed with all the data, we build a result to pass back to\n\t\tthe probe\n\n\t\tBelow is the sample output:\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"morid\": \"vm-4564\",\t\t//mor_id of the vm\n\t\t\t\t\t\"key\": \"Dev_lab\",\t\t\t//tag category name\n\t\t\t\t\t\"value\": \"User\",\t\t\t//tag name\n\t\t\t\t\t\"tag\": \"Tags\"\n\t\t\t\t}\n\t\t\t]\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t*/\n\n\ttagsDatamap.taggedVMs.forEach(function(mor_id){\n\t\tvar categoryID = '';\n\t\tvar tags = tagsDatamap.resourceInfo[mor_id];\n\t\tfor (var i in tags) {\n\t\t\t\tcategoryID = tagsDatamap.tagsInfo[tags[i]].categoryID;\n\t\t\t\toutputToProbe.push({\n\t\t\t\t\tmorid: mor_id,\n\t\t\t\t\tkey: tagsDatamap.tagCategoryInfo[categoryID],\n\t\t\t\t\tvalue: tagsDatamap.tagsInfo[tags[i]].name,\n\t\t\t\t\ttag: 'Tags'\n\t\t\t\t});\n\t\t}\n\t});\n\n\treturn { cmdb_key_value: outputToProbe };\n\n        ///////////////////////////////////////////////////////////////////////////////\n        function extractUniqueTagIDs(tagsInfoList) {\n            var tagObj = {};\n            tagsInfoList.forEach(function(obj) {\n                for (var i in obj.tag_ids)\n                    tagObj[obj.tag_ids[i]] = 1;\n            });\n\n            return Object.keys(tagObj);\n        }\n    }\n\n    // Generic API for making the REST Call\n    ///////////////////////////////////////////////////////////////////////////////\nfunction triggerRESTCall(httpClient, url, methodType, headers, body) {\n        var method;\n        var GetMethod = Packages.org.apache.commons.httpclient.methods.GetMethod;\n        var PostMethod = Packages.org.apache.commons.httpclient.methods.PostMethod;\n        var StringRequestEntity = Packages.org.apache.commons.httpclient.methods.StringRequestEntity;\n\n\tif (methodType == 'GET')\n\t\tmethod = new GetMethod(url);\n\telse if (methodType == 'POST') {\n\t\tmethod = new PostMethod(url);\n\t\tmethod.setRequestEntity( new StringRequestEntity(body.content, body.type, body.charSet) );\n\t}\n\n\tfor (var i in headers)\n\t\tmethod.setHeader(i, headers[i]);\n\n        try {\n\t\tvar status = (httpClient.executeMethod(method)) + '';\n\t\tvar response = JSON.parse(method.getResponseBodyAsString());\n\n\t\tif (status != '200') {\n\t\t\tms.log(status + ':' + JSON.stringify(response).substring(0, 10000));\n\t\t\treturn { error: status + ': Unable to process the request' };\n\t\t}\n\n\t\treturn { response: response.value };\n\t} catch(ex) {\n\t\treturn { error : (ex.getMessage && ex.getMessage() || ex) + '' };\n\t}\n    }\n\n\n    //Below method makes a REST call to the VMWare for creating a session and returns the response.\n    ///////////////////////////////////////////////////////////////////////////////\n\nfunction setUpvCenterSession(httpClient, source) {\n        var IPAddress = Packages.com.snc.commons.networks.IPAddress;\n        var status;\n        var response;\n        var getSessionvCenterURL = IPAddress.fromString(source).isV4() ? 'https://' + source + '/rest/com/vmware/cis/session' : 'https://[' + source + ']/rest/com/vmware/cis/session';\n        var credentials = _this.getCredentials(\"vmware\");\n        var PostMethod = Packages.org.apache.commons.httpclient.methods.PostMethod;\n        var sessionAPIHeader = 'ServiceNow Discovery';\n\n\twhile (credentials.hasNext() && (status != '200')) {\n\t\tvar credential = credentials.next();\n\t\tpostMethod = new PostMethod(getSessionvCenterURL);\n\t\tpostMethod.setHeader('vmware-use-header-authn', sessionAPIHeader);\n\t\thttpClient.setBasicAuth(credential.getUsername(), credential.getPassword());\n\n\t\ttry {\n\t\t\tstatus = (httpClient.executeMethod(postMethod)) + '';\n\t\t\tresponse = JSON.parse(postMethod.getResponseBodyAsString());\n\n\t\t\tif (status == '200') {\n\t\t\t\tresponse.status = status;\n\t\t\t\treturn response;\n\t\t    } else\n\t\t\tresponse = (response.value.hasOwnProperty('messages') && response.value.messages[0].hasOwnProperty('default_message')) ?\n\t\t\tresponse.value.messages[0].default_message : 'Session cannot be established';\n\n\t\t} catch (ex) {\n\t\t\tif (typeof ex == 'object')\n\t\t\t\tresponse = ex.getMessage() || ex + '';\n\t\t\telse if (typeof ex == 'string' && ex.length)\n\t\t\t\tresponse = ex;\n\t\t\telse\n\t\t\t\tresponse = 'Session cannot be established';\n\t\t}\n        }\n        return response;\n\n}})();\n",
      "sys_id": "8ba9e32d0a0a0bb0496b9f907870483d"
    },
    {
      "script": "ms.include(\"PrototypeServer\");\r\n\r\nvar JDBCProbeErrorHandler = Class.create();\r\nJDBCProbeErrorHandler.prototype = {\r\n\r\n  initialize: function() {\r\n\r\n  },\r\n\r\n  process: function() {\r\n    return \"JDBCProbeError handled\";\r\n  },\r\n    \r\n  type: \"JDBCProbeErrorHandler\"\r\n}",
      "sys_id": "8d290571ff2200007fe1fe51c17f9dcc"
    },
    {
      "script": "// Discovery\n\nvar TabularTextParser = Class.create();\nTabularTextParser.prototype = {\n    initialize: function() {\n        // set this to a global regular expression that will recognize column separators...\n        this.separator = /\\s+/g;\n        \n        // set this false if the last column may NOT conatin separators...\n        this.last_column_may_contain_separators = true;\n        \n        // contains an error message if there was any...\n        this.error_msg = null;\n    },\n\n    /**\n     * Parses the given text, returning an array (one entry per data line) of maps of property name to value.\n     * The text may contain more columns than we're actually interested in.  The columns may be separated by \n     * any sequence identifiable in a global regular expression; the default is 1 -> n spaces.  The last column \n     * may optionally contain column separators in its field.  The columns may appear in any order, with the \n     * single exception in the case where the last column may contain separators; obviously in that case that \n     * column must be the last one.  Blank data lines are skipped.  The first line MUST be a line of column \n     * headers.\n     * \n     * The columns of interest are given in the columns argument, which must be an array of column info objects\n     * with these properties:\n     *   header_matcher: a regular expression that will match the column header\n     *   prop_name:      the name of the property to use\n     *   last:           true if the column must be last (presumably because it may contain column separators)\n     *   \n     * On a successful completion, the array of line values is returned, and the parser's error_msg property \n     * is null.  If there are any errors, the array of line values is returned, but it may be either empty or\n     * missing some rows of data.  In this case, the parser's error_msg property will NOT be null, but will\n     * instead contain an error message.\n     */\n    parse: function(text, columns) {\n        var results = [];\n        \n        // sanity checks...\n        if ((text == null) || (columns == null) || (text.length == 0) || (columns.length == 0)) {\n            this.error('Invalid inputs to TabularTextProcessor');\n            return results;\n        }\n        \n        // first get an array of lines...\n        var lines = text.split(/\\r?\\n/);\n        if (lines.length <= 1) {\n            this.error('Input doesn\\'t include any data (an possibly no headers)');\n            return results;\n        }\n        \n        // now parse the first line to get our column headers...\n        var headers = this.parse_line(lines[0], 0);\n        \n        // figure out which (and how many) columns we're interested in...\n        var interested = [];\n        var max = 0;\n        for (var i = 0; i < headers.length; i++) {\n            for (var j = 0; j < columns.length; j++) {\n                if (columns[j].header_matcher.test(headers[i])) {\n                    if ((max > 0) && (i >= max)) {\n                        this.error('Column ' + columns[j].prop_name + ' is beyond column specified as the last column');\n                        return results;\n                    }\n                    columns[j].col = i;\n                    interested.push(columns[j]);\n                    if (columns[j].last)\n                        max = i + 1;\n                }\n            }\n        }\n        \n        // parse all our lines, skipping any empty lines...\n        for (var i = 1; i < lines.length; i++) {\n            if (!lines[i])\n                continue;\n            \n            var cols = this.parse_line(lines[i], max);\n            var map = {};\n            for (var j = 0; j < interested.length; j++)\n                map[interested[j].prop_name] = cols[interested[j].col];\n            results.push(map);\n        }\n        \n        return results;\n    },\n    \n    /**\n     * Return an array of the columns contained in the given line of data.  If max is zero, then one entry \n     * is returned for every separated column in the line.  If max is greater than zero, no more than max\n     * entries are returned, and the last one will include all remaining data on the line.  Any leading\n     * whitespace in the line is ignored.\n     */\n    parse_line: function(line, max) {\n        var ws = /^\\s*/.exec(line);\n        line = line.substring(ws[0].length);\n        var results = [];\n        var cur_pos = 0;\n        var match = null;\n        this.separator.lastIndex = 0;\n        while (match = this.separator.exec(line)) {\n            results.push(line.substring(cur_pos, match.index));\n            cur_pos = this.separator.lastIndex;\n            if ((max > 0) && (results.length + 1 >= max))\n                break;\n        }\n        results.push(line.substring(cur_pos));\n        return results;\n    },\n    \n    /**\n     * Appends the given error message.\n     */\n    error: function(msg) {\n        if (this.error_msg)\n            this.error_msg += msg + '\\n';\n        else\n            this.error_msg = msg + '\\n';\n    },\n    \n    type: 'TabularTextParser'\n};",
      "sys_id": "901bde7b9f21210054679ff3367fcf99"
    },
    {
      "script": "ArrayPolyfill;\n\nvar VMWarevCenterProbe = Class.create();\n\n(function() {\n\nvar getWWNString = Packages.com.service_now.mid.probe.VMWareProbe.getWWNString,\n\tv4 = /[0-9]{1,3}(\\.[0-9]{1,3}){3}/,\n\tmasks = [\n\t\t'0.0.0.0',\n\t\t'128.0.0.0',       '192.0.0.0',       '224.0.0.0',       '240.0.0.0',\n\t\t'248.0.0.0',       '252.0.0.0',       '254.0.0.0',       '255.0.0.0',\n\t\t'255.128.0.0',     '255.192.0.0',     '255.224.0.0',     '255.240.0.0',\n\t\t'255.248.0.0',     '255.252.0.0',     '255.254.0.0',     '255.255.0.0',\n\t\t'255.255.128.0',   '255.255.192.0',   '255.255.224.0',   '255.255.240.0',\n\t\t'255.255.248.0',   '255.255.252.0',   '255.255.254.0',   '255.255.255.0',\n\t\t'255.255.255.128', '255.255.255.192', '255.255.255.224', '255.255.255.240',\n\t\t'255.255.255.248', '255.255.255.252', '255.255.255.254', '255.255.255.255' ];\n\nVMWarevCenterProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n        this.debug('Starting vCenter discovery...');\n        this.vCenter = {};\n\n        // Object data to fetch\n        this.datacenters = [];\n        this.folders = [];\n        this.clusters = [];\n        this.hosts = [];\n        this.vmInstances = [];\n        this.resourcePools = [];\n        this.networks = [];\n        this.datastores = [];\n\n        // Relationships between the objects we fetch\n        this.hostVmRel = {};\n        this.networkVmRel = {};\n        this.networkHostRel = {};\n        this.datastoreVmRel = {};\n        this.datastoreHostRel = {};\n        this.hostClusterRel = {};\n        this.resourcePoolClusterRel = {};\n        this.resourcePoolHostRel = {};\n        this.folderRel = {};\n        this.datacenterNetworkRel = {};\n        this.datacenterVmRel = {};\n        this.datacenterHostRel = {};\n        this.datacenterDatastoreRel = {};\n\n        // Special purpose objects\n        this.processedDatastores = {};\n        this.processedNetworks = {};\n        this.processedClusters = {};\n        this.hostParent = {};\n\n        if (!this.processvCenter())\n\t\t\treturn;\n\n        this.debug('Fetching and processing managed entities');\n        this.processManagedEntities('Datacenter', this.processDatacenter, this);\n        this.processManagedEntities('Folder', this.processFolder, this);\n        this.processManagedEntities('ClusterComputeResource', this.processCluster, this);\n        this.processManagedEntities('HostSystem', this.processHostSystem, this);\n        this.processManagedEntities('ResourcePool', this.processResourcePool, this);\n        this.processManagedEntities('VirtualMachine', this.processVirtualMachine, this);\n\n        this.debug('Generating XML payload');\n        this.generateXMLPayload();\n    },\n\n\t// returns false if error\n    processvCenter : function() {\n        var props = ['content.about.instanceUuid',\n                     'content.about.apiVersion', \n                     'content.about.fullName', \n                     'content.about.name', \n                     'content.about.version'];\n\t\t\n        // If older than 2.5, content.about.instanceUuid does not exist and will throw an InvalidProperty exception\n        var o = {};\n        try {\n            o = this.processObjectProperties(props, this.serviceInstance);\n        } catch (e) {\n            props = ['content.about.apiVersion', \n                     'content.about.fullName', \n                     'content.about.name', \n                     'content.about.version'];\n            o = this.processObjectProperties(props, this.serviceInstance);\n        }\n\t\t\n\t\t// Error if vCenter version too old.\n\t\tvar vCenterMinApiVersion = \"4.1\";\n\t\tvar vc = new Packages.com.service_now.mid.util.VersionComparator();\n\t\tif (vc.compare(vCenterMinApiVersion, o.obj['content.about.apiVersion']) < 0) {\n\t\t\tthis.setError(\"vCenter version \" + o.obj['content.about.apiVersion'] + \" is not supported.  Only \" + vCenterMinApiVersion + \" or newer is supported\");\n\t\t\treturn false;\n\t\t}\t\n\n        o.obj['url'] = '' + this.serviceInstance.getServerConnection().getUrl();\n        this.vCenter = o.obj;\n\t\treturn true;\n    },\n\n    processDatacenter: function(datacenter, thisObj) {\n        var props = ['name',\n                     'network',\n                     'vmFolder',\n                     'hostFolder',\n                     'datastore'];\n        var o = thisObj.processObjectProperties(props, datacenter);\n\n        var networks = o.propvals.get('network') || [];\n        for (var i = 0; i < networks.length; i++) {\n            var network = new vim25.mo.Network(thisObj.serviceInstance.getServerConnection(), networks[i]);\n            thisObj.processNetwork(network, thisObj);\n        }\n\n        thisObj.processRelationship('network', o, thisObj.datacenterNetworkRel, thisObj);\n        thisObj.processRelationship('datastore', o, thisObj.datacenterDatastoreRel, thisObj);\n        thisObj.processRelationshipSubFolder('vmFolder', o, thisObj.datacenterVmRel, thisObj);\n        thisObj.processRelationshipSubFolder('hostFolder', o, thisObj.datacenterHostRel, thisObj);\n\n        thisObj.datacenters.push(o.obj);\n\n\t\t// PRB647166: A bug in vijava doesn't let us get datastores from the top level object with\n\t\t// vSphere 6.0.  Get datastores via their association to datacenters instead.\n\t\tvar datastores = o.propvals.get('datastore') || [];\n\t\tfor (i = 0; i < datastores.length; i++) {\n\t\t\tvar datastore = new vim25.mo.Datastore(thisObj.serviceInstance.getServerConnection(), datastores[i]);\n\t\t\tthisObj.processDatastore(datastore, thisObj);\n\t\t}\n    },\n\n    processFolder: function(folder, thisObj) {\n        var props = ['name',\n                     'parent',\n                     'childEntity',\n\t\t\t\t\t 'childType'];\n        var o = thisObj.processObjectProperties(props, folder);\n\n        var parent = o.propvals.get('parent');\n        if (parent) {\n            var managedEntity = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), parent);\n            o.obj['parent'] = managedEntity.getMOR().val;\n        } else\n            o.obj['parent'] = '';\n\n        thisObj.processRelationship('childEntity', o, thisObj.folderRel, thisObj);\n\t\t\n\t\tvar childTypes = o.propvals.get('childType') || [];\n\t\to.obj['folderType'] = [];\n\t\tfor (var i = 0; i < childTypes.length; i++) {\n\t\t\tvar childType = {};\n\t\t\tchildType['childType'] = childTypes[i];\n\t\t\to.obj['folderType'].push(childType);\n\t\t}\n\t\t\n        thisObj.folders.push(o.obj);\n    },\n\t\n\tprocessDatastore : function(dataStore, thisObj) {\t\t\n\t\tvar props = ['summary.accessible',\n                     'summary.capacity', \n                     'summary.freeSpace', \n                     'summary.name', \n                     'summary.type', \n                     'summary.url',\n                     'vm',\n                     'host',\n\t\t\t\t\t 'capability.perFileThinProvisioningSupported'];\n\n        var o = thisObj.processObjectProperties(props, dataStore);\n\t\to.obj['datastoreHostMount'] = [];\n\n        var hostMounts = o.propvals.get('host') || [];\n\t\t\t\n\t\t// Get the host mount info\n        for (var i = 0; i < hostMounts.length; i++) {\n        \tif (hostMounts[i] instanceof vim25.DatastoreHostMount)\n\t\t\t\tthisObj.processDataStoreHostMount(hostMounts[i], o.obj);\t\t\n        }\n\n        var datastoreInfo = dataStore.getInfo();\n        \n        if (datastoreInfo instanceof vim25.VmfsDatastoreInfo) \n            thisObj.processDataStoreHostDisks(datastoreInfo, o.obj);\n\t\t\t\n        thisObj.datastores.push(o.obj);\n        thisObj.processRelationship('vm', o, thisObj.datastoreVmRel, thisObj);\n    },\n\t\n    processCluster: function(cluster, thisObj) {\n        var props = ['name',\n                     'summary.numHosts', \n                     'summary.totalMemory', \n                     'summary.totalCpu',\n                     'summary.numEffectiveHosts',\n                     'summary.numCpuThreads',\n                     'summary.numCpuCores',\n                     'summary.effectiveCpu',\n                     'summary.effectiveMemory',\n                     'parent'];\n        var o = thisObj.processObjectProperties(props, cluster);\n\n        var parent = o.propvals.get('parent');\n        var managedEntity = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), parent);\n        o.obj['parent'] = managedEntity.getMOR().val;\n\n        thisObj.processedClusters[o.obj.morid] = 1;\n\n        thisObj.clusters.push(o.obj);\n    },\n\n    processHostSystem : function(hostSystem, thisObj) {\n        var props = ['summary.hardware.uuid',\n                     'summary.hardware.cpuMhz', \n                     'summary.hardware.model', \n                     'summary.hardware.memorySize', \n\t\t\t\t\t 'summary.hardware.numCpuPkgs', \n                     'summary.hardware.numCpuCores', \n                     'summary.hardware.vendor', \n                     'summary.hardware.cpuModel',\n\t\t\t\t\t 'runtime.inMaintenanceMode',\n                     'hardware.cpuPkg',\n                     'name',\n                     'datastore',\n                     'vm',\n                     'parent'];\n\n        var o = thisObj.processObjectProperties(props, hostSystem),\n        \tobj = o.obj;\n\n        //resolve the host name into an ip address; append to o.obj\n        var hostName = o.propvals.get('name');\n        var ips = new Packages.com.snc.commons.networks.IPHost(hostName).resolveAddress();\n        if (ips.length > 0) {\n        \to.obj.ip = ips[0].toString();\n        }\n\n        // Get the first CPU to determine the manufacturer\n        var cpuPkg = o.propvals.get('hardware.cpuPkg')[0];\n        o.obj['hardware.cpuPkg.vendor'] = cpuPkg.getVendor();\n\n\t\tvar parmValue = (probe.getParameter('vCenter.getSANStorageInfo') || '') + '';\n        // Get the disks on this host\n\t\tif (parmValue == 'true')\n\t\t\tgetMultipathInfo();\n\n\t\t// Get the serial number\n\t\tgetSerialNumber();\n\n        // For the purpose of building resource pool relationships\n        var parent = o.propvals.get('parent');\n        var managedEntity = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), parent);\n        o.obj['parent'] = managedEntity.getMOR().val;\n        thisObj.hostParent[o.obj.morid] = '' + managedEntity.getMOR().val;\n\n        thisObj.processRelationship('datastore', o, thisObj.datastoreHostRel, thisObj);\n        thisObj.processRelationship('vm', o, thisObj.hostVmRel, thisObj);\n        thisObj.processSingleRelationship('parent', o, thisObj.hostClusterRel, thisObj);\n        thisObj.hosts.push(o.obj);\n\n\t\tfunction getSerialNumber() {\n\t\t\tvar sn = { },\n\t\t\t\ttoGet = {\n\t\t\t\t\tConfig: {\n\t\t\t\t\t\tProduct: {\n\t\t\t\t\t\t\tFullName: ''\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHardware: {\n\t\t\t\t\t\tSystemInfo: {\n\t\t\t\t\t\t\tOtherIdentifyingInfo: [{\n\t\t\t\t\t\t\t\tIdentifierType: {\n\t\t\t\t\t\t\t\t\tKey: ''\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tIdentifierValue: ''\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\tgetVCenterObject(hostSystem, sn, toGet);\n\t\t\tobj.sn = JSON.stringify(sn);\n\t\t}\n\n\t\tfunction getMultipathInfo() {\n\t\t\t// Doc: http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.host.StorageDeviceInfo.html\n\t\t\tvar config = hostSystem.getConfig(),\n\t\t\t\tstorageDevice = config.getStorageDevice(),\n\t\t\t\tmpi = { },\n\t\t\t\ttoGet = {\n\t\t\t\t\tScsiLun: [{\t\t\t // The list of SCSI logical units available on the host. \n\t\t\t\t\t\tCanonicalName: '',  // Canonical name of the SCSI logical unit.\n\t\t\t\t\t\t\t\t\t\t\t// Disk partition or extent identifiers refer to this name when referring to a disk.\n\t\t\t\t\t\t\t\t\t\t\t// Use this property to correlate a partition or extent to a specific SCSI disk.\n\t\t\t\t\t\tCapacity: {\n\t\t\t\t\t\t\tBlock: 0,\n\t\t\t\t\t\t\tBlockSize: 0\n\t\t\t\t\t\t},\n\t\t\t\t\t\tUuid: '',\t\t\t// Universally unique identifier for the LUN used to identify ScsiLun across multiple servers.\n\t\t\t\t\t\tDisplayName: '',\n\t\t\t\t\t\tModel: '',\n\t\t\t\t\t\tVendor: ''\n\t\t\t\t\t}],\n\t\t\t\t\t// a storage entity that represents a topological path from a host bus adapter to a SCSI logical unit.\n\t\t\t\t\t// Each path is unique although each host bus adapter/SCSI logical unit pair can have multiple paths.\n\t\t\t\t\tMultipathInfo: {\t\t// The multipath configuration that controls multipath policy for ScsiLuns.\n\t\t\t\t\t\t\t\t\t\t\t// This data object exists only if path information is available and is configurable. \n\t\t\t\t\t\tLun: [ {\t\t\t// List of logical units that can be configured for multipathing. \n\t\t\t\t\t\t\tId: '',\t\t\t// Identifier of LogicalUnit.  Use this id to configure LogicalUnit multipathing policy\n\t\t\t\t\t\t\tKey: '',\t\t\t// Linkable identifier. \n\t\t\t\t\t\t\tLun: '',\t\t\t// SCSI device corresponding to logical unit.\n\t\t\t\t\t\t\tPath: [ {\t\t\t// Array of paths available to access this LogicalUnit. \n\t\t\t\t\t\t\t\tAdapter: '',\t// The host bus adapter at one endpoint of this path. \n\t\t\t\t\t\t\t\tTransport: {\t\t// Transport information for the target end of the path. \n\t\t\t\t\t\t\t\t\tNodeWorldWideName: '',\t// FC: The world wide node name of the target. \n\t\t\t\t\t\t\t\t\tPortWorldWideName: '',\t// FC: The world wide port name of the target. \n\t\t\t\t\t\t\t\t\tIScsiName: ''\t\t\t// iSCSI: The iSCSI name of the target. \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t} ]\n\t\t\t\t\t},\n\t\t\t\t\tHostBusAdapter: [{\t\t // The list of host bus adapters available on the host. \n\t\t\t\t\t\tKey: '',\t\t\t   // The linkable identifier. \n\t\t\t\t\t\tModel: '',\t\t\t // The model name of the host bus adapter. \n\t\t\t\t\t\tIScsiName: '',\t\t\t// ISCSI: The iSCSI name of this host bus adapter.\n\t\t\t\t\t\tConfiguredStaticTarget: [{\t// ISCSI: The configured iSCSI static target entries.\n\t\t\t\t\t\t\tAddress: '',\t\t\t// The IP address or hostname of the storage device.\n\t\t\t\t\t\t\tIScsiName: ''\t\t\t// The iSCSI name of the storage device.\n\t\t\t\t\t\t}],\n\n\t\t\t\t\t\tDevice: '',\t\t\t// The device name of host bus adapter.\n\t\t\t\t\t\tNodeWorldWideName: '',\t// FC: The world wide node name for the adapter. \n\t\t\t\t\t\tPortType: '',\t\t\t // FC: The type of the fiber channel port. \n\t\t\t\t\t\tPortWorldWideName: '',\t// FC: The world wide port name for the adapter. \n\t\t\t\t\t\tSpeed: '',\t\t\t\t// FC: The current operating speed of the adapter in bits per second. \n\t\t\t\t\t\tMaxSpeedMb: '',\t\t\t// ISCSI: The maximum supported link speed of the port in megabits per second.\n\t\t\t\t\t\tIpProperties: {\t\t\t// ISCSI: The IP settings for this host bus adapter. \n\t\t\t\t\t\t\tAddress: '',\t\t\t// The current IPv4 address. \n\t\t\t\t\t\t\tMac: ''\t\t\t\t// The MAC address. \n\t\t\t\t\t\t}\n\t\t\t\t\t}],\n\t\t\t\t},\n\t\t\ttoGetVnic = [ {\n\t\t\t\tDevice: '',\n\t\t\t\tSpec: {\n\t\t\t\t\tExternalId: '',\n\t\t\t\t\tMac: '',\n\t\t\t\t\tIp: {\n\t\t\t\t\t\tDhcp: '',\n\t\t\t\t\t\tIpAddress: '',\n\t\t\t\t\t\tSubnetMask: ''\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ],\n\t\t\ttoGetForNic = {\n\t\t\t\tNetwork: {\n\t\t\t\t\tPnic: [ {\n\t\t\t\t\t\tDevice: '',\n\t\t\t\t\t\tMac: '',\n\t\t\t\t\t\tSpec: {\n\t\t\t\t\t\t\tIp: {\n\t\t\t\t\t\t\t\tDhcp: '',\n\t\t\t\t\t\t\t\tIpAddress: '',\n\t\t\t\t\t\t\t\tSubnetMask: ''\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} ],\n\t\t\t\t\tConsoleVnic: toGetVnic,\n\t\t\t\t\tVnic: toGetVnic\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tgetVCenterObject(storageDevice, mpi, toGet);\n\t\t\tgetVCenterObject(config, mpi, toGetForNic);\n\t\t\t\n\t\t\tobj.mpi = JSON.stringify(mpi);\n\t\t\t\n\t\t}\n\t},\n\n\tprocessDataStoreHostMount : function(hostMount, dataStoreObj) {\n\t\t\n        var hostSystem = new vim25.mo.ManagedEntity(this.serviceInstance.getServerConnection(), hostMount.getKey());\n\t\tvar hostmountinfo = {};\n        hostmountinfo['hostSystemMorId'] = '' + hostSystem.getMOR().val;\n\t\t\n\t\tvar mountInfo = hostMount.getMountInfo();\n\t\thostmountinfo['mountInfo.accessible'] = '' + mountInfo.getAccessible();\n\t\thostmountinfo['mountInfo.accessMode'] = '' + mountInfo.getAccessMode();\n\n        dataStoreObj['datastoreHostMount'].push(hostmountinfo);\n    },\n\n    processDataStoreHostDisks : function(datastoreInfo, dataStoreObj) {\n        dataStoreObj['datastoreDisk'] = []; \n\n        var vmfs = datastoreInfo.getVmfs();\n        var scsiDiskPartitions = vmfs.getExtent();\n\n        for (var i = 0; i < scsiDiskPartitions.length; i++) {\n            var datastoreDiskInfo = {};\n            datastoreDiskInfo['name'] = '' + scsiDiskPartitions[i].getDiskName();\n            dataStoreObj['datastoreDisk'].push(datastoreDiskInfo);\n        }\n    },\n\n    processVirtualMachine : function(virtualMachine, thisObj) {\n        var nic,\n\t\t\tguest = { },\n\t\t\ttoGet = {\n\t\t\t\tguest: {\n\t\t\t\t\tipAddress: 'ipAddress',\n\t\t\t\t\tipStack: [ {\n\t\t\t\t\t\tipRouteConfig: {\n\t\t\t\t\t\t\tipRoute: [ {\n\t\t\t\t\t\t\t\tprefixLength: 'prefixLength',\n\t\t\t\t\t\t\t\tgateway: {\n\t\t\t\t\t\t\t\t\tdevice: 'device',\n\t\t\t\t\t\t\t\t\tipAddress: 'ipAddress'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t}\n\t\t\t\t\t} ],\n\t\t\t\t\tnet: [ {\n\t\t\t\t\t\tmacAddress: 'macAddress',\n\t\t\t\t\t\tdnsConfig: [ { ipAddress: 'ipAddress' } ],\n\t\t\t\t\t\tipConfig: {\n\t\t\t\t\t\t\tdhcp: {\n\t\t\t\t\t\t\t\tipv4: {\n\t\t\t\t\t\t\t\t\tenable: function(value, o) { o.enable = !!value.isEnable(); }\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tipv6: {\n\t\t\t\t\t\t\t\t\tenable: function(value, o) { o.enable = !!value.isEnable(); }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tipAddress: [ {\n\t\t\t\t\t\t\t\tipAddress: 'ipAddress',\n\t\t\t\t\t\t\t\tprefixLength: 'prefixLength'\n\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t}\n\t\t\t\t\t} ]\n\t\t\t\t}\n\t\t\t},\n\t\t\tprops = ['config.hardware.numCPU',\n                     'config.hardware.memoryMB', \n                     'config.uuid',\n\t\t\t\t\t 'config.instanceUuid',\n                     'config.files.vmPathName', \n                     'config.template',\n\t\t\t\t\t 'config.guestId',\n                     'runtime.powerState', \n                     'name', \n                     'config.hardware.device',\n                     'network'];\n\n        var o = thisObj.processObjectProperties(props, virtualMachine);\n        o.obj['runtime.powerState'] = o.propvals.get('runtime.powerState').toString();\n\n        o.obj['virtualDisk'] = [];\n\t\to.obj.virtualMac = [ ];\n\n        thisObj.processRelationship('network', o, thisObj.networkVmRel, thisObj);\n\n        var virtualDevices = o.propvals.get('config.hardware.device') || [];\n\n\t\tgetVCenterObject(virtualMachine, guest, toGet);\n\n\t\t// Get disk info from the devices\n        for (var i = 0; i < virtualDevices.length; i++) {\n            if (virtualDevices[i] instanceof vim25.VirtualDisk)\n                thisObj.processVirtualDisk(virtualDevices[i], o.obj);\n\t\t\telse if (virtualDevices[i] instanceof vim25.VirtualEthernetCard) {\n\t\t\t\tnic = thisObj.extractNic(virtualDevices[i], guest && guest.guest);\n\t\t\t\to.obj.virtualMac.push(nic);\n\t\t\t}\n\t\t}\n\n\t\tthisObj.vmInstances.push(o.obj);\n    },\n\n    processVirtualDisk : function(virtualDisk, virtualMachine) {\n        var virtualDiskObj = {};\n        virtualDiskObj[LABEL] = '' + virtualDisk.getDeviceInfo().getLabel();\n        virtualDiskObj[CAPACITY_KB] = '' + virtualDisk.getCapacityInKB();\n        virtualMachine['virtualDisk'].push(virtualDiskObj);\n\t},\n\n\textractNic: function(device, guest) {\n\t\tvar addresses, address, noPrefix, ipConfig,\n\t\t\tnet = guest && guest.net,\n\t\t\tipStack = guest && ipStack,\n\t\t\tnic = {\n\t\t\t\tmac_address: '' + device.getMacAddress()\n\t\t\t};\n\n\t\t// 1. Find the net device with the mac address\n\t\tnet = net && net.find(\n\t\t\tfunction(net) {\n\t\t\t\treturn '' + net.macAddress == nic.mac_address;\n\t\t\t});\n\n\t\t// 2. If we found it, try to get dns server, ip address, subnet mask & dhcp from it\n\t\tif (net) {\n\t\t\tipConfig = net.ipConfig;\n\n\t\t\t// Just pick the first DNS server...\n\t\t\tnic.dns_server = net.dnsConfig && net.dnsConfig.ipAddress[0];\n\t\t\taddresses = ipConfig && ipConfig.ipAddress;\n\n\t\t\t// Look for an IP V4 address first, then use IP V6\n\t\t\tif (addresses) {\n\t\t\t\tif (!addresses.find(isIpV4))\n\t\t\t\t\taddresses.find(isIpV6);\n\t\t\t}\n\t\t}\n\n\t\t// 3. Look for the gateway, preferring the default gateway\n\t\tif (nic.ip_address && ipStack) {\n\t\t\tif (!ipStack.some(useIpStack)) {\n\t\t\t\tnoPrefix = true;\n\t\t\t\tipStack.some(useIpStack);\n\t\t\t}\n\t\t}\n\n\t\tif (!nic.dns_server)\n\t\t\tdelete nic.dns_server;\n\t\tif (nic.dhcp_enabled === undefined)\n\t\t\tdelete nic.dhcp_enabled;\n\n\t\treturn nic;\n\n\t\tfunction useIpStack(stack) {\n\t\t\tif (stack.ipRouteConfig && stack.ipRouteConfig.ipRoute)\n\t\t\t\treturn stack.ipRouteConfig.ipRoute.some(\n\t\t\t\t\tfunction(route, idx) {\n\t\t\t\t\t\tif ((idx == foundIdx) && (noPrefix || !route.prefixLength) && route.gateway && route.gateway.ipAddress) {\n\t\t\t\t\t\t\tnic.ip_default_gateway = route.gateway.ipAddress;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\n\t\tfunction isIpV4(address, idx) {\n\t\t\tif (address.ipAddress && address.ipAddress.match(v4)) {\n\t\t\t\tfoundIdx = idx;\n\t\t\t\tnic.ip_address = address.ipAddress;\n\t\t\t\tnic.subnet_mask = masks[address.prefixLength];\n\t\t\t\tnic.dhcp_enabled = ipConfig.dhcp && ipConfig.dhcp.ipv4 && ipConfig.dhcp.ipv4.enable;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction isIpV6(address, idx) {\n\t\t\tfoundIdx = idx;\n\t\t\tnic.ip_address = address.ipAddress;\n\t\t\tnic.dhcp_enabled = ipConfig.dhcp && ipConfig.dhcp.ipv6 && ipConfig.dhcp.ipv6.enable;\n\t\t}\n\t},\n\n\tprocessNetwork: function(network, thisObj) {\n        var props = ['name',\n                     'summary.accessible',\n                     'vm',\n                     'host'];\n\n        var o = thisObj.processObjectProperties(props, network);\n\n        if (!thisObj.processedNetworks[o.obj.morid]) {\n            thisObj.processedNetworks[o.obj.morid] = true;\n            thisObj.networks.push(o.obj);\n        }\n\n        thisObj.processRelationship('host', o, thisObj.networkHostRel, thisObj);\n    },\n\n    processRelationship: function(prop, o, relArray, thisObj) {\n        relArray[o.obj.morid] = [];\n\n\n        var objects = o.propvals.get(prop) || [];\n        for (var i = 0; i < objects.length; i++) {\n            var object = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), objects[i]);\n            relArray[o.obj.morid].push(object.getMOR().val);\n        }\n    },\n\n    processRelationshipSubFolder: function(prop, o, relArray, thisObj) {\n        relArray[o.obj.morid] = [];\n\n        var folder = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), o.propvals.get(prop));\n        var props = ['childEntity'];\n\n        var folderObj = thisObj.processObjectProperties(props, folder);\n\t\to.obj[prop] = folderObj.obj.morid;\n        var subfolders = folderObj.propvals.get('childEntity') || [];\n\n        for (var i = 0; i < subfolders.length; i++) {\n            var subfolder = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), subfolders[i]);\t\t\t\n\t\t\t// ignore folders\n\t\t\tif (subfolder && subfolder.getMOR().type.matches(\"Folder\"))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\trelArray[o.obj.morid].push(subfolder.getMOR().val);\n        }\n    },\n\n\n    processSingleRelationship: function(prop, o, relArray, thisObj) {\n        relArray[o.obj.morid] = [];\n        var object = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), o.propvals.get(prop));\n        relArray[o.obj.morid].push(object.getMOR().val);\n    },\n\n    processResourcePool: function(resourcePool, thisObj) {\n        var props = ['name',\n                     'owner',\n                     'parent',\n                     'config.cpuAllocation.limit', \n                     'config.cpuAllocation.reservation', \n                     'config.cpuAllocation.shares.shares', \n                     'config.cpuAllocation.expandableReservation', \n                     'config.memoryAllocation.limit', \n                     'config.memoryAllocation.reservation',\n                     'config.memoryAllocation.shares.shares',\n                     'config.memoryAllocation.expandableReservation'];\n\n        var o = thisObj.processObjectProperties(props, resourcePool);\n\n        var owner = o.propvals.get('owner');\n        var resource = new vim25.mo.ComputeResource(thisObj.serviceInstance.getServerConnection(), owner);\n        o.obj['owner'] = resource.getName();\n        var owner_morid = '' + resource.getMOR().val;\n        o.obj['owner_morid'] = owner_morid;\n\n        var parent = o.propvals.get('parent');\n        var managedEntity = new vim25.mo.ManagedEntity(thisObj.serviceInstance.getServerConnection(), parent);\n        o.obj['parent'] = managedEntity.getMOR().val;\n\n        // Build relationships - weird indirection because the resource pools that are not part of a cluster\n        // aren't owned directly by the host, but the parent of the host\n        if (thisObj.processedClusters[owner_morid]) {\n            thisObj.resourcePoolClusterRel[o.obj.morid] = [];\n            thisObj.resourcePoolClusterRel[o.obj.morid].push(owner_morid);\n        } else {\n            for (var item in thisObj.hostParent)\n                if (owner_morid == thisObj.hostParent[item]) {\n                    thisObj.resourcePoolHostRel[o.obj.morid] = [];\n                    thisObj.resourcePoolHostRel[o.obj.morid].push(item);\n                }\n        }\n\n        thisObj.resourcePools.push(o.obj);\n    },\n\n    processManagedEntities: function(type, processFunc, thisObj) {\n        this.debug('Now processing: ' + type);\n        var rootFolder = this.serviceInstance.getRootFolder();\n        var managedEntities = vim25.mo.InventoryNavigator(rootFolder).searchManagedEntities(type);\n\n        for (var i = 0; i < managedEntities.length; i++)\n            processFunc(managedEntities[i], thisObj);\n    },\n\n    processObjectProperties: function(props, vCenterObject) {\n        var propvals = vCenterObject.getPropertiesByPaths(props);\n        var o = {};\n        var e = propvals.keys();\n\n        while(e.hasMoreElements()) {\n            var key = e.nextElement();\n            var prop = propvals.get(key);\n\n            if (prop instanceof Packages.java.lang.Integer ||\n                prop instanceof Packages.java.lang.Short ||\n                 prop instanceof Packages.java.lang.String ||\n                prop instanceof Packages.java.lang.Long ||\n                prop instanceof Packages.java.lang.Boolean)\n                  o[key] = '' + prop;\n        }\n\n        o['morid'] = '' + vCenterObject.getMOR().val;\n        return {'obj':o, 'propvals':propvals};\n    },\n\n    /**\n     * Writes the XML payload representing the VMWare environment managed by vCenter\n     */\n    generateXMLPayload : function() {\n        this.createOutputRecord = false;\n        this.newResult();\n\n        this.vCenterXmlPayload();\n    },\n\n    vCenterXmlPayload : function() {\n        this.objectXmlPayload('vCenter', this.vCenter, false);\n        this.objectListXmlPayload('datacenter', this.datacenters);\n        this.objectListXmlPayload('folder', this.folders);\n        this.objectListXmlPayload('cluster', this.clusters);\n        this.objectListXmlPayload('hostSystem', this.hosts);\n        this.objectListXmlPayload('dataStore', this.datastores);\n        this.objectListXmlPayload('virtualMachine', this.vmInstances);\n        this.objectListXmlPayload('resourcePool', this.resourcePools);\n        this.objectListXmlPayload('network', this.networks);\n\n        this.relXmlPayload('hostVmRels', 'host', 'vm', this.hostVmRel);\n        this.relXmlPayload('networkVmRels', 'vm', 'network', this.networkVmRel);\n        this.relXmlPayload('networkHostRels', 'network', 'host', this.networkHostRel);\n        this.relXmlPayload('datastoreVmRels', 'datastore', 'vm', this.datastoreVmRel);\n        this.relXmlPayload('datastoreHostRels', 'host', 'datastore', this.datastoreHostRel);\n        this.relXmlPayload('clusterHostRels', 'host', 'cluster', this.hostClusterRel);\n        this.relXmlPayload('resourcePoolClusterRels', 'resourcePool', 'cluster', this.resourcePoolClusterRel);\n        this.relXmlPayload('resourcePoolHostRels', 'resourcePool', 'host', this.resourcePoolHostRel);\n        this.relXmlPayload('folderRels', 'folder', 'folderitem', this.folderRel);\n        this.relXmlPayload('datacenterNetworkRels', 'datacenter', 'network', this.datacenterNetworkRel);\n        this.relXmlPayload('datacenterVmRels', 'datacenter', 'vm', this.datacenterVmRel);\n        this.relXmlPayload('datacenterHostRels', 'datacenter', 'host', this.datacenterHostRel);        \n        this.relXmlPayload('datacenterDatastoreRels', 'datacenter', 'datastore', this.datacenterDatastoreRel);\n\n        this.pop();\n    },\n\n    relXmlPayload: function(relName, type1, type2, rels) {\n        var topElement = this.createElement(relName, '');\n        this.setCurrent(topElement);\n\n        for (var element in rels) {\n            var relElement = this.createElement(type1, '');\n            this.setCurrent(relElement);\n            this.setAttribute(type1 + 'MORid', element);\n\n            var subElement = this.createElement(type2 + 's', '');\n            this.setCurrent(subElement);\n\n            var subItems = rels[element];\n            for (var i = 0; i < subItems .length; i++) {\n                var subElement2 = this.createElement(type2, '');\n                this.setCurrent(subElement2);           \n                this.setAttribute(type2 + 'MORid', subItems[i]);\n                this.pop();\n            }\n\n            this.pop();\n            this.pop();\n        }\n\n        this.pop();\n    },\n\n    objectListXmlPayload: function(elementName, objects) {\n        var elements = this.createElement(elementName + 's', '');\n        this.setCurrent(elements);\n \n        // Handle each object\n        for (var i = 0; i < objects.length; i++)\n            this.objectXmlPayload(elementName, objects[i], true);\n\n        this.pop();\n    },\n\n    objectXmlPayload: function(elementName, object, shouldPop) {\n        var element = this.createElement(elementName, '');\n        this.setCurrent(element);\n\n        for (var name in object) {\n            if (object[name] instanceof Array)\n                this.objectListXmlPayload(name, object[name]);\n            else \n                this.setAttribute(name, object[name]);\n        }\n\n        if (shouldPop)\n            this.pop();\n    },\n\n    type : 'VMWarevCenterProbe',\n});\n\nfunction getVCenterObject(vRoot, jsRoot, templ) {\n\t\n\tvar name, vObj, o, t, i;\n\n\tfor (name in templ) {\n\t\tt = templ[name];\n\t\tif (name == 'PortWorldWideName' || name == 'NodeWorldWideName')\n\t\t\tvObj = getWWNString(vRoot, capitalize(name)) || undefined;\n\t\telse\n\t\t\tvObj = vRoot['get' + capitalize(name)]();\n\n\t\tif (t instanceof Array) {\n\n\t\t\tif (vObj) {\n\t\t\t\tjsRoot[name] = [ ];\n\t\t\t\tfor (i = 0; i < vObj.length; i++) {\n\t\t\t\t\tif (typeof t[0] == 'object') {\n\t\t\t\t\t\to = { };\n\t\t\t\t\t\tjsRoot[name].push(o);\n\t\t\t\t\t\tgetVCenterObject(vObj[i], o, t[0]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tjsRoot.push(vObj[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof t == 'object') {\n\n\t\t\to = { };\n\t\t\tjsRoot[name] = o;\n\t\t\tvObj && getVCenterObject(vObj, o, t);\n\t\t}\n\t\telse if (typeof t == 'function')\n\t\t\tt(vRoot, jsRoot);\n\t\telse\n\t\t\tjsRoot[name] = vObj;\n\t}\n\n\tfunction capitalize(s) { return s[0].toUpperCase() + s.substr(1); }\n}\n\n})();\n\n",
      "sys_id": "95e51ae5c0a8019a75cd1ef52db6bf36"
    },
    {
      "script": "var AVMWareVMProbe = Class.create();\n\nAVMWareVMProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    getVM : function(name) {\n        if (!this.serviceInstance) {\n            var err = \"Not connected to a vCenter instance\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        var rootFolder = this.serviceInstance.getRootFolder();\n        var vm = new vim25.mo.InventoryNavigator(rootFolder).searchManagedEntity(\"VirtualMachine\", name); \n\n        if (!vm) {\n            var err = \"VM \" + name + \" could not be found\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        return vm;\n    },\n\n    getVMByUuid : function(uuid) {\n        if (!this.serviceInstance) {\n            var err = \"Not connected to a vCenter instance\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        var rootFolder = this.serviceInstance.getRootFolder();\n        var vm = null;\n\n        // This portion of code is ported from the VIJava API from the searchManagedEntity that is optimized for searching on name\n        var ocs = this.retrieveObjectContents(rootFolder, [[\"VirtualMachine\", \"config.uuid\",], ]);\n\n        if (ocs && ocs.length > 0) {\n            for (var i = 0; i < ocs.length; i++) {\n                var propSet = ocs[i].getPropSet();\n\t\n                if (propSet && propSet.length > 0) {\n                    var uuidInPropSet = propSet[0].getVal();\n                    if (uuid.equalsIgnoreCase(uuidInPropSet)) {\n                        var mor = ocs[i].getObj();\n                        vm = vim25.mo.util.MorUtil.createExactManagedEntity(rootFolder.getServerConnection(), mor);\n                    }\n                }\n            }\n        }\n\n        if (!vm) {\n            var err = \"VM with uuid \" + uuid + \" could not be found\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        return vm;\n    },\n\t\n\t//retrieve a unique VM based on the VM instanceuuid or the combination of uuid and objectId\n\tgetUniqueVM : function(instanceUuid, uuid, objectId){\n\t\tif (!this.serviceInstance) {\n            var err = \"Not connected to a vCenter instance\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        var rootFolder = this.serviceInstance.getRootFolder();\n        var vm = null;\n\n\t\tvar ocs = this.retrieveObjectContents(rootFolder, [[\"VirtualMachine\", \"config.uuid\", \"config.instanceUuid\"], ]);\t\t\n\n        if (ocs && ocs.length > 0) {\n            for (var i = 0; i < ocs.length; i++) {\n                var propSet = ocs[i].getPropSet();\n\t\n                if (propSet && propSet.length > 0) {\n                    var uuidInPropSet = propSet[1].getVal();\n\t\t\t\t\tvar instanceUuidInPropSet = propSet[0].getVal();\n\t\t\t\t\tif (instanceUuid) {\n\t\t\t\t\t\tif (!instanceUuid.equalsIgnoreCase(instanceUuidInPropSet))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar mor = ocs[i].getObj();\n                        vm = vim25.mo.util.MorUtil.createExactManagedEntity(rootFolder.getServerConnection(), mor);\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\n\t\t\t\t\t}\n                    else if (uuid.equalsIgnoreCase(uuidInPropSet)) {\n                        var mor = ocs[i].getObj();\n                        vm = vim25.mo.util.MorUtil.createExactManagedEntity(rootFolder.getServerConnection(), mor);\n\t\t\t\t\t\tvar morid = vm.getMOR().val;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (objectId && objectId != morid)\n\t\t\t\t\t\t\tvm = null;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n                    }\n                }\n            }\n        }\n\n        if (!vm) {\n            var err = \"VM could not be found. Check VM instanceUuid or CorrelationId and MOR Id\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        return vm;\n\t},\n\n    getUuidsForVMName : function(name) {\n        if (!this.serviceInstance) {\n            var err = \"Not connected to a vCenter instance\";\n            ms.log(err);\n            this.setError(err);\n            return;\n        }\n\n        var rootFolder = this.serviceInstance.getRootFolder();\n        var vm = null;\n\n        // This portion of code is ported from the VIJava API from the searchManagedEntity that is optimized for searching on name, except\n        // now instead of returning when we find the first one, we return the UUID for each VM that has the name\n        var ocs = this.retrieveObjectContents(rootFolder, [[\"VirtualMachine\", \"name\",], ]);\n\n        var uuids = [];\n        if (ocs && ocs.length > 0) {\n\t\t\tvar vmName = this._encodeVMName(name);\n            for (var i = 0; i < ocs.length; i++) {\n                var propSet = ocs[i].getPropSet();\n\t\t\t\tif (propSet.length > 0) {\n                    var nameInPropSet = '' + propSet[0].getVal();\n\t\t\t// vmName is javascript string now. use the javascript function to compare\n                    if (vmName.toUpperCase() == nameInPropSet.toUpperCase()) {\n                        var mor = ocs[i].getObj();\n                        vm = vim25.mo.util.MorUtil.createExactManagedEntity(rootFolder.getServerConnection(), mor);\n                        uuids.push(vm.getConfig().getUuid());\n                    }\n                }\n            }\n        }\n\n        return uuids;\n    },\n\n    handleTask : function(task, action, name) {\n        if (!task.waitForMe().equals(vim25.mo.Task.SUCCESS)) {\n            var err = \"Failed to execute task:\" + action + \", \" + name;\n            ms.log(err);\n            this.setError(err);\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * This code is ported from the VIJava API to help optimize the lookup of a VM by its uuid\n     */\n    retrieveObjectContents : function(rootEntity, typeinfo) {\n        var selectionSpecs = null;\n        if (!typeinfo || typeinfo.length == 0)\n            return null;\n\n        var pc = this.serviceInstance.getPropertyCollector();\n\n        if (!selectionSpecs) {\n            var ai = this.serviceInstance.getAboutInfo();\n            selectionSpecs = ai.apiVersion.startsWith(\"4\") ? vim25.mo.util.PropertyCollectorUtil.buildFullTraversalV4() : vim25.mo.util.PropertyCollectorUtil.buildFullTraversal();\n        }\n\n        var propspecary = vim25.mo.util.PropertyCollectorUtil.buildPropertySpecArray(typeinfo);\t\n\n        var os = new vim25.ObjectSpec();\n        os.setObj(rootEntity.getMOR());\n        os.setSkip(false);\n        os.setSelectSet(selectionSpecs);\n\t\t\n        var spec = new vim25.PropertyFilterSpec();\n        spec.setObjectSet([os]);\n        spec.setPropSet(propspecary);\n\t\t\n        return pc.retrieveProperties([spec]);\n    },\n\t_encodeVMName : function (name){\n\t\tif ( JSUtil.nil(name) )\n\t\t\treturn name;\n\t\t// the vSphere name is partially encoded. By now, the '/', '%' and '\\' are encoded, space and other special chars are still kept.\n\t\t// By using decodeURIComponent and decodeURI method, the 'test w/o confg' just return part after /\n\t\t// They have the different behavior from brwoser. It may be related to javascript version supported in Rhino.\n\t\t// It should be modified after change.\n\t\t\tvar regs = [  \n\t\t\t\t\t    [new RegExp('\\\\%', 'g'), '%25'], // must be the first one\n\t\t\t\t\t\t[new RegExp('\\/', 'g'), '%2f'],\n\t\t\t\t\t\t[new RegExp('\\\\\\\\', 'g'), '%5c']\n\t\t\t\t\t   ];\n\t\t\tvar vmName = ''+name;\n\t\t\tfor(var i=0; i < regs.length; i++)\n\t\t\t\tvmName = vmName.replace(regs[i][0], regs[i][1]);\n\t\t\treturn vmName;\n\t},\n    type : \"AVMWareVMProbe\",\n});",
      "sys_id": "a02fde6f0a0a0beb41f18dad6e9c1a22"
    },
    {
      "script": "var StringPolyfill;\n\nif (!String.prototype.padStart) {\n\t/**\n\t * Pads the current string with another string (multiple times, if needed) until the resulting string reaches the given length. The padding is applied from the start (left) of the current string\n\t * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\n\t */\n\tString.prototype.padStart = function padStart(targetLength, padString) {\n        targetLength = targetLength >> 0; //truncate if number, or convert non-number to 0;\n        padString = String(typeof padString !== 'undefined' ? padString : ' ');\n        if (this.length >= targetLength) {\n            return String(this);\n        } else {\n            targetLength = targetLength - this.length;\n            if (targetLength > padString.length) {\n                padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\n            }\n            return padString.slice(0, targetLength) + String(this);\n        }\n    };\n}",
      "sys_id": "a224819b0f0323001b54fe39b4767e5d"
    },
    {
      "script": "ms.include(\"PostProcessorIncludes\");\n\nvar ProbePostProcessor = Class.create();\nProbePostProcessor.prototype = {\n\n    initialize : function(definition) {\n        \n\t\t// Init logs array\n\t\tthis.logs = [];\n\t\t\n\t\t// Allow to override methods from constructor\n\t\tfor (var property in definition)\n            this[property] = definition[property];\n    \t\n\t\t// Lets run\n\t\tthis.run();\n\t},\n\n    /**\n     * Runs the probe instance\n     */\n    run : function() {   \t\n\t\t// Define global objects for use by subclass \n\t\tcurrent = {};\n\t\trelated_data = {};\n\n\t\t// If WMIRunner probe, convert the xml output to json before processing\n\t\tif (this.getParameter('topic') == 'WMIRunner' && (this.getParameter('output_format') == 'xml' || !this.getParameter('output_format'))) {\n\t\t\tvar xmlHelper = new XMLHelper();\n\t\t\tvar xmlResult = xmlHelper.toObject(output);\t\n\t\t\tif (!JSUtil.nil(xmlResult))\n\t\t\t\toutput = xmlResult;\n\t\t}\n\t\t\n\t\t// Class appropriate subclass postProcess\n    \tthis.process();\n        \n\t\tvar result = {};\n\t\t// If we have any logs, add it to the output\n\t\tif (this.logs.length > 0) {\n\t\t\tresult.logs = this.logs;\n\t\t}\n\t\t\n\t\t// If empty, do not set current\n\t\tif (!JSUtil.isEmpty(current))\n\t\t\tresult.current = current;\n\t\t\n\t\t// If empty, do not set related_data\n\t\tif (!JSUtil.isEmpty(related_data)) \n\t\t\tresult.related_data = related_data;\n\t\t\t\t\n    \t// Compare results with cache and send back json response\n    \tg_probe.setPostProcessOutput(new JSON().encodeObject(result));\n    },\n    \t\n    /**\n\t * Override this method to do the post processing\n\t */\n\tprocess : function() {\n\t},\n    \n\t/**\n\t * Get parameter from the probe payload\n\t */\n    getParameter : function(param) {\n        if (g_probe != null)\n            return g_probe.getParameter(param);\n        else\n            return null;\n    },\n\n\tlog : function(str) {\n\t\tms.log(\"PostProbeProcessor: \" + str);\n\t\tthis.logs.push(str);\n\t},\n\t\n    type: \"ProbePostProcessor\"\n}",
      "sys_id": "a668f2f147412100fc856f2ccee490e8"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n \nvar VMWarevCenterNetworksProbe = Class.create();\n\n(function() {\n\nvar _this,\n\toutput = { },\n\tnetworks = [ ],\n\tdvpgs = [ ],\n\tdvss = [ ];\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterNetworksProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name, output,\n\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\tleftOverMors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\t// Average measured size of a network is 1000 bytes.  Default page size\n\t\t\t// of 500 leaves us well below the 5 MB limit.\n\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 500,\n\t\t\tnetworkMorIds = leftOverMors.splice(0, pageSize),\n\t\t\toriginalData = [ ],\n\t\t\tdatamap = {\n\t\t\t\tNetwork: {\n\t\t\t\t\t'summary.accessible': 'accessible',\n\t\t\t\t\tname: 'name',\n\t\t\t\t\thost: [ { } ],\n\t\t\t\t\tvm: [ { } ]\n\t\t\t\t},\n\t\t\t\tDistributedVirtualPortgroup: {\n\t\t\t\t\tconfig: {\n\t\t\t\t\t\tdistributedVirtualSwitch: { }\n\t\t\t\t\t},\n\t\t\t\t\t'summary.accessible': 'accessible',\n\t\t\t\t\tname: 'name',\n\t\t\t\t\thost: [ { } ],\n\t\t\t\t\tvm: [ { } ]\n\t\t\t\t},\n\t\t\t\tDistributedVirtualSwitch: {\n\t\t\t\t\tname: 'name',\n\t\t\t\t\tportgroup: [ { } ],\n\t\t\t\t\tsummary: {\n\t\t\t\t\t\thostMember: [ { } ],\n\t\t\t\t\t\thost: [ { } ],\n\t\t\t\t\t\tvm: [ { } ]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfixers = {\n\t\t\t\tNetwork: fixNetwork,\n\t\t\t\tDistributedVirtualPortgroup: fixDvpg,\n\t\t\t\tVmwareDistributedVirtualSwitch: fixDvs,\n\t\t\t\tDistributedVirtualSwitch: fixDvs\n\t\t\t};\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\t/*\n\t\tSample data.  Truncated for brevity, so possibly inconsistent:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"type\": \"DistributedVirtualPortgroup\",\n\t\t\t\t\"morid\": \"dvportgroup-28\",\n\t\t\t\t\"accessible\": true,\n\t\t\t\t\"name\": \"DC1_DVPG0\",\n\t\t\t\t\"host\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\t\"morid\": \"host-5624\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\t\"morid\": \"host-7452\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"vm\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\t\"morid\": \"vm-1612\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\t\"morid\": \"vm-9068\"\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"type\": \"VmwareDistributedVirtualSwitch\",\n\t\t\t\t\"morid\": \"dvs-23\",\n\t\t\t\t\"name\": \"DC1_DVS\"\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of networks we're going to explore\n\t\tnetworkMorIds.forEach(\n\t\t\tfunction(network) {\n\t\t\t\ttry {\n\t\t\t\t\t// Create a managed object for the current network, fetch data for it\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.Network.html\n\t\t\t\t\tvar networkConnectionObj,\n\t\t\t\t\t\tnetworkType = network.type,\n\t\t\t\t\t\tmor = new vim25.ManagedObjectReference();\n\n\t\t\t\t\tmor.setType(networkType);\n\t\t\t\t\tmor.setVal(network.morid);\n\t\t\t\t\tnetworkConnectionObj = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\tnetwork = _this.getPropsForUnknownType(networkConnectionObj, datamap);\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(network));\n\n\t\t\t\t\t// Fixup the data.\n\t\t\t\t\tfixers[networkType] && fixers[networkType](network, networkConnectionObj);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing ' + network.type + ' ' + network.morid + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\toutput = {\n\t\t\tcmdb_ci_vcenter_network: networks,\n\t\t\tcmdb_ci_vcenter_dv_port_group: dvpgs,\n\t\t\tcmdb_ci_vcenter_dvs: dvss\n\t\t};\n\t\n\t\t// We fetched at most pageSize networks.  Send back the IDs of remaining networks so the\n\t\t// sensor can fire another probe.\n\t\tif (leftOverMors.length)\n\t\t\toutput.leftOverMors = leftOverMors;\n\n\t\tif (debug)\n\t\t\toutput.originalData = originalData.map(JSON.parse);\n\n\t\tthis.output = JSON.stringify(output, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterNetworksProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixNetwork(network) {\n\textractMORs(network.host);\n\textractMORs(network.vm);\n\n\tnetwork.cmdb_ci_esx_server = network.host;\n\tdelete network.host;\n\n\tnetworks.push(network);\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixDvpg(dvpg, networkConnectionObj) {\n\textractMORs(dvpg.host);\n\textractMORs(dvpg.vm);\n\n\tdvpg.cmdb_ci_esx_server = dvpg.host;\n\tdelete dvpg.host;\n\n\tdvpg.dvs_ref = dvpg.config.distributedVirtualSwitch.morid;\n\tdelete dvpg.config;\n\n\tvar vlanInfo = getVLANInformation(dvpg, networkConnectionObj);\t\n\tif (vlanInfo.hasOwnProperty('pvlanId')) {\n\t\t// Prive VLAN information\n\t\tdvpg.vlan_type = 'private_vlan';\n\t\tdvpg.private_vlan_id = vlanInfo.pvlanId;\n\t} else if (vlanInfo.hasOwnProperty('vlanId')) {\n\t\tif (typeof vlanInfo.vlanId == 'number') {\n\t\t\t// VLAN information\n\t\t\tdvpg.vlan_type = 'vlan';\n\t\t\tdvpg.vlan_id = vlanInfo.vlanId;\n\t\t} else if ((vlanInfo.vlanId instanceof Array) && (vlanInfo.vlanId.length > 0)) {\n\t\t\t// VLAN trunking information\n\t\t\tdvpg.vlan_type = 'vlan_trunking';\n\t\t\tdvpg.vlan_trunk_start_range = vlanInfo.vlanId[0].startRange;\n\t\t\tdvpg.vlan_trunk_end_range = vlanInfo.vlanId[0].endRange;\n\t\t}\n\t}\n\n\tdvpgs.push(dvpg);\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixDvs(dvs) {\n\textractMORs(dvs.summary.host);\n\textractMORs(dvs.summary.hostMember);\n\textractMORs(dvs.summary.vm);\n\textractMORs(dvs.portgroup);\n\n\tdvs.cmdb_ci_esx_server = dvs.summary.host.concat(dvs.summary.hostMember);\n\tdvs.vm = dvs.summary.vm;\n\n\tdvs.host_count = dvs.cmdb_ci_esx_server.length;\n\tdvs.vm_count = dvs.vm.length;\n\n\tdelete dvs.summary;\n\n\tdvss.push(dvs);\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction extractMORs(a) {\n\ta.forEach(function(o, idx) { a[idx] = o.morid; });\n}\n\n/*\n* The VLAN information for the \"DistributedVirtualPortgroup\". There are 3 different VLAN types\n* 1. Private VLAN\n* 2. VLAN trunking\n* 3. VLAN\n* \n* Below we try to use different datamap for getting individual VLAN detail as their response\n* varies with VLAN type\n*\n* INPUT: \n*       dvpg - A distributed virtual port group's data object\n*       dvpgConnection - vCenter Connection object that we trying to reuse\n*\n* OUTPUT:\n*       A map containing output according to the VLAN type i.e., and nothing if no VLAN ID is used\n*\n* If it's a Private VLAN\t:\t{ \"pvlanId\":15 }\n* If it's a VLAN trunking\t:\t{ \"vlanId\":[ {\"endRange\":4094,\"startRange\":0} ] }\n* If it's a VLAN\t\t\t:\t{ \"vlanId\":10 }\n**/\t\n//////////////////////////////////////////////////////////////////////////\nfunction getVLANInformation(dvpg, dvpgConnectionObj) {\n\tvar vlan, dvpgVLANInfo,\n\t\tdvpgDatamap = {\n\t\t\t\tDistributedVirtualPortgroup: {\n\t\t\t\t\tconfig: {\n\t\t\t\t\t\tdefaultPortConfig: {\n\t\t\t\t\t\t\tvlan: { vlanId: 'vlanId', pvlanId: 'pvlanId' }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t// Resets the previous vlan configuration if exists in CMDB for the current CI\n\tdvpg.vlan_type = dvpg.vlan_id = dvpg.vlan_trunk_start_range = dvpg.vlan_trunk_end_range = dvpg.private_vlan_id = '',\n\t\n\tdvpgVLANInfo = _this.getPropsForUnknownType(dvpgConnectionObj, dvpgDatamap);\n\tvlan = dvpgVLANInfo.config.defaultPortConfig.vlan;\n\n\tif (vlan.hasOwnProperty('vlanId') && typeof vlan.vlanId != 'number') {\n\t\tdvpgDatamap.DistributedVirtualPortgroup.config.defaultPortConfig.vlan.vlanId = [ { start: 'startRange', end: 'endRange' } ];\n\t\tdvpgVLANInfo = _this.getPropsForUnknownType(dvpgConnectionObj, dvpgDatamap);\n\t}\n\t\n\treturn dvpgVLANInfo.config.defaultPortConfig.vlan;\n}\n\n})();",
      "sys_id": "ad8fb4ef93c31200c2fe705bb47ffb2f"
    },
    {
      "script": "// Discovery class\n\n/**\n * Parses output of the following command:\n *     lsof -i4TCP -n -P -F pcnfT\n * \n * author tom.dilatush@service-now.com\n */\nvar LSOFParser = Class.create();\n\nLSOFParser.prototype = {\n    /**\n     * Parse the given lsof output.  Results are in tcp[], each element of which is an object with the following fields:\n     *   pid: process ID\n     *   type: \"on\" or \"to\" for listening on or connecting to, respectively\n     *   ip: the IP address we're listening on or connecting to (depending on type)\n     *   port: the port we're listening on or connecting to (depending on type)\n     *   local_ip: the local IP address we're connecting from (undefined if listening on)\n     *   local_port: the local port we're connecting from (undefined if listening on)\n     *   \n     *   Errors are recorded in the error string if the isValid is false.\n     */\n    parse: function(output) {\n        this.initProcess();\n        this.errorString = '';\n        this.tcp = [];\n        this.isValid = true;\n        var lines = output.trim().split('\\n');\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            if (JSUtil.nil(line)) {\n                if (i != lines.length - 1)\n                    this.error('Empty line in lsof output, line: ' + (i + 1));\n                continue;\n            }\n\t\t\t\n            var prefix = line.substring(0, 1);\n            var eventHandler = 'on_' + prefix;\n            if (this[eventHandler])\n                this[eventHandler](line.substring(1));\n            else\n                this.error('Bad line in lsof output, line '+(i+1)+':\\n'+line);\n        }\n        this.on_endProcess();\n    },\n\n    on_p: function(line) {\n        var pid = new Number(line);\n        if (isNaN(pid)) {\n            this.error('Invalid PID: ' + line);\n            return;\n        }\n        this.on_endProcess();\n        this.currentPID = ''+pid;\n    },\n\n    on_c: function(line) {\n        if (JSUtil.nil(line)) {\n            this.error('Empty command');\n            return;\n        }\n        this.currentCmd = line;\n    },\n\n    on_f: function(line) {\n\t\tvar fd = new Number(line);\n\t\t//if there's more than 10000 file descriptors, lsof replaces higher digits with \"*\"\n\t\tif(line[0] == \"*\") {\n\t\t\tif(!this.lastPrefix)\n\t\t\t\tthis.lastPrefix = 10;\n\t\t\t\n\t\t\tif(this.lastSuffix == '999')\n\t\t\t\tthis.lastPrefix++;\n\t\t\t\n\t\t\tthis.lastSuffix = line.substring(1);\n\t\t\tfd = new Number(''+this.lastPrefix+this.lastSuffix);\n\t\t}\n        \n        if (isNaN(fd)) {\n            this.error('Invalid file descriptor: ' + line);\n            return;\n        }\n        this.on_endFileDescriptor();\n        this.currentFD = line;\n    },\n\n    on_n: function(line) {\n        this.currentAddress = line;\n    },\n\n    on_T: function(line) {\n        var parts = line.split('ST=');\n        if ((parts.length != 2) || (parts[0] != ''))\n            return;\n\n        this.currentState = parts[1];\n    },\n\n    on_endFileDescriptor: function() {\n        if (!this.currentFD)\n            return;\n\n\t\t//Sometimes we get entries like this. The connection is closed. Skip it.\n\t\t//n*:*\n\t\t//TST=CLOSED\t\t\n\t\tif (this.currentState == 'CLOSED')\n\t\t\treturn;\n\t\t\n        var isListening = (this.currentState == 'LISTEN');\n        if (!this.currentPID) {\n            this.error('Missing PID on file descriptor ' + this.currentFD);\n            return;\n        }\n        if (!this.currentAddress) {\n            this.error('Missing address on PID ' + this.currentPID + ', file descriptor ' + this.currentFD);\n            return;\n        }\n        \n        // parse the connection data to get the bits we want...\n        var result = {};\n        result.type = isListening ? 'on' : 'to';\n        result.pid = this.currentPID;\n        var parsedIP = null;\n        var parsedLocalIP = null;\n        if (isListening)\n            parsedIP = this.parse_connection(this.currentAddress);\n        else {\n            var parts = this.currentAddress.split('->');\n            parsedIP = this.parse_connection(parts[1]);\n            parsedLocalIP = this.parse_connection(parts[0]);\n\t\t\t//Need to properly parse both sides for a valid connection\n\t\t\tif(parsedIP == null || parsedLocalIP == null)\n\t\t\t\treturn;\n        }\n        if (parsedIP == null) {\n            this.error('Connection address and port is not parseable: ' + this.currentAddress);\n            return;\n        }\n\n        result.ip = parsedIP.ip;\n        result.port = ''+parsedIP.port;\n        if (parsedLocalIP != null) {\n            result.local_ip = parsedLocalIP.ip;\n            result.local_port = parsedLocalIP.port;\n        }\n        \n        this.tcp.push(result);\n        \n        this.initFileDescriptor();\n    },\n    \n    /**\n     * Returns an object with an ip and port fields, which are parsed from the given string.  If the \n     * IP addresss section of the given string is not a valid IP address, it is replaced with 0.0.0.0.\n     * Returns null on any parsing error.\n     */\n    parse_connection: function(str) {\n        if (!str)\n            return null;\n        \n        var result = {};\n\t\tif(str.indexOf('[') < 0) { // not an IPv6 address\n\t\t\tvar parts = str.split(':');\n\t\t\tif (parts.length != 2)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tresult.port = Number(parts[1]);\n\t\t\tif (isNaN(result.port))\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tresult.ip = parts[0];\n\t\t\tif (parts[0] == '*' || !SncIPAddressV4.getIPAddressV4Instance(parts[0]))\n\t\t\t\tresult.ip = '0.0.0.0';\n\t\t}\n\t\telse { //tis IPv6\n\t\t\tvar parts = /\\[([^\\]]+)\\]:([0-9]+)/.exec(str);\n\t\t\tif(!parts || parts.length != 3)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tresult.port = Number(parts[2]);\n\t\t\tif (isNaN(result.port))\n\t\t\t\treturn null;\n\t\t\tresult.ip = parts[1];\n\t\t}\n        return result;\n    },\n\n    on_endProcess: function() {\n        if (!this.currentPID)\n            return;\n\n        this.on_endFileDescriptor();\n        this.initProcess();\n    },\n\n    initProcess: function() {\n        this.currentPID = null;\n        this.currentCmd = null;\n        this.initFileDescriptor();\n    },\n\n    initFileDescriptor: function() {\n        this.currentFD = null;\n        this.currentAddress = null;\n        this.currentState = null;\n    },\n\n    error: function(msg) {\n        this.isValid = false;\n        if (!JSUtil.nil(this.errorString))\n            this.errorString += '\\n';\n        this.errorString += msg;\n    },\n\n    type: \"LSOFParser\"\n}",
      "sys_id": "adb836e79f21210054679ff3367fcf13"
    },
    {
      "script": "var F5SshTerminalProbe = Class.create();\n\n\nF5SshTerminalProbe.prototype = Object.extendsObject(SSHTerminalCommand, {\n    \n   \n    WELL_KNOWN_PROTOCOL_PORT: {\n        'ftp': '21',\n        'http': '80',\n        'https': '443',\n        'telnet': '23',\n        'pptp': '1723',\n        'smtp': '25',\n        'snmp': '161',\n        'snmp-trap': '162',\n        'ms sql': '1443',\n        'submission' : '587',\n        'ldaps' : '389'\n    },\n\n    /*\n    This is the Override function in order to provice cpecific implementation for Cisco. \n    */\n    runCommands: function (cliCommands) {\n\n        this.cliShell = 'tmsh';\n\n        this.vipList = [];\n        \n        for(var aIndex in cliCommands){\n            var cliCommand = cliCommands[aIndex];\n            ms.log('running command ' + cliCommand);\n            \n            this.__runCliCommand(cliCommand);\n\n        }\n        if (this.vipList.length > 0) {\n            this.f5XmlPayload();\n        }\n       \n    },\n\n    __runCliCommand: function (cliCommand) {\n        if (cliCommand) {\n            switch (String(cliCommand).trim()) {\n                case 'list ltm virtual recursive':\n                    this.getF5Vips(cliCommand);\n                break;\n                default:\n                    ms.log(\"Unsupported cli command \" + cliCommand);\n                break;\n                \n            }\n        }\n\n    },\n\n     getF5Vips: function (cliCommand) {\n        var commandSyntax = 'tmsh ' + cliCommand;\n        var cmdResult = this.commandExecutor.execCommand(commandSyntax);\n        ms.log('command result is: ' + cmdResult);\n            \n        if(typeof cmdResult === null){\n            cmdResult = 'empty';\n        }\n\n        var lines = cmdResult.split(\"\\n\");\n\n        var vipName;\n        var vipIp;\n        var vipPort;\n        var vipPool;\n        var isPoolExist = false;\n\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            line = line.trim();\n            if (line) {\n                line = line.replace(\"\\\"\", \"\"); \n                var lineParts = String(line).split(new RegExp(\"\\\\s+\"));\n                if (line.match(/ltm virtual/)) {\n                    isPoolExist=false;\n                    if (lineParts.length >=2){\n                    \tvipName=lineParts[2].trim();\n                    }\n                    else{\n                    \tms.log('problem with VIP name parsing');\n                    }\n                }\n                else if (line.match(/destination/)) {\n                \tif (lineParts.length >=1){\n                    \tvar ipAndPort = lineParts[1].trim()\n                    \tvar parts = ipAndPort.split(\":\");\n                    \tvipIp = parts[0].split(\"%\")[0];\n\n                    \tvar portValue = parts[1].trim();\n                     \tif (typeof this.WELL_KNOWN_PROTOCOL_PORT[portValue] !== 'undefined') {\n                        \tvipPort = this.WELL_KNOWN_PROTOCOL_PORT[portValue];\n                    \t} else {\n                        \tvipPort = portValue;\n                    \t}\n                    }\n                    else{\n                    \tms.log('problem with IP parsing');\n                    }\n               }\n               else if (line.match(/^\\/pool/)) {     \n                    isPoolExist=true;\n                    if (lineParts.length >=1){\n\t                    vipPool = lineParts[1];\n\t                   \n\t                    var entry = {\n\t                        name: vipName,\n\t                        ip: vipIp,\n\t                        port: vipPort,\n\t                        pool: vipPool\n\t                    };\n\t                    this.vipList.push(entry); \n                    }\n                    else{\n                    \tms.log('problem with pool parsing');\n                    }\n              } \n              else if (line.match(/vs-index/) && !isPoolExist){\n                    if (lineParts.length >=1){\n\t                    vipPool = lineParts[1];\n\t                   \n\t                    var entry = {\n\t                        name: vipName,\n\t                        ip: vipIp,\n\t                        port: vipPort,\n\t                        pool: \"\"\n\t                    };\n\t                    this.vipList.push(entry);   \n                    }\n                    else{\n                    \tms.log('problem with pool parsing');\n                    }         \n                }\n            }\n        }\n     },\n\n     \n     f5XmlPayload: function () {\n        this.newResult();\n        this.objectXmlPayload('device', null, false);\n        this.objectListXmlPayload('vip', this.vipList);\n        this.pop();\n    },\n\n    objectListXmlPayload: function (elementName, objects) {\n        var elements = this.createElement(elementName + 's', '');\n        this.setCurrent(elements);\n\n        // Handle each object\n        for (var i = 0; i < objects.length; i++)\n            this.objectXmlPayload(elementName, objects[i], true);\n\n        this.pop();\n    },\n\n    objectXmlPayload: function (elementName, object, shouldPop) {\n        var element = this.createElement(elementName, '');\n        this.setCurrent(element);\n\n        for (var name in object) {\n            if (object[name] instanceof Array)\n                this.objectListXmlPayload(name, object[name]);\n            else\n                this.setAttribute(name, object[name]);\n        }\n\n        if (shouldPop)\n            this.pop();\n    },\n\n\n    type: \"F5SshTerminalProbe\"\n});",
      "sys_id": "b21ebd109f02020003f3b0aec32e709a"
    },
    {
      "script": "ms.include(\"PrototypeServer\");\nms.include(\"String\");",
      "sys_id": "bb6e3cd3c0a8020100823824cbacec99"
    },
    {
      "script": "var Class = {\r\n  create: function() {\r\n    return function() {\r\n      this.initialize.apply(this, arguments);\r\n    }\r\n  }\r\n}\r\n\r\nObject.extend = function(destination, source) {\r\n  for (property in source) {\r\n    destination[property] = source[property];\r\n  }\r\n  return destination;\r\n}\r\n\r\nObject.extendsObject = function(destination, source) {\r\n  destination = Object.clone(destination.prototype);\r\n  \r\n  for (property in source) {\r\n    destination[property] = source[property];\r\n  }\r\n  return destination;\r\n}\r\n\r\nObject.clone = function(obj) {\r\n  var clone = Class.create();\r\n\t\r\n  for (property in obj) {\r\n    clone[property] = obj[property];\r\n  }\r\n\t\r\n  return clone;\r\n}",
      "sys_id": "bb6f9cf6c0a8020100ba345c60be2383"
    },
    {
      "script": "var WindowsInstalledSoftware = Class.create();\n\nWindowsInstalledSoftware.prototype = {\n\tprocess : function(output, related_data) {\n\t\trelated_data.packages = [];\n\n\t\tvar jsonPayload = JSON.parse(output);\n\t\t// Using hash to make sure we get no dups (by name + version).\n\t\tvar softwareList = this.getAllPackages(jsonPayload, related_data);\n\n\t\tfor (var sw in softwareList){\n\t\t\t// Special case for OS IDs\n\t\t\tif (sw === \"osId:prodId:dProdId\")\n\t\t\t\trelated_data.osPackage = softwareList[sw];\n\t\t\telse\n\t\t\t\trelated_data.packages.push(softwareList[sw]);\n\t\t}\n\n\t\trelated_data.caption = jsonPayload.wmi.Win32_OperatingSystem.Caption;\n\t\trelated_data.osVersion = jsonPayload.wmi.Win32_OperatingSystem.Version;\n\t},\n\n\tgetAllPackages: function(payload, related_data) {\n\t\tvar registryKeys = payload.registry;\n\t\tvar softwareList = {};\n\t\tvar productIds = {};\n\t\tvar officeLicenses = {};\n\n\t\tfor(var reg in registryKeys) {\n\t\t\tvar pkg = registryKeys[reg];\n\t\t\tvar pkgPath = pkg.Path;\n\n\t\t\tif (pkgPath.includes(\"\\\\Package_\")){\n\t\t\t\t// Need to process hotfixes\n\t\t\t\tvar kb = this.parseInstalledKBs(pkg);\n\n\t\t\t\tif (kb)\n\t\t\t\t\tsoftwareList[kb.key] = kb;\n\t\t\t}\n\t\t\telse if (pkgPath.includes(\"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Internet Explorer\")){\n\t\t\t\t// Need to process IE details\n\t\t\t\tvar iePackage = this.parseIEDetails(pkg);\n\n\t\t\t\tif (!JSUtil.nil(iePackage))\n\t\t\t\t\tsoftwareList[\"iePackage\"] = iePackage;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (pkgPath.includes(\"Adobe Acrobat\") && pkgPath.includes(\"AVEntitlement\")) {\n\t\t\t\trelated_data.adobe_acrobat_edition = this.getValueFromPackage(pkg, \"iEntitlementLevel\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (pkgPath == \"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\" || pkgPath == \"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\"){\n\t\t\t\t\t// Need to process OSIDs\n\n\t\t\t\t\tvar osId = this.parseOSIDs(pkg);\n\n\t\t\t\t\tif (!JSUtil.nil(osId)){\n\t\t\t\t\t\tsoftwareList[\"osId:prodId:dProdId\"] = osId;\n\t\t\t\t\t\t// Only continue if this is OS IDs section - otherwise parse package.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (pkgPath.startsWith(\"HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Office\") || pkgPath.startsWith(\"HKEY_LOCAL_MACHINE\\\\Software\\\\Wow6432Node\\\\Microsoft\\\\Office\")){\n\t\t\t\t\t// This is a Office!\n\n\t\t\t\t\t// Grabs the string after the last slash and removes curly brackets if there are any\n\t\t\t\t\tvar officeUuidRegex = /.*\\\\\\{?(.*?)\\}?$/mgi;\n\n\t\t\t\t\tvar prodId = pkg.ProductId;\n\t\t\t\t\tvar dProdId = pkg.DigitalProductId;\n\t\t\t\t\tvar uuid = pkg.Path;\n\n\t\t\t\t\t// Try and get the UUID from the path\n\t\t\t\t\tvar uuidDetails = officeUuidRegex.exec(pkg.Path);\n\t\t\t\t\tif (uuidDetails && uuidDetails[1])\n\t\t\t\t\t\tuuid = uuidDetails[1];\n\n\t\t\t\t\tofficeLicenses[uuid] = {};\n\t\t\t\t\tofficeLicenses[uuid].productid = prodId;\n\t\t\t\t\tofficeLicenses[uuid].digitalproductid = dProdId;\n\t\t\t\t}\n\n\t\t\t\tvar softwareItem = this.parseSoftwareAndProduct(pkg, related_data);\n\t\t\t\tif (!JSUtil.nil(softwareItem)){\n\t\t\t\t\tif (JSUtil.nil(softwareList[softwareItem.uniqueName]) || softwareList[softwareItem.uniqueName] == null || softwareList[softwareItem.uniqueName] == undefined)\n\t\t\t\t\t\tsoftwareList[softwareItem.uniqueName] = softwareItem;\n\t\t\t\t\telse\n\t\t\t\t\t\tsoftwareList[softwareItem.uniqueName] = this.mergeJsonObjects(softwareList[softwareItem.uniqueName], softwareItem);\n\n\t\t\t\t\tif (softwareList[softwareItem.uniqueName] != null && !JSUtil.nil(softwareItem.msi_id) && !JSUtil.nil(officeLicenses[softwareItem.msiID]))\n\t\t\t\t\t\tsoftwareList[softwareItem.uniqueName].digital_product_id = officeLicenses[softwareItem.msiID].digitalproductid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Finish processing adobe acrobat if neccesary\n\t\tif (related_data.adobe_acrobat != null) {\n\t\t\t// If we found the edition in registry, apply that instead.\n\t\t\tvar acrobat_pkg = related_data.adobe_acrobat;\n\t\t\tacrobat_pkg = this.setAttributeOnlyIfHasValue(acrobat_pkg, \"edition\", related_data.adobe_acrobat_edition);\n\t\t\t\n\t\t\t// Merge/Re-Add to payload as neccessary\n\t\t\tif (!softwareList[acrobat_pkg.uniqueName])\n\t\t\t\tsoftwareList[acrobat_pkg.uniqueName] = related_data.adobe_acrobat;\n\t\t\telse\n\t\t\t\tsoftwareList[acrobat_pkg.uniqueName] = this.mergeJsonObjects(softwareList[acrobat_pkg.uniqueName], acrobat_pkg);\n\t\t\t\n\t\t\t// cleanup related_data of the unneeded adobe properties\n\t\t\tdelete related_data.adobe_acrobat;\n\t\t\tdelete related_data.adobe_acrobat_edition;\n\t\t}\n\t\treturn softwareList;\n\t},\n\n\tgetValueFromPackage: function(pkg, attribute){\n\t\treturn pkg[attribute] || '';\n\t},\n\n\tparseIEDetails: function (pkg){\n\t\tvar svcVersion = pkg.svcVersion;\n\t\tvar ver = pkg.Version;\n\n\t\tif (JSUtil.nil(svcVersion) && JSUtil.nil(ver))\n\t\t\treturn;\n\n\t\tvar iePackage = {};\n\t\tiePackage.name = \"Internet Explorer\";\n\t\tiePackage.vendor = \"Microsoft\";\n\n\t\t// Version should work for IE 4.0+. svcVersion is new to IE 10. \n\t\tiePackage.version = svcVersion ? svcVersion : ver;\n\n\t\treturn iePackage;\n\t},\n\n\tparseOSIDs: function (pkg){\n\t\tvar prodId = pkg.ProductId;\n\t\tvar dProdId = pkg.DigitalProductId;\n\n\t\tif (!JSUtil.nil(prodId) || !JSUtil.nil(dProdId)){\n\t\t\treturn {\n\t\t\t\tproduct_id: prodId,\n\t\t\t\tdigital_product_id: dProdId\n\t\t\t};\n\t\t}\n\t},\n\n\tparseInstalledKBs: function(pkg){\n\t\tvar kbRegEx = /Package_.*?_(KB\\d+).*?([\\d\\.]*)\\./mgi;\n\t\tvar installName = pkg.InstallName;\n\t\tvar kbDetails;\n\t\tvar kbPrefix = \"Hotfix\";\n\n\t\t// Extract the KB number and Version using regex\n\t\tkbDetails = kbRegEx.exec(installName);\n\t\tif (kbDetails && kbDetails[1]){\n\t\t\tvar kb = {};\n\t\t\tvar key = kbDetails[1];\n\t\t\tkb.name = kbPrefix + \" (\" + key + \")\";\n\t\t\tkb.key = key;\n\t\t\tkb.package_name = key;\n\t\t\tkb.vendor = \"Microsoft Corporation\";\n\t\t\t// Fixed sys_id for Unknown\n\t\t\tkb.manufacturer = \"0e8b8e650a0a0b3b004f285ffbb1a4fc\";\n\t\t\tif (kbDetails[2])\n\t\t\t\tkb.version = kbDetails[2];\n\n\t\t\treturn kb;\n\t\t}\n\n\t\treturn;\n\t},\n\n\tparseSoftwareAndProduct: function(pkg, related_data){\n\t\tvar softwareItem = {};\n\n\t\tvar displayName = this.getValueFromPackage(pkg, \"DisplayName\");\n\t\tvar parentDisplayName = this.getValueFromPackage(pkg, \"ParentDisplayName\");\n\t\tvar displayVersion = this.getValueFromPackage(pkg, \"DisplayVersion\");\n\t\tvar publisher = this.getValueFromPackage(pkg, \"Publisher\");\n\t\tvar uninstallString = this.getValueFromPackage(pkg, \"UninstallString\");\n\t\tvar installDate = this.getValueFromPackage(pkg, \"InstallDate\");\n\t\tvar msiID = this.parseMsiId(uninstallString);\n\t\tvar pid = this.getValueFromPackage(pkg, \"ProductID\");\n\t\tvar installLocation = this.getValueFromPackage(pkg, \"InstallLocation\");\n\t\tvar validPID = true;\n\t\tif (pid == null || pid.length == 0 || pid.toLowerCase() == \"none\")\n\t\t\tvalidPID = false;\n\n\t\tif (JSUtil.nil(displayName) || displayName === \"\")\n\t\t\treturn;\n\n\t\tvar uniqueName = this.getUniqueName(displayName, displayVersion);\n\n\t\tsoftwareItem = {};\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"uniqueName\", uniqueName);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"name\", displayName);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"version\", displayVersion);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"vendor\", publisher);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"part_of\", parentDisplayName);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"uninstall_string\", uninstallString);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"install_date\", installDate);\n\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"install_location\", installLocation);\n\n\t\tif (validPID)\n\t\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"product_id\", pid);\n\n\t\tif (msiID != null && msiID.length > 0 && msiID.toLowerCase() != \"none\" && msiID != \"\")\n\t\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"msi_id\", msiID);\n\t\t\n\t\tif (/Acrobat/.test(displayName) && !JSUtil.nil(uninstallString) && (uninstallString.indexOf(\"{\") >= 0) && (uninstallString.indexOf(\"}\") >= 0)) {\n\t\t\tvar editionString = uninstallString.split(\"{\")[1];\n\t\t\teditionString = editionString.split(\"}\")[0];\n\t\t\tif (!JSUtil.nil(editionString)) {\n\t\t\t\tvar splitEdition = editionString.split(\"-\");\n\t\t\t\tif (splitEdition.length >= 4)\n\t\t\t\t\tsoftwareItem = this.setAttributeOnlyIfHasValue(softwareItem, \"edition\", splitEdition[3]);\n\t\t\t}\n\t\t\trelated_data.adobe_acrobat = softwareItem;\n\t\t\treturn;\n\t\t}\n\n\t\treturn softwareItem;\n\t},\n\n\tgetUniqueName: function(name, version) {\n\t\treturn name + \" \" + version;\n\t},\n\n\tsetAttributeOnlyIfHasValue: function(obj, att, value){\n\t\tif (!JSUtil.nil(value) && value != null && value.length > 0 && value.toLowerCase() != \"none\" && value != \"\")\n\t\t\tobj[att] = value;\n\n\t\treturn obj;\n\t},\n\n\tmergeJsonObjects: function(obj1, obj2){\n\t\tfor (var key in obj2){\n\t\t\tif (!obj1.hasOwnProperty(key) || JSUtil.nil(obj1[key]) || obj1[key] == null || obj1[key].length == 0 || obj1[key].toLowerCase() == \"none\" || obj1[key] == \"\")\n\t\t\t\tobj1[key] = obj2[key];\n\t\t}\n\n\t\treturn obj1;\n\t},\n\n\tparseMsiId: function(str) {\n\t\tvar msiID = \"\";\n\n\t\tif (str && str.toLowerCase().indexOf(\"msiexec\") > -1) {\n\t\t\tvar start = str.indexOf(\"{\");\n\t\t\tvar finalString = str.substring(start+1);\n\t\t\tvar end = finalString.indexOf(\"}\");\n\t\t\tmsiID = finalString.substring(0, end);\n\t\t}\n\n\t\treturn msiID;\n\t},\n\ttype: \"WindowsInstalledSoftware\"\n};",
      "sys_id": "be27e596732300102535b7385ef6a7a5"
    },
    {
      "script": "var RequestAuthTwitterSigner = Class.create();\nRequestAuthTwitterSigner.prototype = {\n    initialize: function() {\n    },\n\ttype: 'RequestAuthTwitterSigner',\n\t\n\tgenerateAuth: function(requestAuthenticator) {\n\t\t//requestAuthenticator object is java class signer\n\t\treturn requestAuthenticator.generateAuthRemotely();\n\t}\n};\n\n",
      "sys_id": "c41709b5531333006626ddeeff7b12fd"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n \nvar VMWarevCenterVMNICsProbe = Class.create();\n\n(function() {\n\nvar _this, includeNics, includeDisks,\n\toutput = { },\n\tvmNics = [ ],\n\tvmWithoutDisks = [ ],\n\tvmDisks = [ ],\n\tv4 = /[0-9]{1,3}(\\.[0-9]{1,3}){3}/,\n\tmasks = [\n\t\t'0.0.0.0',\n\t\t'128.0.0.0',       '192.0.0.0',       '224.0.0.0',       '240.0.0.0',\n\t\t'248.0.0.0',       '252.0.0.0',       '254.0.0.0',       '255.0.0.0',\n\t\t'255.128.0.0',     '255.192.0.0',     '255.224.0.0',     '255.240.0.0',\n\t\t'255.248.0.0',     '255.252.0.0',     '255.254.0.0',     '255.255.0.0',\n\t\t'255.255.128.0',   '255.255.192.0',   '255.255.224.0',   '255.255.240.0',\n\t\t'255.255.248.0',   '255.255.252.0',   '255.255.254.0',   '255.255.255.0',\n\t\t'255.255.255.128', '255.255.255.192', '255.255.255.224', '255.255.255.240',\n\t\t'255.255.255.248', '255.255.255.252', '255.255.255.254', '255.255.255.255' ];\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterVMNICsProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name,\n\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\tvmMorIds = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\toriginalData = [ ],\n\t\t\tdatamap = {\n\t\t\t\tconfig: {\n\t\t\t\t\thardware: {\n\t\t\t\t\t\tdevice: [ {\n\t\t\t\t\t\t\tmacAddress: 'macAddress',\n\t\t\t\t\t\t\tcapacityInBytes: 'size',\n\t\t\t\t\t\t\tkey: 'name',\n\t\t\t\t\t\t\tdiskObjectId: 'volume_id',\n\t\t\t\t\t\t\tdeviceInfo: {\n\t\t\t\t\t\t\t\tlabel: 'label'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbacking: {\n\t\t\t\t\t\t\t\tfileName: 'filename'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} ]\n\t\t\t\t\t},\n\t\t\t\t\ttemplate: function(value, o) { o.template = !!value.isTemplate(); },\n\t\t\t\t},\n\t\t\t\tguest: {\n\t\t\t\t\tipAddress: 'ipAddress',\n\t\t\t\t\tipStack: [ {\n\t\t\t\t\t\tipRouteConfig: {\n\t\t\t\t\t\t\tipRoute: [ {\n\t\t\t\t\t\t\t\tprefixLength: 'prefixLength',\n\t\t\t\t\t\t\t\tgateway: {\n\t\t\t\t\t\t\t\t\tdevice: 'device',\n\t\t\t\t\t\t\t\t\tipAddress: 'ipAddress'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t}\n\t\t\t\t\t} ],\n\t\t\t\t\tnet: [ {\n\t\t\t\t\t\tmacAddress: 'macAddress',\n\t\t\t\t\t\tdnsConfig: [ { ipAddress: 'ipAddress' } ],\n\t\t\t\t\t\tipConfig: {\n\t\t\t\t\t\t\tdhcp: {\n\t\t\t\t\t\t\t\tipv4: {\n\t\t\t\t\t\t\t\t\tenable: function(value, o) { o.enable = !!value.isEnable(); }\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tipv6: {\n\t\t\t\t\t\t\t\t\tenable: function(value, o) { o.enable = !!value.isEnable(); }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tipAddress: [ {\n\t\t\t\t\t\t\t\tipAddress: 'ipAddress',\n\t\t\t\t\t\t\t\tprefixLength: 'prefixLength'\n\t\t\t\t\t\t\t} ]\n\t\t\t\t\t\t}\n\t\t\t\t\t} ]\n\t\t\t\t}\n\t\t\t};\n\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\tdatamap.config.hardware.device._filter = vmFilter;\n\t\tincludeNics = ('' + probe.getParameter('disable_vm_nic_vnics')) != 'true';\n\t\tincludeDisks = ('' + probe.getParameter('disable_vm_nic_vdisks')) != 'true';\n\n\t\t/*\n\t\tSample data.  Truncated for brevity:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"mo\": {\n\t\t\t\t},\n\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\"morid\": \"vm-3184\",\n\t\t\t\t\"config\": {\n\t\t\t\t  \"hardware\": {\n\t\t\t\t\t\"device\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"macAddress\": \"00:50:56:a7:b0:51\",\n\t\t\t\t\t\t\"mo\": {\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  },\n\t\t\t\t  \"template\": false\n\t\t\t\t},\n\t\t\t\t\"guest\": {\n\t\t\t\t  \"ipStack\": [\n\t\t\t\t  ],\n\t\t\t\t  \"net\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"macAddress\": \"00:50:56:a7:b0:51\",\n\t\t\t\t\t  \"dnsConfig\": [\n\t\t\t\t\t  ],\n\t\t\t\t\t  \"ipConfig\": {\n\t\t\t\t\t\t\"ipAddress\": [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\"ipAddress\": \"172.16.7.76\",\n\t\t\t\t\t\t\t\"prefixLength\": 24\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t]\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  ]\n\t\t\t\t}\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"mo\": {\n\t\t\t\t},\n\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\"morid\": \"vm-5494\",\n\t\t\t\t\"config\": {\n\t\t\t\t  \"hardware\": {\n\t\t\t\t\t\"device\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"macAddress\": \"00:50:56:a7:9b:fa\",\n\t\t\t\t\t\t\"mo\": {\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  },\n\t\t\t\t  \"template\": false\n\t\t\t\t},\n\t\t\t\t\"guest\": {\n\t\t\t\t  \"ipStack\": [\n\t\t\t\t  ],\n\t\t\t\t  \"net\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"macAddress\": \"00:50:56:a7:9b:fa\",\n\t\t\t\t\t  \"dnsConfig\": [\n\t\t\t\t\t  ],\n\t\t\t\t\t  \"ipConfig\": {\n\t\t\t\t\t\t\"ipAddress\": [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\"ipAddress\": \"172.16.15.76\",\n\t\t\t\t\t\t\t\"prefixLength\": 24\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t]\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  ]\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of VMs we're going to get NICs for\n\t\tvmMorIds.forEach(\n\t\t\tfunction(vm) {\n\t\t\t\ttry {\n\t\t\t\t\t// Create a managed object for the current VM, fetch data for its NICs\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.VirtualMachine.html\n\t\t\t\t\tvar mor = new vim25.ManagedObjectReference();\n\t\t\t\t\tmor.setType('VirtualMachine');\n\t\t\t\t\tmor.setVal(vm.morid || vm);\n\t\t\t\t\tvm = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\tvm = _this.getPropsForManagedObject(vm, datamap);\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(vm));\n\n\t\t\t\t\t// Fixup the data.\n\t\t\t\t\tfixVM(vm);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing NICs for VirtualMachine ' + vm + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\toutput = {\n\t\t\tcmdb_ci_storage_volume: vmDisks,\n\t\t\tcmdb_ci_vmware_nic: vmNics,\n\t\t\tvm_without_disks : vmWithoutDisks\n\t\t};\n\n\t\tif (debug)\n\t\t\toutput.originalData = originalData.map(JSON.parse);\n\n\t\tthis.output = JSON.stringify(output);\n\t},\n\n\ttype : 'VMWarevCenterVMNICsProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction vmFilter(vcenterObj, obj) {\n\tif ((includeDisks && (vcenterObj instanceof vim25.VirtualDisk)) || (includeNics && (vcenterObj instanceof vim25.VirtualEthernetCard))) {\n\t\tobj.dd = vcenterObj;\n\t\treturn true;\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixVM(vm) {\n\tvar config = vm.config,\n\t\thardware = config.hardware,\n\t\tdevices = hardware.device,\n\t\tcount = 0;\n\n\t// We've already filtered hardware to have only disks & ethernet cards\n\tdevices.forEach(\n\t\tfunction(device) {\n\t\t\tif (device.dd instanceof vim25.VirtualDisk) {\n\t\t\t\tvmDisks.push({\n\t\t\t\t\tcomputer: vm.morid,\n\t\t\t\t\tlabel: device.deviceInfo.label,\n\t\t\t\t\tname: device.name,\n\t\t\t\t\tsize_bytes: device.size,\n\t\t\t\t\tvolume_id: device.volume_id,\n\t\t\t\t\tobject_id: device.backing && device.backing.filename,\n\t\t\t\t\tvdisk_id: vm.morid + '-' + device.name\n\t\t\t\t});\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tvmNics.push(extractNic(device, vm));\n\t\t\t\t/*\n\t\t\t\t// Get the virtual manufacturer\n\t\t\t\tif (dd instanceof vim25.VirtualE1000)\n\t\t\t\t\tvm.card = 'Intel E1000';\n\t\t\t\telse if (dd instanceof vim25.VirtualE1000e)\n\t\t\t\t\tvm.card = 'Intel E1000e';\n\t\t\t\telse if (dd instanceof vim25.VirtualPCNet32)\n\t\t\t\t\tvm.card = 'AMD Lance PCNet32';\n\t\t\t\telse if (ff instanceof vim25.VirtualSriovEthernetCard)\n\t\t\t\t\tvm.card = 'SR-IOV';\n\t\t\t\telse if (ff instanceof vim25.VirtualVmxnet)\n\t\t\t\t\tvm.card = 'VMWare vmx';*/\n\t\t});\n\tif(count == 0)\n\t\tvmWithoutDisks.push(vm.morid);\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction extractNic(device, vm) {\n\tvar addresses, address, noPrefix, ipConfig,\n\t\tguest = vm.guest,\n\t\tnet = guest && guest.net,\n\t\tipStack = guest && ipStack,\n\t\tnic = {\n\t\t\tmac_address: device.macAddress,\n\t\t\tcmdb_ci: vm.morid\n\t\t};\n\n\t// 1. Find the net device with the mac address\n\tnet = net && net.find(\n\t\tfunction(net) {\n\t\t\treturn net.macAddress.toLowerCase() == device.macAddress.toLowerCase();\n\t\t});\n\n\t// 2. If we found it, try to get dns server, ip address, subnet mask & dhcp from it\n\tif (net) {\n\t\tipConfig = net.ipConfig;\n\t\t\n\t\t// Just pick the first DNS server... but make sure there is at least one\n\t\t\t\t// Just pick the first DNS server...\n\t\tif(net.dnsConfig && net.dnsConfig.ipAddress.length > 0)\n\t\t\tnic.dns_server = net.dnsConfig.ipAddress[0];\n\n\t\taddresses = ipConfig && ipConfig.ipAddress;\n\n\t\t// Look for an IP V4 address first, then use IP V6\n\t\tif (addresses) {\n\t\t\tif (!addresses.find(isIpV4))\n\t\t\t\taddresses.find(isIpV6);\n\t\t}\n\t}\n\n\t// 3. Look for the gateway, preferring the default gateway\n\tif (nic.ip_address && ipStack) {\n\t\tif (!ipStack.some(useIpStack)) {\n\t\t\tnoPrefix = true;\n\t\t\tipStack.some(useIpStack);\n\t\t}\n\t}\n\n\treturn nic;\n\n\tfunction useIpStack(stack) {\n\t\tif (stack.ipRouteConfig && stack.ipRouteConfig.ipRoute)\n\t\t\treturn stack.ipRouteConfig.ipRoute.some(\n\t\t\t\tfunction(route, idx) {\n\t\t\t\t\tif ((idx == foundIdx) && (noPrefix || !route.prefixLength) && route.gateway && route.gateway.ipAddress) {\n\t\t\t\t\t\tnic.ip_default_gateway = route.gateway.ipAddress;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\n\tfunction isIpV4(address, idx) {\n\t\tif (address.ipAddress && address.ipAddress.match(v4)) {\n\t\t\tfoundIdx = idx;\n\t\t\tnic.ip_address = address.ipAddress;\n\t\t\tnic.subnet_mask = masks[address.prefixLength];\n\t\t\tnic.dhcp_enabled = ipConfig.dhcp && ipConfig.dhcp.ipv4 && ipConfig.dhcp.ipv4.enable;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tfunction isIpV6(address, idx) {\n\t\tfoundIdx = idx;\n\t\tnic.ip_address = address.ipAddress;\n\t\tnic.dhcp_enabled = ipConfig.dhcp && ipConfig.dhcp.ipv6 && ipConfig.dhcp.ipv6.enable;\n\t}\n}\n\n})();",
      "sys_id": "d24260d48f1c2200c2fe0b5437bdee20"
    },
    {
      "script": "ms.include(\"PostProcessorIncludes\");\n\nvar CiscoAceXmlProbe = Class.create();\n\n/*\n * This is the implementation of Cisco ACE Load Balancer Probe that expect output result form the device in XML format\n * Each cli command are filtered and converted to a specific xml output format in order to prevent large data transfer to the Instance.\n *\n * Supported Cisco Versions:\n *\n * 1. build 3.0(0)A2(3.6a)(3.3)\n * 2. build 3.0(0)A3(2.0)\n * 3. build 3.0(0)A4(2.3) \n * 4. build 3.0(0)A5\n */\nCiscoAceXmlProbe.prototype = Object.extendsObject(SSHTerminalCommand, {\n    /*\n     * This is the map of the supported firmware versions\n     * Based on this map version we are performing different parsing logic due to unsupported backward compatibility\n     */\n    SUPPORTED_VERSIONS: {\n        A2: 'A2',\n        A3: 'A3',\n        A4: 'A4',\n        A5: 'A5'\n    },\n\n    /*\n     * We defined mapping Object in order to translate protocol name to real default port\n     */\n    DEFAULT_PROTOCOL_PORT: {\n        'www': '80',\n        'ftp': '21',\n        'ssh': '22',\n        'smtp': '25',\n        'https': '443 ',\n        'rtsp': '554',\n        'rdp': '3389',\n        'sip': '5060'\n    },\n\n    /*\n    This is the Ovveride function in order to provice cpecific implementation for Cisco. \n    */\n    runCommands: function (ciscoCliCommands) {\n\n        this.deviceVersion = {\n            type: 'Cisco ACE LoadBalancer',\n            version: ''\n        };\n        this.groups = [];\n        this.realServers = [];\n        this.interfaces = [];\n        this.vipList = [];\n        this.ciscoContexts = [];\n        /*In case of port range we need to limit the generation in order to prevent database overloading*/\n        this.vipPortRangeLimit = this.getIntParameter('vip_port_range_limit', 10);\n        /*Customer can change the default limit port reange limit from 10 to other number*/\n        this.__getPortRangeLimit();\n        this.commandExecutor.execCommand(\"xml-show on\");\n        this.deviceVersion.version = this.getCiscoVersion();\n        this.__getCiscoContexts();\n\n        /*\n         * In order to perform full discovery we need to get the configuration from all defined contexts\n         * We perform the set of the defined commands for each context\n         * The configuration output is xml\n         * Since xml is not the default output we turn it to on/off per context\n         */\n        for (var cIndex in this.ciscoContexts) {\n            var ciscoContext = this.ciscoContexts[cIndex];\n            try {\n                this.changeCiscoContext(ciscoContext);\n                this.commandExecutor.execCommand(\"xml-show on\");\n                this.__runCliCommands(ciscoCliCommands);\n                this.commandExecutor.execCommand(\"xml-show off\");\n            } catch (error) {\n                ms.error(\"CiscoAceXmlProbe: failed to change context: \" + error);\n            }\n        }\n        this.commandExecutor.execCommand(\"xml-show off\");\n\n        this.generateXMLPayload();\n\n    },\n\n    /*\n     * This is the parent function that was overwritten in order to perform specific logic for Cisco Ace\n     */\n    __runCliCommands: function (cliCommands) {\n        for (var i in cliCommands) {\n            cli_command = cliCommands[i];\n            if (cli_command) {\n                switch (String(cli_command).trim()) {\n                    case 'show version':\n                        /*\n                          We are using the version command in order to run relevant parse logic for each version\n                          Since we called this function erliar we shoud skip this call.\n                          The case is empty in order to prevent message from default case - Unsupported cli command\n                        */\n                        break;\n                    case 'show interface':\n                        this.getCiscoInterfaces();\n                        break;\n                    case 'show rserver':\n                        this.getCiscoRealServers();\n                        break;\n                    case 'show serverfarm':\n                        this.getCiscoFarms();\n                        break;\n                    case 'show service-policy detail':\n                        this.getCiscoVips();\n                        break;\n                    default:\n                        ms.error(\"Unsupported cli command \" + cli_command);\n                        break;\n                }\n            }\n        }\n\n    },\n\n    getCiscoVersion: function () {\n        var runCommand = 'show version';\n\n        try {\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, true);\n\n            if (jsonObject.xml_show_version.ver_software.hasOwnProperty('ver_system')) {\n                return jsonObject.xml_show_version.ver_software.ver_system;\n            }\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n\n        return \"\";\n    },\n\n    __getCiscoContexts: function () {\n        var runCommand = 'show context';\n        try {\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, true);\n\n            var pathToContext = null;\n\n            if (!this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A2))\n                pathToContext = jsonObject.xml_show_context.ctx_contexts.ctx_context;\n            else\n                pathToContext = jsonObject.xml_show_context.ctx_context;\n\n            if (typeof pathToContext !== 'undefined') {\n                var contexts = pathToContext;\n                if (!(contexts instanceof Array))\n                    contexts = [contexts];\n\n                for (var contextIndex in contexts) {\n                    var ciscoContext = contexts[contextIndex];\n                    this.ciscoContexts.push(ciscoContext['name'].trim());\n                }\n            }\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n    },\n\n    /* \n     * This function changes the context to the provided context Name/User\n     */\n    changeCiscoContext: function (contextName) {\n        var cmdResult = this.commandExecutor.execCommand('changeto ' + contextName);\n        if (cmdResult !== null && cmdResult !== '') {\n            var subStrIndex = cmdResult.indexOf('Error:');\n            if (subStrIndex > -1)\n                throw 'Error: Failed to change context to: ' + contextName + ' contact System Administrator';\n        }\n    },\n\n    /* \n     * This function updates the list of the discovered interfaces for the current load balancer\n     * The parsing knowledge is based on the above Cisco ACE firmware versions\n     * If the version is unknown the default parsing is like A2,A4,A5\n     */\n\n    getCiscoInterfaces: function () {\n\n        var runCommand = 'show interface';\n        try {\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, true);\n            if (!this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A3))\n                this.__getCiscoInterfaces_A2_A4_A5(jsonObject);\n            else\n                this.__getCiscoInterfacesA3(jsonObject);\n\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n    },\n\n    /*\n     * Specific parsing of the interace section for the A2, A4, A5 firmware versions\n     */\n    __getCiscoInterfaces_A2_A4_A5: function (jsonObject) {\n        if (jsonObject && jsonObject.xml_show_interface.hasOwnProperty('xml_interface_entry')) {\n            var ethInterfaces = jsonObject.xml_show_interface.xml_interface_entry;\n            if (!(ethInterfaces instanceof Array))\n                ethInterfaces = [ethInterfaces];\n\n            for (var ethInterfaceIndex in ethInterfaces) {\n                var ethInterface = ethInterfaces[ethInterfaceIndex];\n                var iName = ethInterface.xml_interface['interface_name'].trim();\n                var iStatus = ethInterface.xml_interface['interface_status'].trim();\n                var iMacAddress = ethInterface.xml_interface.interface_mac['macaddress'].trim();\n\n                this.__updateInteracesList(iName, iStatus, iMacAddress);\n            }\n        }\n    },\n\n    /*\n     * Specific parsing of the interace section for the A3 firmware version\n     */\n    __getCiscoInterfacesA3: function (jsonObject) {\n        if (jsonObject && jsonObject.xml_show_interface.hasOwnProperty('xml_interface_eth_entry')) {\n            var ethInterfaces = jsonObject.xml_show_interface.xml_interface_eth_entry;\n            if (!(ethInterfaces instanceof Array))\n                ethInterfaces = [ethInterfaces];\n\n            for (var ethInterfaceIndex in ethInterfaces) {\n                var ethInterface = ethInterfaces[ethInterfaceIndex];\n                var iName = ethInterface.xml_eth_interface['interface_name'].trim();\n                var iStatus = ethInterface.xml_eth_interface['interface_status'].trim();\n                var iMacAddress = ethInterface.xml_eth_interface.interface_eth_info.interface_mac['macaddress'].trim();\n\n                this.__updateInterfacesList(iName, iStatus, iMacAddress);\n            }\n        }\n    },\n\n    __updateInterfacesList: function (iName, iStatus, iMacAddress) {\n        this.interfaces.push({\n            name: iName,\n            status: iStatus,\n            MACAddress: iMacAddress\n        });\n    },\n\n    /* \n     * This function updates the list of groups/farms for the current load balancer\n     */\n    getCiscoFarms: function () {\n        var runCommand = 'show serverfarm';\n\n        try {\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, true);\n            if (jsonObject.xml_show_serverfarm.hasOwnProperty('sf_entry')) {\n                var serverFarms = jsonObject.xml_show_serverfarm.sf_entry;\n                if (!(serverFarms instanceof Array))\n                    serverFarms = [serverFarms];\n\n                for (var farmIndex in serverFarms) {\n                    var serverFarm = serverFarms[farmIndex];\n                    var sName = serverFarm['name'].trim();\n                    var balancingMethod = serverFarm['sf_predictor'].trim();\n\n                    var entry = {\n                        name: sName,\n                        method: balancingMethod\n                    };\n\n                    this.groups.push(entry);\n                }\n            }\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n    },\n\n    /* \n     * This function updates the list of the real servers for the current load balancer\n     */\n    getCiscoRealServers: function () {\n        var runCommand = 'show rserver';\n\n        try {\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, true);\n            if (jsonObject.xml_show_rserver.hasOwnProperty('rs_entry')) {\n                var realServers = jsonObject.xml_show_rserver.rs_entry;\n                if (!(realServers instanceof Array))\n                    realServers = [realServers];\n\n                for (var serverIndex in realServers) {\n\n                    var realServer = realServers[serverIndex];\n                    if (realServer !== null && realServer.hasOwnProperty('rs_entry')) {\n                        var complexServer = realServer.rs_entry;\n                        var sName = realServer['name'].trim();\n                        if (!(realServer.rs_entry instanceof Array))\n                            complexServer = [realServer.rs_entry];\n\n                        for (var currentiIndex in complexServer) {\n                            var currentServer = complexServer[currentiIndex];\n                            var sGroup = currentServer['rs_sfarm'].trim();\n                            var sIp = currentServer['address'].trim();\n                            var sPort = currentServer['rs_port'].trim();\n                            var sState = currentServer['rs_state'].trim();\n\n                            var entry = {\n                                name: sName,\n                                ip: sIp,\n                                port: sPort,\n                                group: sGroup,\n                                state: sState\n                            };\n                            this.realServers.push(entry);\n                        }\n                    }\n\n\n                }\n            }\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n    },\n\n    /* \n     * This function updates the list of the discovered VIP's for the current load balancer\n     * The parsing knowledge is based on the above Cisco ACE firmware versions\n     */\n    getCiscoVips: function () {\n        var runCommand = 'show running-config class-map';\n        var policyMaps = this.__getPolicyMaps();\n        if (!(policyMaps != null && policyMaps.length > 0))\n            return;\n        \n        try {\n            var validateAndFix = true;\n            \n            if (this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A4) || this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A5)) {\n                validateAndFix = false;\n            }\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, validateAndFix);\n            if (jsonObject && jsonObject.xml_show_running_config.hasOwnProperty('class-map')) {\n                var vipServices = jsonObject.xml_show_running_config['class-map'];\n                if (!(vipServices instanceof Array))\n                    vipServices = [vipServices];\n                \n                for (var vipIndex in vipServices) {\n                    var vipService = vipServices[vipIndex];\n                    var vipName = vipService['@name'].trim();\n                    var vipIp = \"\";\n                    var vipPort = '';\n                    var vipState = 'INSERVICE';\n                    var serviceFarm = '';\n                    var portValue = '';\n\n                    if (!vipService.hasOwnProperty('match_virtual-addr'))\n                        continue;\n\n                    var virtualAddresses = vipService['match_virtual-addr'];\n                    if (!(virtualAddresses instanceof Array))\n                        virtualAddresses = [virtualAddresses];\n                        \n                    for (var virtualAddressIndex in virtualAddresses) {\n                        var virtualAddress = virtualAddresses[virtualAddressIndex];\n\n                        vipIp = this.__getVipIpFromVirtualAddress(virtualAddress);\n                        serviceFarm = this.__getGroupNameFromPolicyMapByVipName(policyMaps, vipName);\n\n                        \n                        if (!virtualAddress.hasOwnProperty('@operator'))\n                            continue;\n                            \n                        var isPortRange = (virtualAddress['@operator'].trim() === 'range') ? true : false;\n                        if (isPortRange) {\n                            var portRange = this.__getVipPortRangeFromVirtualAddress(virtualAddress);\n                            if (portRange === null) continue;\n                            for (var currentPort = portRange.startPort; currentPort <= portRange.endPort; currentPort++) {\n                                this.__addToListVipEntry(vipName + '-' + currentPort, vipIp, currentPort, vipState, serviceFarm);\n                            }\n                        } else {\n                            vipPort = this.__getVipPortFromVirtualAddress(virtualAddress);\n                            if (vipPort === null) continue;\n                            this.__addToListVipEntry(vipName, vipIp, vipPort, vipState, serviceFarm);\n\n                        }\n                    }\n                }\n            }\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n    },\n\n\n    __getVipIpFromVirtualAddress: function (virtualAddress) {\n        \n        var ipAddress = '';\n        if (this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A5)) {\n            ipAddress = virtualAddress['@ipv4-address'].trim();\n        } else {\n            ipAddress = virtualAddress['@virtual-address'].trim();\n        }\n       \n        return ipAddress;\n    },\n\n    __getVipPortFromVirtualAddress: function (virtualAddress) {\n        var portValue = '';\n        if (this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A3)) {\n            if (!virtualAddress.hasOwnProperty('@protocol-value'))\n                return null;\n            portValue = virtualAddress['@protocol-value'].trim();\n        } else {\n            if (virtualAddress.hasOwnProperty('@port-tcp-name')) {\n                portValue = virtualAddress['@port-tcp-name'].trim();\n            }\n            if (virtualAddress.hasOwnProperty('@port-udp-name')) {\n                portValue = virtualAddress['@port-udp-name'].trim();\n            }\n\n        }\n        var portNumber = '';\n        if (typeof this.DEFAULT_PROTOCOL_PORT[portValue] !== 'undefined') {\n            portNumber = this.DEFAULT_PROTOCOL_PORT[portValue].trim();\n        } else {\n            portNumber = portValue;\n        }\n        return portNumber;\n    },\n\n    __getVipPortRangeFromVirtualAddress: function (virtualAddress) {\n        var startPort = parseInt(virtualAddress['@port-1'].trim());\n        var endPort = parseInt(virtualAddress['@port-2'].trim());\n\n        if (startPort >= 0 && startPort <= 65535) {\n            if (endPort >= 0 && endPort <= 65535) {\n                if ((endPort < startPort)) {\n                    ms.error(\"Invalid, endPort<startPort range for vip name: \" + vipName + ' port range: [ ' + startPort + ',' + endPort + ' ]');\n                    return null;\n                }\n            } else {\n                ms.error(\"Invalid startPort>endPort range for vip name: \" + vipName + ' port range: [ ' + startPort + ',' + endPort + ' ]');\n                return null;\n            }\n        } else {\n            ms.error(\"Invalid startPort range for vip name: \" + vipName + ' port range: [ ' + startPort + ',' + endPort + ' ]');\n            return null;\n        }\n\n        /* Set port range limit according to the configuration */\n        if ((endPort - startPort) > (this.vipPortRangeLimit - 1)) {\n            endPort = startPort + this.vipPortRangeLimit - 1;\n        }\n\n        var portRange = {\n            startPort: startPort,\n            endPort: endPort\n        };\n\n        return portRange;\n    },\n\n    __getGroupNameFromPolicyMapByVipName: function (policyMaps, vipName) {\n        var groupName = '';\n        for (var mapIndex in policyMaps) {\n            var policyMap = policyMaps[mapIndex];\n            var tmpVipName = '';\n            if ((vipName.length >= 3) && this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A4))\n                tmpVipName = vipName.slice(0, -4);\n\n            if ((policyMap['policy'].indexOf(tmpVipName) > -1))\n                return policyMap['group'];\n            else {\n                if (vipName.length > 3 && vipName.indexOf('vip-') == 0) {\n                    vipName = vipName.slice(4);\n                    if ((policyMap['policy'].indexOf(vipName) > -1))\n                        return policyMap['group'];\n                }\n            }\n        }\n        return groupName;\n    },\n\n    __addToListVipEntry: function (vipName, vipIp, vipPort, vipState, vipGroup) {\n\n        var entry = {\n            name: vipName,\n            ip: vipIp,\n            port: vipPort,\n            state: vipState,\n            group: vipGroup\n        };\n\n        this.vipList.push(entry);\n\n    },\n\n    /* \n     * This function return the List of the discovered Policy per Group/Farm\n     * This information is needed in order identify to which group/farm the VIP is related\n     */\n    __getPolicyMaps: function () {\n        var runCommand = 'show running-config policy-map';\n        var policyMapsList = [];\n        try {\n            var jsonObject = this.__getJsonObjectByCliCommand(runCommand, false);\n\n            if (jsonObject && jsonObject.xml_show_running_config.hasOwnProperty('policy-map_lb')) {\n                var policyMaps = jsonObject.xml_show_running_config['policy-map_lb'];\n                if (!(policyMaps instanceof Array))\n                    policyMaps = [policyMaps];\n\n                for (var policyMapIndex in policyMaps) {\n                    var policyMap = policyMaps[policyMapIndex];\n                    var pName = policyMap['@pmap-name'].trim();\n                    var pFarm = '';\n                    if (this.deviceVersion.version.match(this.SUPPORTED_VERSIONS.A4)){\n                        if (policyMap.class_pmap_lb.hasOwnProperty('sticky-serverfarm') && policyMap.class_pmap_lb['sticky-serverfarm'].hasOwnProperty('@sticky-group')) {\n                            var stickyGroup = policyMap.class_pmap_lb['sticky-serverfarm']['@sticky-group'];\n                            if (stickyGroup.length > 7)\n                                stickyGroup = stickyGroup.slice(0, -7).trim();\n                            pFarm = stickyGroup;\n                        }\n                    }else{\n                        pFarm = policyMap.class_pmap_lb.serverfarm_pmap['@sfarm-name'].trim();\n                    }                           \n\n                    var entry = {\n                        policy: pName,\n                        group: pFarm\n                    };\n\n                    policyMapsList.push(entry);\n                }\n            }\n        } catch (error) {\n            ms.error(\"Failed due to parse command: \" + runCommand + \" output \" + error);\n        }\n        return policyMapsList;\n    },\n\n    /*\n        Run Cisco ACE Cli commads and convert it to Json Object \n        cliCommand: cli command that we are running over SSH Terminal\n        skipResultValidation: Due to invalid XML output in some cases,\n        we are providing posibility to validate the validity of XML before parsing,\n        in order to prevent Exceptions for known issues.\n    */\n    __getJsonObjectByCliCommand: function (cliCommand, skipResultValidation) {\n\n        var isShowRunningConfTagExists = false;\n        if (cliCommand.indexOf(\"running-config\") > -1)\n            isShowRunningConfTagExists = true;\n\n        var cmdResult = this.commandExecutor.execCommand(cliCommand);\n        /*\n        As part of the xml output we are getting non ASCII characters and statements \n        Before parsing the XML output we should clean it from non ASCII chars and not relevant statements\n        */\n\n        cmdResult = String(cmdResult).replace(/[^\\x00-\\x7F]/g, '');\n        cmdResult = String(cmdResult).replace(/undefined/g, '');\n        cmdResult = String(cmdResult).replace(/--More--/, '');\n        cmdResult = String(cmdResult).replace('Generating configuration....', '');\n\n        if (!(skipResultValidation))\n            cmdResult = this.__validateXmlResult(cmdResult);\n\n        // In case xml tag droped down by enter the XML parser is fails.\n        // In order to avoid this situation we are removing all new lines from the xml\n        cmdResult = String(cmdResult).replace(/(\\r\\n|\\n|\\r)/gm, '');\n\n        //In case XML corrupted and this tag is missing we are fixing the XML structure\n        if (isShowRunningConfTagExists)\n            if (cmdResult.indexOf(\"<xml_show_running_config>\") == -1) {\n                cmdResult = \"<xml_show_running_config>\" + cmdResult;\n            }\n\n        var jsonResult = null;\n        try {\n            var xmlHelper = new XMLHelper(\"<xml>\" + cmdResult + \"</xml>\");\n            jsonResult = xmlHelper.toObject();\n\n        } catch (error) {\n            var SAXParseException = Packages.org.xml.sax.SAXParseException;\n            if (error instanceof SAXParseException) {\n                ms.error(\"Trying to fix XML\");\n                ms.error(\"The column number is: \" + error.getColumnNumber());\n                ms.error(\"The line number is: \" + error.getLineNumber());\n                ms.error(\"The Public Id is: \" + error.getPublicId());\n                ms.error(\"The System Id is: \" + error.getLineNumber());\n            } else\n                ms.error(\"Failed due to parse command: \" + cliCommand + \" output \" + error);\n\n        }\n\n        return jsonResult;\n\n    },\n\n    /* \n        Due to invalid XML result for command we are fixing XML before parsing\n        Missing last tag </policy-map_lb>\n    */\n    __validateXmlResult: function (xmlCliResult) {\n        var fixedXmlOutput = \"\";\n\n        var xmlRows = xmlCliResult.split('\\n');\n        for (var rowIndex = 0; rowIndex < xmlRows.length; rowIndex++) {\n            var xmlRow = xmlRows[rowIndex];\n            fixedXmlOutput = fixedXmlOutput + xmlRow + '\\n';\n            if (xmlRow.match('\\<\\/class_pmap_lb\\>')) {\n                if (!(xmlRows[rowIndex + 1].match('\\<\\/policy\\-map_lb\\>'))) {\n                    fixedXmlOutput = fixedXmlOutput + '</policy-map_lb>\\n';\n                    rowIndex++;\n                }\n            }\n        }\n        return fixedXmlOutput;\n    },\n\n    /**\n     * Writes the XML payload representing the Cisco load balancer environment configuration\n     * The existing Probe api is used\n     */\n    generateXMLPayload: function () {\n        this.createOutputRecord = false;\n        this.newResult();\n        this.ciscoXmlPayload();\n    },\n\n    ciscoXmlPayload: function () {\n        this.objectXmlPayload('device', this.deviceVersion, false);\n        this.objectListXmlPayload('group', this.groups);\n        this.objectListXmlPayload('server', this.realServers);\n        this.objectListXmlPayload('interface', this.interfaces);\n        this.objectListXmlPayload('vip', this.vipList);\n        this.pop();\n    },\n\n    objectListXmlPayload: function (elementName, objects) {\n        var elements = this.createElement(elementName + 's', '');\n        this.setCurrent(elements);\n\n        // Handle each object\n        for (var i = 0; i < objects.length; i++)\n            this.objectXmlPayload(elementName, objects[i], true);\n\n        this.pop();\n    },\n\n    objectXmlPayload: function (elementName, object, shouldPop) {\n        try {\n            var element = this.createElement(elementName, '');\n            this.setCurrent(element);\n\n            for (var name in object) {\n                if (object[name] !== undefined && object[name] instanceof Array)\n                    this.objectListXmlPayload(name, object[name]);\n                else\n                if (object[name] !== undefined)\n                    this.setAttribute(name, object[name]);\n                else\n                    this.setAttribute(name, 'undefined');\n            }\n\n            if (shouldPop) this.pop();\n        } catch (error) {\n            ms.error(\"Failed to add xml element: \" + elementName + \":  \" + error);\n        }\n    },\n\n    type: \"CiscoAceXmlProbe\"\n});",
      "sys_id": "d847c5ef93210200084135bb357ffb3c"
    },
    {
      "script": "var MIDServerInit = Class.create();\r\n\r\nMIDServerInit.prototype = {\r\n    initialize: function() {\r\n    },\r\n\r\n    process: function() {\r\n        // var init = new InitCredentialsProviders();\r\n        // init.process();\r\n    },\r\n\r\n    type: 'MIDServerInit'\r\n}",
      "sys_id": "da6fe3dac0a802010030ce326d6850d2"
    },
    {
      "script": "// Required so can check if g_ var is defined.  Cannot just use 'typeof' on a defined g_ var due to\r\n// the way all the predefined g_ vars are set in the execution context in Java.\r\nfunction globalDefined(varName) {\r\n\treturn (function() {\r\n\t\treturn (varName in this);\r\n\t})();\r\n}\r\n\r\nvar XMLHelper = Class.create();\r\nXMLHelper.prototype = {\r\n\r\n\tinitialize : function(xml) {\r\n\t\tthis.setXML(xml);\r\n\t\tthis.trim = (!globalDefined('g_probe') || g_probe == null) ? false :  JSUtil.toBoolean(g_probe.getParameter(\"glide.xmlhelper.trim.enable\", \"false\"));\r\n\t},\r\n\r\n\tsetXML : function(xmlParam) {\r\n\t\tthis.xml = xmlParam;\r\n\r\n\t\t// if xml is string, or it looks like a string (has trimLeft function and is object)\r\n\t\t// then we want to parse it as a string\r\n\t\tif (typeof xmlParam == 'string' || (typeof xmlParam == 'object' && xmlParam && xmlParam.trimLeft))\r\n\t\t\tthis.xml = Packages.com.glide.util.XMLUtil.parse(xmlParam);\r\n\t},\r\n\r\n\t// convert XML to Javascript Object... Use the format specified on\r\n\t// http://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html\r\n\t// 'fastRemoveWhite' changes the way empty nodes are removed.  I think the\r\n\t// result will be identical, but I'm paranoid about breaking something.\r\n\t// New code should always set fastRemoveWhite to true.\r\n\ttoObject : function(xmlParam, fastRemoveWhite) {\r\n\r\n\t\tif (xmlParam)\r\n\t\t\tthis.setXML(xmlParam);\r\n\r\n\t\tvar xml = this.xml;\r\n\r\n\t\tif (!xml)\r\n\t\t\treturn;\r\n\r\n\t\tremoveWhite(xml);\r\n\r\n\t\treturn toObj(xml, this.trim);\r\n\r\n\t\t// borrowed and modified from: http://goessner.net/download/prj/jsonxml/xml2json.js\r\n\t\tfunction toObj(xml, doTrim) {\r\n\t\t\tvar i, item, nName, nValue, hasElementChild, n, nodeType, oVal, name, textChildNodeValue,\r\n\t\t\t\tattrs, length, firstChild,\r\n\t\t\t\txmlNodeType = xml.getNodeType(),\r\n\t\t\t\to = '', \r\n\t\t\t\ttextChild = 0,\r\n\t\t\t\tcdataChild = 0;\r\n\r\n\t\t\tif (xmlNodeType == 9)\r\n\t\t\t\treturn toObj(xml.documentElement, doTrim);\r\n\r\n\t\t\tif (xmlNodeType != 1)\r\n\t\t\t\treturn o;\r\n\r\n\t\t\tattrs = xml.attributes;\r\n\t\t\tlength = attrs && attrs.length;\r\n\t\t\tfirstChild = xml.firstChild;\r\n\r\n\t\t\t// element node ..\r\n\r\n\t\t\tif (length) // element with attributes ..\r\n\t\t\t\to = o || { };\r\n\t\t\t\tfor (i = 0; i < length; i++) {\r\n\t\t\t\t\titem = attrs.item(i);\r\n\t\t\t\t\tnName = item.nodeName;\r\n\t\t\t\t\tnValue = '' + item.nodeValue;\r\n\t\t\t\t\tif (doTrim) \r\n\t\t\t\t\t\tnValue = nValue.trim();\r\n\t\t\t\t\to[\"@\" + nName] = nValue;\r\n\t\t\t\t}\r\n\t\t\tattrs = 0;    // Reduce our memory use as much as possible.\r\n\r\n\t\t\tfor (n = firstChild; n && textChild < 2 && cdataChild < 2 && !hasElementChild; n = n.nextSibling) {\r\n\t\t\t\tnodeType = n.getNodeType();\r\n\t\t\t\tif (nodeType == 1)\r\n\t\t\t\t\thasElementChild = true;\r\n\t\t\t\telse if (nodeType == 4)\r\n\t\t\t\t\tcdataChild++; // cdata section node\r\n\t\t\t\telse if (nodeType == 3) {\r\n\t\t\t\t\tnValue = n.nodeValue;\r\n\t\t\t\t\tif (nValue.match(/\\S/)) {\r\n\t\t\t\t\t\ttextChild++;\r\n\t\t\t\t\t\ttextChildNodeValue = nValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (hasElementChild) {\r\n\t\t\t\tif (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..\r\n\t\t\t\t\tfastRemoveWhite || removeWhite(xml);\r\n\t\t\t\t\tfor (n = firstChild; n; n = n.nextSibling) {\r\n\t\t\t\t\t\tfirstChild = 0;   // Reduce our memory use as much as possible.\r\n\t\t\t\t\t\tnodeType = n.getNodeType();\r\n\t\t\t\t\t\tif (nodeType == 3 || nodeType == 4) {\r\n\t\t\t\t\t\t\tnValue = escape(n.nodeValue);\r\n\t\t\t\t\t\t\tif (nValue) {\r\n\t\t\t\t\t\t\t\to = o || { };\r\n\t\t\t\t\t\t\t\tif (nodeType == 3)\r\n\t\t\t\t\t\t\t\t\to['#text'] = nValue;\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\to['#cdata'] = nValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\to = o || { };\r\n\t\t\t\t\t\t\tname = n.nodeName;\r\n\t\t\t\t\t\t\tif (oVal = o[name]) { // multiple occurence of element ..\r\n\t\t\t\t\t\t\t\tif (oVal instanceof Array)\r\n\t\t\t\t\t\t\t\t\toVal.push(toObj(n, doTrim));\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\to[name] = [ oVal, toObj(n, doTrim) ];\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\to[name] = toObj(n, doTrim);  // first occurence of element..\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // mixed content\r\n\t\t\t\t\tif (!length)\r\n\t\t\t\t\t\to = escape(innerXml(xml));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\to[\"#text\"] = escape(innerXml(xml));\r\n\t\t\t\t}\r\n\t\t\t} else if (textChild) { // pure text\r\n\t\t\t\tif (textChild > 1)\r\n\t\t\t\t\ttextChildNodeValue = innerXml(xml);\r\n\t\t\t\t\r\n\t\t\t\tif (!length)\r\n\t\t\t\t\to = escape(textChildNodeValue);\r\n\t\t\t\telse\r\n\t\t\t\t\to[\"#text\"] = escape(textChildNodeValue);\r\n\t\t\t} else if (cdataChild) { // cdata\r\n\t\t\t\tif (!length)\r\n\t\t\t\t\to = escape(firstChild.nodeValue);\r\n\t\t\t\telse\r\n\t\t\t\t\to[\"#cdata\"] = escape(xml.lastChild);\r\n\t\t\t}\r\n\r\n\t\t\treturn o;\r\n\r\n\t\t\tfunction innerXml(node) {\r\n\t\t\t\tvar s = \"\";\r\n\t\t\t\tfor ( var c = node.firstChild; c; c = c.nextSibling)\r\n\t\t\t\t\ts += asXml(c);\r\n\t\t\t\treturn s;\r\n\r\n\t\t\t\tfunction asXml(n) {\r\n\t\t\t\t\tvar attrs, length, item, nName,\r\n\t\t\t\t\t\ts = \"\",\r\n\t\t\t\t\t\ttype = n.getNodeType();\r\n\r\n\t\t\t\t\tif (type == 1) {\r\n\t\t\t\t\t\tnName = n.nodeName;\r\n\t\t\t\t\t\ts += \"<\" + nName;\r\n\t\t\t\t\t\tattrs = n.attributes;\r\n\t\t\t\t\t\tlength = attrs.length;\r\n\t\t\t\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\t\t\t\titem = attrs.item(i);\r\n\t\t\t\t\t\t\ts += \" \" + item.nodeName + \"=\\\"\"\r\n\t\t\t\t\t\t\t\t+ (item.nodeValue || \"\").toString() + \"\\\"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar c = n.firstChild;\r\n\t\t\t\t\t\tif (c) {\r\n\t\t\t\t\t\t\ts += \">\";\r\n\t\t\t\t\t\t\tfor ( ; c; c = c.nextSibling)\r\n\t\t\t\t\t\t\t\ts += asXml(c);\r\n\t\t\t\t\t\t\ts += \"</\" + nName + \">\";\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\ts += \"/>\";\r\n\t\t\t\t\t} else if (type == 3)\r\n\t\t\t\t\t\ts += n.nodeValue;\r\n\t\t\t\t\telse if (type == 4)\r\n\t\t\t\t\t\ts += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n\t\t\t\t\treturn s;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction escape(txt) {\r\n\t\t\t\tvar escapedTxt = '' + (doTrim ? txt.trim() : txt);\r\n\t\t\t\t\r\n\t\t\t\treturn escapedTxt.replaceAll(/([\\\\\\\"])/g, '\\\\$1').replaceAll(/[\\\\r\\\\n]/g, '\\\\n');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction removeWhite(e) {\r\n\t\t\te.normalize();\r\n\t\t\tfor ( var n = e.firstChild; n;) {\r\n\t\t\t\tvar nodeType = n.getNodeType();\r\n\t\t\t\tif (nodeType == 3) { // text node\r\n\t\t\t\t\tif (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) { // pure whitespace text node\r\n\t\t\t\t\t\tvar nxt = n.nextSibling;\r\n\t\t\t\t\t\te.removeChild(n);\r\n\t\t\t\t\t\tn = nxt;\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t\t} else if (nodeType == 1) { // element node\r\n\t\t\t\t\tremoveWhite(n);\r\n\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t\t} else\r\n\t\t\t\t\t// any other node\r\n\t\t\t\t\tn = n.nextSibling;\r\n\t\t\t}\r\n\t\t\treturn e;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\ttoXMLStr : function(o) {\r\n\t\tvar toXml = function(v, name, ind) {\r\n\t\t\tif (typeof(v) == \"function\")\r\n\t\t\t\treturn \"\";\r\n\r\n\t\t\tvar xml = \"\";\r\n\t\t\tif (v instanceof Array) {\r\n\t\t\t\tfor ( var i = 0, n = v.length; i < n; i++)\r\n\t\t\t\t\txml += ind + toXml(v[i], name, ind + \"\\t\") + \"\\n\";\r\n\t\t\t} else if (typeof (v) == \"object\") {\r\n\t\t\t\tvar hasChild = false;\r\n\t\t\t\txml += ind + \"<\" + name;\r\n\t\t\t\tfor ( var m in v) {\r\n\t\t\t\t\tif (m.charAt(0) == \"@\")\r\n\t\t\t\t\t\txml += \" \" + m.substr(1) + \"=\\\"\" + v[m].toString() + \"\\\"\";\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\thasChild = true;\r\n\t\t\t\t}\r\n\t\t\t\txml += hasChild ? \">\" : \"/>\";\r\n\t\t\t\tif (hasChild) {\r\n\t\t\t\t\tfor (m in v) {\r\n\t\t\t\t\t\tif (m == \"#text\")\r\n\t\t\t\t\t\t\txml += v[m];\r\n\t\t\t\t\t\telse if (m == \"#cdata\")\r\n\t\t\t\t\t\t\txml += \"<![CDATA[\" + v[m] + \"]]>\";\r\n\t\t\t\t\t\telse if (m.charAt(0) != \"@\")\r\n\t\t\t\t\t\t\txml += toXml(v[m], m, ind + \"\\t\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\txml += (xml.charAt(xml.length - 1) == \"\\n\" ? ind : \"\") + \"</\" + name + \">\";\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\txml += ind + \"<\" + name + \">\" + v.toString() + \"</\" + name + \">\";\r\n\t\t\t}\r\n\t\t\treturn xml;\r\n\t\t};\r\n\r\n\t\tvar xml = \"\";\r\n\t\tfor ( var m in o)\r\n\t\t\txml += toXml(o[m], m, \"\");\r\n\t\treturn xml.replace(/\\t|\\n/g, \"\");\r\n\t},\r\n\ttype : \"XMLHelper\"\r\n};\r\n",
      "sys_id": "db1b58349f02210054679ff3367fcfc3"
    },
    {
      "script": "ms.include(\"JsSshIncludes\");\n\nvar SSHTerminalCommand = Class.create();\nSSHTerminalCommand.prototype = Object.extendsObject(AProbe, {\n\n    initialize : function(probe) {\n        this.probe = probe;\n        this.output = \"\";\n        this.createOutputRecord = false;\n\t\tthis.source = this.getParameter(SOURCE);\n    },\n    \n    /**\n     * Runs the probe instance\n     */\n    run : function() {\n\t\tms.log('SSHTerminalCommand: run');\n        this.init();\n        \n       \n        // If something fails in the probe code and an unhandled exception is thrown, make sure we clean up\n        try {\n            this.process();\n        }catch (ex) {\n\t\t\tif (ex instanceof AuthenticationFailureException) {\n\t\t\t\tms.log(\"Authentication failed for host \" +  this.source + \", check the SSH credential definition \");\n\t\t\t} else {\n\t\t\t\tms.log(ex);\n\t\t\t\tthis.setError(ex);\n\t\t\t}\n            \n        } finally {\n            this.cleanup();\n\t\t\tthis.commandExecutor.terminate();\n        }\n\t\t\n    },\n    \n     //This is the abstruct function that must be implemented in derived class\n\t // This function should prepare the output and assign it to this.output\n    \n     runCommands : function(cliCommands) {\n         \n         this.newResult();\n         var elements = this.createElement('commands', '');\n         this.setCurrent(elements);\n         for(var aIndex in cliCommands){\n             var cliCommand = cliCommands[aIndex];\n             var cmdResult = this.commandExecutor.execCommand(cliCommand);\n             if(typeof cmdResult === 'undefined'){\n                cmdResult = 'empty';\n             }\n             var element = this.createElement('command', '');\n             this.setCurrent(element);\n             this.setAttribute('executed',cliCommand);\n             this.probe.createCDATAElement('result',cmdResult);\n             this.pop();\n         }\n         this.pop();\n     },\n    \n    /**\n      * Attempts to initialize the commandExecutor instance to allow the process method to do its work\n      */\n    init : function() {\n\t\tms.log('SSHTerminalCommand: init');\n        this.commandExecutor = this.getCommandExecuter();\n    },\n    \n    /**\n      * Abstract function to run the probe functionality - the derived probes should have a body for this\n      */\n    process : function() {\n        var CLI_COMMANDS_PARAM = 'cli_commands';\n\t\tvar cliCommands = this.getParameter(CLI_COMMANDS_PARAM);\n        ms.log('SSHTerminalCommand: init - cli_commands = ' + cliCommands);\n        if(cliCommands.trim())\n        {\n            var arrCliCommands = cliCommands.split(';');\n            this.runCommands(arrCliCommands);\n        }\n        \n    },\n    \n    /**\n     * Logs out of the SSHProvider connected to cli device and creates the output result records when\n     * we weren't able to connect so the error that is set gets propagated properly\n     */\n    cleanup : function() {\n        \n        if (this.createOutputRecord)\n            this.createOutputResult(this.output);\n    },\n    \n    getCommandExecuter : function() {\n\t\t\n\t\tms.log('SSHTerminalCommand: getCommandExecuter');\n\t\tms.log('SSHTerminalCommand: getCommandExecuter - source = ' + this.source);\n        \n\t\tvar sshProvider = null;\n        \n\t\ttry {\n            var providerFactory = new DiscoveryProviderFactory();\n            sshProvider = providerFactory.create(ProviderType.SSH, null, this.source, null);\n\t\t\tsshProvider.setHost(this.source);\n\t\t\tsshProvider.setUseSncssh(false);\n            this.debug('Attempting to connect');\n        } catch (ex) {\n            this.setError(\"Unable to establish connection \" + ex);\n            return null;\n        }\n        \t\n        return sshProvider;\n    },\n           \n    type: \"SSHTerminalCommand\"\n});",
      "sys_id": "e1c0271293d10200084135bb357ffb3e"
    },
    {
      "script": "/* jshint -W030 */\nObjectPolyfill;\nArrayPolyfill;\n \nvar VMWarevCenterVMsProbe = Class.create();\n\n(function() {\n\nvar _this, refreshOnly,\n\toutput = { },\n\tdvpgDatamap = {\n\t\tconfig: {\n\t\t\tdistributedVirtualSwitch: { }\n\t\t}\n\t};\n\n//////////////////////////////////////////////////////////////////////////\nVMWarevCenterVMsProbe.prototype = Object.extendsObject(AVMWareProbe, {\n\n    process : function() {\n\t\tvar name, output,\n\t\t\tvms = [ ],\n\t\t\ttemplates = [ ],\n\t\t\tleftOverMors = JSON.parse('' + probe.getParameter('mor_ids')),\n\t\t\tdebug = ('' + probe.getParameter('debug')) == 'true',\n\t\t\t// Average measured size of a VM is 637 bytes.  Default page size\n\t\t\t// of 100 leaves us well below the 5 MB limit.\n\t\t\tpageSize = parseInt(probe.getParameter('page_size')) || 100,\n\t\t\tvmMorIds = leftOverMors.splice(0, pageSize),\n\t\t\toriginalData = [ ],\n\t\t\tdatamap = {\n\t\t\t\tparent: { },\n\t\t\t\tresourcePool: { },\n\t\t\t\tparentVApp: { },\n\t\t\t\tconfig: {\n\t\t\t\t\thardware: {\n\t\t\t\t\t\tnumCPU: 'cpus',\n\t\t\t\t\t\tmemoryMB: 'memory',\n\t\t\t\t\t\tdevice: [ {\n\t\t\t\t\t\t\tcapacityInKB: 'capacity',\n\t\t\t\t\t\t\tmacAddress: 'macAddress'\n\t\t\t\t\t\t} ]\n\t\t\t\t\t},\n\t\t\t\t\tuuid: 'correlation_id',\n\t\t\t\t\tinstanceUuid: 'vm_instance_uuid',\n\t\t\t\t\tfiles: { vmPathName: 'vmPathName' },\n\t\t\t\t\ttemplate: function(value, o) { o.template = !!value.isTemplate(); },\n\t\t\t\t\tguestId: 'guest_id',\n\t\t\t\t\tguestFullName: 'guest_os_fullname'\n\t\t\t\t},\n\t\t\t\tsummary: {\n\t\t\t\t\tguest: {\n\t\t\t\t\t\tipAddress: 'ipAddress',\n\t\t\t\t\t\thostName: 'hostName'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdatastore: [ { } ],\n\t\t\t\truntime: {\n\t\t\t\t\tpowerState: 'state',\n\t\t\t\t\thost: { }\n\t\t\t\t},\n\t\t\t\tname: 'name',\n\t\t\t\tnetwork: [ { } ]\n\t\t\t},\n\t\t\trefreshDatamap = {\n\t\t\t\truntime: {\n\t\t\t\t\tpowerState: 'state'\n\t\t\t\t}\n\t\t\t};\n\n\t\tdatamap.config.hardware.device._filter = vmFilter;\n\n\t\trefreshOnly = (this.getParameter('refresh_state') == 'true');\n\t\tif (refreshOnly)\n\t\t\tdatamap = refreshDatamap;\n\t\t\n\t\tif (!this.serviceInstance)\n\t\t\treturn;\n\n\t\t_this = this;\n\n\t\t/*\n\t\tSample data.  Truncated for brevity, so possibly inconsistent:\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"type\": \"VirtualMachine\",\n\t\t\t\t\"morid\": \"vm-4373\",\n\t\t\t\t\"parent\": {\n\t\t\t\t  \"type\": \"Folder\",\n\t\t\t\t  \"morid\": \"group-v3\"\n\t\t\t\t},\n\t\t\t\t\"config\": {\n\t\t\t\t  \"hardware\": {\n\t\t\t\t\t\"cpus\": 1,\n\t\t\t\t\t\"memory\": 64,\n\t\t\t\t\t\"device\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"capacity\": 524288\n\t\t\t\t\t  },\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"macAddress\": \"00:50:56:a7:3c:c1\"\n\t\t\t\t\t  }\n\t\t\t\t\t]\n\t\t\t\t  },\n\t\t\t\t  \"correlation_id\": \"42273e88-343c-9bda-96e1-9bd9680081f2\",\n\t\t\t\t  \"vm_instance_uuid\": \"5027ad3b-f66e-fe70-ab41-5d2dcdc52521\",\n\t\t\t\t  \"files\": {\n\t\t\t\t\t\"vmPathName\": \"[SANLAB1GlobalDS_4] DC0_C1_RP2_VM11\\/DC0_C1_RP2_VM11.vmx\"\n\t\t\t\t  },\n\t\t\t\t  \"template\": false,\n\t\t\t\t  \"guest_id\": \"winNetStandardGuest\"\n\t\t\t\t},\n\t\t\t\t\"datastore\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"Datastore\",\n\t\t\t\t\t\"morid\": \"datastore-93\"\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"runtime\": {\n\t\t\t\t  \"state\": {\n\n\t\t\t\t  },\n\t\t\t\t  \"host\": {\n\t\t\t\t\t\"type\": \"HostSystem\",\n\t\t\t\t\t\"morid\": \"host-1078\"\n\t\t\t\t  }\n\t\t\t\t},\n\t\t\t\t\"name\": \"DC0_C1_RP2_VM11\",\n\t\t\t\t\"network\": [\n\t\t\t\t  {\n\t\t\t\t\t\"type\": \"DistributedVirtualPortgroup\",\n\t\t\t\t\t\"morid\": \"dvportgroup-11\"\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t*/\n\t\t// Iterate over the MOR IDs of VMs we're going to process\n\t\tvmMorIds.forEach(\n\t\t\tfunction(vm) {\n\t\t\t\ttry {\n\t\t\t\t\t// Create a managed object for the current VM, fetch data for it\n\t\t\t\t\t// See http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.VirtualMachine.html\n\t\t\t\t\tvar mor = new vim25.ManagedObjectReference();\n\t\t\t\t\tmor.setType(vm.type);\n\t\t\t\t\tmor.setVal(vm.morid);\n\t\t\t\t\tvm = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\t\tvm = _this.getPropsForManagedObject(vm, datamap);\n\n\t\t\t\t\t// If we're debugging, save the data we fetched\n\t\t\t\t\tif (debug)\n\t\t\t\t\t\toriginalData.push(JSON.stringify(vm));\n\n\t\t\t\t\tif (vm.config.template)\n\t\t\t\t\t\ttemplates.push(vm);\n\t\t\t\t\telse\n\t\t\t\t\t\tvms.push(vm);\n\n\t\t\t\t\t// Fixup the data.\n\t\t\t\t\tfixVM(vm);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.probe.appendWarning('Caught exception when processing ' + vm.type + ' ' + vm.morid + ': ' + e.toString());\n\t\t\t\t}\n\t\t\t});\n\n\t\toutput = {\n\t\t\t\tcmdb_ci_vmware_instance: vms,\n\t\t\t\tcmdb_ci_vmware_template: templates\n\t\t\t};\n\n\t\t// We fetched at most pageSize VMs.  Send back the IDs of remaining VMs so the\n\t\t// sensor can fire another probe.\n\t\tif (leftOverMors.length)\n\t\t\toutput.leftOverMors = leftOverMors;\n\n\t\tif (debug)\n\t\t\toutput.originalData = originalData.map(JSON.parse);\n\n\t\tthis.output = JSON.stringify(output, function(key, value) { if (key != \"mo\") return value; });\n\t},\n\n\ttype : 'VMWarevCenterVMsProbe'\n});\n\n//////////////////////////////////////////////////////////////////////////\nfunction vmFilter(vcenterObj, obj) {\n\tif (vcenterObj instanceof vim25.VirtualDisk || vcenterObj instanceof vim25.VirtualEthernetCard) {\n\t\tobj.mo = vcenterObj;\n\t\treturn true;\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction fixVM(vm) {\n\tvar name, dvpg, mor,\n\t\tstate = vm.runtime.state,\n\t\tconfig = vm.config,\n\t\thardware = config.hardware,\n\t\tdevices = hardware.device;\n\n\tif (state == 'poweredOn')\n\t\tvm.state = 'on';\n\telse if (state == 'poweredOff')\n\t\tvm.state = 'off';\n\telse\n\t\tvm.state = 'paused';\n\n\tvm.cmdb_ci_esx_morid = vm.runtime.host && vm.runtime.host.morid;\n\n\tdelete vm.runtime;\n\n\tif (refreshOnly)\n\t\treturn;\n\n\tvm.network.forEach(\n\t\tfunction(network) {\n\t\t\tif (network.type == 'DistributedVirtualPortgroup') {\n\t\t\t\tmor = new vim25.ManagedObjectReference();\n\t\t\t\tmor.setType(network.type);\n\t\t\t\tmor.setVal(network.morid);\n\t\t\t\tdvpg = vim25.mo.util.MorUtil.createExactManagedEntity(_this.serverConnection, mor);\n\t\t\t\tdvpg = _this.getPropsForManagedObject(dvpg, dvpgDatamap);\n\t\t\t\tif (dvpg.config && dvpg.config.distributedVirtualSwitch)\n\t\t\t\t\tvm.cmdb_ci_vcenter_dvs = dvpg.config.distributedVirtualSwitch.morid;\n\t\t\t}\n\t\t});\n\n\textractMORs(vm.datastore);\n\textractMORs(vm.network);\n\n\tvm.cmdb_ci_vcenter_network = vm.network;\n\tvm.cmdb_ci_vcenter_datastore = vm.datastore;\n\tif (vm.resourcePool)\n\t\tvm.cmdb_ci_esx_resource_pool = vm.resourcePool.morid;\n\tif (vm.parentVApp)\n\t\tvm.vapp = vm.parentVApp.morid;\n\n\tfor (name in config)\n\t\tvm[name] = config[name];\n\tfor (name in hardware)\n\t\tvm[name] = hardware[name];\n\n\tvm.cmdb_ci_vcenter_folder = vm.parent.morid;\n\t\n\tvm.object_id = vm.morid;\n\n\tvm.image_path = config.files.vmPathName;\n\n\tif (vm.summary.guest){\n\t\tif(vm.summary.guest.ipAddress)\n\t\t\tvm.ip_address = vm.summary.guest.ipAddress;\n\t\tif(vm.summary.guest.hostName)\n\t\t\tvm.fqdn = vm.summary.guest.hostName;\n\t}\n\n\tvm.disks = 0;\n\tvm.disks_size = 0;\n\tvm.nics = 0;\n\tvm.macs = [ ];\n\n\tdevices.forEach(\n\t\tfunction(device) {\n\t\t\tif (device.mo instanceof vim25.VirtualDisk) {\n\t\t\t\tvm.disks_size += device.capacity;\n\t\t\t\tvm.disks++;\n\t\t\t} else {\n\t\t\t\tvm.nics++;  // We've already filtered hardware to have only disks & ethernet cards\n\t\t\t\tvm.macs.push(device.macAddress);\n\t\t\t}\n\t\t});\n\tvm.disks_size = (vm.disks_size / 1048576) | 0;\n\n\tdelete vm.resourcePool;\n\tdelete vm.parentVApp;\n\tdelete vm.files;\n\tdelete vm.config;\n\tdelete vm.hardware;\n\tdelete vm.device;\n\tdelete vm.parent;\n\tdelete vm.network;\n\tdelete vm.datastore;\n}\n\n//////////////////////////////////////////////////////////////////////////\nfunction extractMORs(a) {\n\ta.forEach(function(o, idx) { a[idx] = o.morid; });\n}\n\n})();",
      "sys_id": "e6dfb0ef93c31200c2fe705bb47ffbae"
    },
    {
      "script": "var AProbe = Class.create();\n\nAProbe.prototype = {\n\n    initialize : function(probe) {\n        this.probe = probe;\n    },\n    \n    /**\n     * Abstract function to execute the probe functionality - the derived probes should have a body for this\n     */\n    run : function() {\n    },\n        \n    /**\n      * Probe pass-through helper functions\n      */\n    createElement : function(key, value) {\n        if (this.probe != null)\n            return this.probe.createElement(key, value);\n        else\n            return null;\n    },\n    \n    createOutputResult : function(output) {\n        if (this.probe != null)\n            this.probe.createOutputResult(output);\n    },\n    \n    getParameter : function(key, defaultValue) {\n        if (this.probe != null) {\n\t\t\tif (arguments.length >= 2)\n\t\t\t\treturn this.probe.getParameter(key, defaultValue);\n\t\t\treturn this.probe.getParameter(key, null);\n\t\t} else\n            return null;\n    },\n    \n    getIntParameter : function(key) {\n        if (this.probe != null)\n            return this.probe.getIntParameter(key);\n        else\n            return null;\n    },\n    \n    getIntParameter : function(key, defaultValue) {\n        if (this.probe != null)\n            return this.probe.getIntParameter(key, defaultValue);\n        else\n            return null;\n    },\n    \n    getBooleanParameter : function(key) {\n        if (this.probe != null)\n            return this.probe.getBooleanParameter(key);\n        else\n            return null;\n    },\n\n    getBooleanParameter : function(key, defaultValue) {\n        if (this.probe != null)\n            return this.probe.getBooleanParameter(key, defaultValue);\n        else\n            return null;\n    },\n\n    getAgentName : function() {\n        if (this.probe != null)\n            return this.probe.getAgentName();\n        else\n            return null;\n    },\n\n    getPayload : function() {\n        if (this.probe != null)\n            return this.probe.getPayload();\n        else\n            return null;\n    },\n\n    hasParameter : function(param) {\n        if (this.probe != null)\n            return this.probe.hasParameter(param);\n        else\n            return false;\n    },\n\n    newResult : function() {\n        if (this.probe != null)\n            return this.probe.newResult();\n        else\n            return null;\n    },\n\n    pop : function() {\n        if (this.probe != null)\n            this.probe.pop();\n    },\n\n    setAttribute : function(key, value) {\n        if (this.probe != null)\n            return this.probe.setAttribute(key, '' + value);\n        else\n            return null;\n    },\n\n    setCurrent : function(element) {\n        if (this.probe != null)\n            this.probe.setCurrent(element);\n    }, \n\n    setError : function(error) {\n        if (this.probe != null)\n            this.probe.setError(error);\n    },\n\n    debug : function(msg) {\n        if (this.probe != null && this.probe.isDebugging())\n            ms.log('*** DEBUG: ' + msg);\n    },\n\t\n\t/**\n     * Returns an iterator over the set of credentials available to this MID server. If the target host has affinity\n     * with any of the credentials in the set, then that credential will be the first one iterated.\n     */\n\tgetCredentials : function(type) {\n\t\tif (this.probe != null)\n            return this.probe.getCredentials(type);\n\t\telse\n\t\t\treturn null; \n\t},\n\n    type: \"AProbe\"\n}",
      "sys_id": "ec826c90ff230000dada679cdbffad9c"
    },
    {
      "script": "var CiscoCliProbe = Class.create();\n\nCiscoCliProbe.prototype = Object.extendsObject(SSHTerminalCommand, {\n\n    runCommands: function (cisco_cli_commands) {\n\n        this.deviceVersion = {\n            type: 'Cisco ACE LoadBalancder',\n            version: ''\n        };\n        this.groups = [];\n        this.realServers = [];\n        this.interfaces = [];\n        this.vipList = [];\n\n        var ciscoContexts = this.getCiscoContexts();\n\n        for (var cIndex in ciscoContexts) {\n            var ciscoContext = ciscoContexts[cIndex];\n            try {\n                this.changeCiscoContext(ciscoContext);\n                this.__runCliCommands(cisco_cli_commands);\n            } catch (error) {\n                ms.log(\"CiscoCliProbe: fail to change context: \" + error);\n            }\n        }\n\n        this.generateXMLPayload();\n\n    },\n\n    __runCliCommands: function (cliCommands) {\n        for (var i in cliCommands) {\n            cli_command = cliCommands[i];\n            if (cli_command) {\n                switch (String(cli_command).trim()) {\n                    case 'show version':\n                        ms.log(\"Trying to run cli command \" + cli_command);\n                        this.deviceVersion.version = this.getCiscoVersion();\n                        break;\n\n                    case 'show interface':\n                        ms.log(\"Trying to run cli command \" + cli_command);\n                        this.getCiscoInterfaces();\n                        break;\n                    case 'show rserver':\n                        ms.log(\"Trying to run cli command \" + cli_command);\n                        this.getCiscoRealServers();\n                        break;\n                    case 'show serverfarm':\n                        ms.log(\"Trying to run cli command \" + cli_command);\n                        this.getCiscoFarms();\n                        break;\n                    case 'show service-policy detail':\n                        ms.log(\"Trying to run cli command \" + cli_command);\n                        this.getCiscoVips();\n                        break;\n                    default:\n                        ms.log(\"Unsupported cli command \" + cli_command);\n                        break;\n                }\n            }\n        }\n\n    },\n\n    getCiscoVersion: function () {\n        var cmd_result = this.commandExecutor.execCommand('show version|include system:|exclude filesystem');\n        var ciscoVersion = cmd_result.replace('system:', '').trim();\n        return ciscoVersion;\n\n    },\n\n    changeCiscoContext: function (contextName) {\n        var cmdResult = this.commandExecutor.execCommand('changeto ' + contextName);\n        if (cmdResult !== null && cmdResult !== '') {\n            var subStrIndex = cmdResult.indexOf('Error:')\n            if (subStrIndex > -1) {\n                throw 'Error: Failed to change context to: ' + contextName + ' contact System Administrator';\n            } else {\n                ms.log(\"CiscoCliProbe:changeCiscoContext: context changed to: \" + contextName);\n            }\n        }\n\n    },\n\n    getCiscoInterfaces: function () {\n\n        var cmd_result = this.commandExecutor.execCommand('show interface | include is');\n        var lines = cmd_result.split(\"\\n\");\n\n        for (var i = 0; i < lines.length; i++) {\n            var line = String(lines[i]).trim().split(new RegExp(\"\\\\s+\"));\n\n            if (line.length === 9 && line[0] === \"GigabitEthernet\") {\n                var rowName = line[2].split(\"/\");\n                var interfaceName = rowName[0] + \".\" + rowName[1];\n                var interfaceStatus = line[4].split(',')[0];\n                var macAddress = \"undefined\";\n                if (i + 1 < lines.length) {\n                    macLine = String(lines[i + 1]).trim().split(new RegExp(\"\\\\s+\"));\n                    ms.log(\"The line of MAC length is: \" + macLine.length);\n\n                    if (macLine.length >= 8) {\n                        macAddress = macLine[8];\n                    }\n                }\n                this.interfaces.push({\n                    name: interfaceName,\n                    status: interfaceStatus,\n                    MACAddress: macAddress\n                });\n            }\n        }\n\n        ms.log(\"This is the Json result \" + JSON.stringify(this.interfaces));\n    },\n\n    getCiscoContexts: function () {\n\n        var cmd_result = this.commandExecutor.execCommand('show context | include Name:');\n        var raw_contexts = cmd_result.split('\\n');\n        var contexts = [];\n        for (var i in raw_contexts) {\n            var context = raw_contexts[i].replace('Name:', '').split(',')[0].trim();\n            contexts.push(context);\n        }\n\n        return contexts;\n    },\n\n    getCiscoFarms: function () {\n        var cmd_result = this.commandExecutor.execCommand('show serverfarm | exclude +-----|exclude serverfarm');\n        var lines = cmd_result.split(\"\\n\");\n\n        var serverFarmName;\n        var balancingMethod;\n        var isDetailsNextRow = false;\n        var entry;\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            line = line.trim();\n\n            if (line) {\n                var lineParts = String(line).split(new RegExp(\"\\\\s+\"));\n\n                if (isDetailsNextRow) {\n                    isDetailsNextRow = false;\n                    balancingMethod = lineParts[2];\n                    entry = {\n                        name: serverFarmName,\n                        method: balancingMethod\n                    };\n                    ms.log(entry.group);\n                    ms.log(entry.method);\n                    this.groups.push(entry);\n                } else if (lineParts.length == 1) {\n                    serverFarmName = lineParts[0];\n                    isDetailsNextRow = true;\n\n                }\n            }\n        }\n\n        ms.log(\"This is the Json result \" + JSON.stringify(this.groups));\n\n\n    },\n\n    getCiscoRealServers: function () {\n\n        var cmd_result = this.commandExecutor.execCommand('show rserver | exclude state | exclude +--- | exclude connections');\n        var lines = cmd_result.split(\"\\n\");\n\n        var realServerName;\n        var realServerAddress;\n        var realServerPort;\n        var pool;\n\n        var isIPNextRow = false;\n\n        var entry;\n\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            line = line.trim();\n\n            if (line) {\n                var lineParts = String(line).split(new RegExp(\"\\\\s+\"));\n\n                if (isIPNextRow) {\n                    isIPNextRow = false;\n                    var ipAndPort = lineParts[0].split(\":\");\n                    realServerAddress = ipAndPort[0];\n                    realServerPort = ipAndPort[1];\n\n                    entry = {\n                        name: realServerName,\n                        ip: realServerAddress,\n                        port: realServerPort,\n                        group: pool\n                    };\n                    this.realServers.push(entry);\n                } else if (lineParts[0].match(/rserver/)) {\n                    realServerName = lineParts[2].split(',')[0];\n                } else if (lineParts[0].match(/serverfarm/)) {\n                    pool = lineParts[1];\n                    isIPNextRow = true;\n                }\n            }\n        }\n\n        ms.log(\"This is the Json result \" + JSON.stringify(this.realServers));\n\n    },\n\n    getCiscoVips: function () {\n\n        var cmd_result = this.commandExecutor.execCommand('show service-policy detail');\n        var lines = cmd_result.split(\"\\n\");\n\n        var vipName;\n        var vipIp;\n        var vipPort;\n        var vipState;\n\n        var isDetailsNextRow = false;\n\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            line = line.trim();\n            if (line) {\n                var lineParts = String(line).split(new RegExp(\"\\\\s+\"));\n                if (isDetailsNextRow) {\n                    isDetailsNextRow = false;\n                    vipIp = lineParts[0];\n                    if (lineParts.length == 4) {\n                        vipPort = lineParts[3];\n                    } else {\n                        vipPort = \"80\";\n                    }\n                } else if (lineParts[0].match(/class:/)) {\n                    if (lineParts[1]) {\n                        vipName = lineParts[1].trim();\n                    }\n                } else if (line.match(/VIP Address:/)) {\n                    isDetailsNextRow = true;\n                } else if (line.match(/VIP State:/)) {\n                    vipState = lineParts[2].trim();\n\n                } else if (line.match(/primary serverfarm:/)) {\n                    var serviceFarm = lineParts[2].trim();\n                    var entry = {\n                        name: vipName,\n                        ip: vipIp,\n                        port: vipPort,\n                        state: vipState,\n                        group: serviceFarm\n                    };\n                    this.vipList.push(entry);\n                }\n\n            }\n        }\n\n        ms.log(\"This is the Json result \" + JSON.stringify(this.vipList));\n    },\n\n    /**\n     * Writes the XML payload representing the VMWare environment managed by vCenter\n     */\n    generateXMLPayload: function () {\n        this.createOutputRecord = false;\n        this.newResult();\n        this.ciscoXmlPayload();\n    },\n\n    ciscoXmlPayload: function () {\n        this.objectXmlPayload('device', this.deviceVersion, false);\n        this.objectListXmlPayload('group', this.groups);\n        this.objectListXmlPayload('server', this.realServers);\n        this.objectListXmlPayload('interface', this.interfaces);\n        this.objectListXmlPayload('vip', this.vipList);\n        this.pop();\n    },\n\n    objectListXmlPayload: function (elementName, objects) {\n        var elements = this.createElement(elementName + 's', '');\n        this.setCurrent(elements);\n\n        // Handle each object\n        for (var i = 0; i < objects.length; i++)\n            this.objectXmlPayload(elementName, objects[i], true);\n\n        this.pop();\n    },\n\n    objectXmlPayload: function (elementName, object, shouldPop) {\n        var element = this.createElement(elementName, '');\n        this.setCurrent(element);\n\n        for (var name in object) {\n            if (object[name] instanceof Array)\n                this.objectListXmlPayload(name, object[name]);\n            else\n                this.setAttribute(name, object[name]);\n        }\n\n        if (shouldPop)\n            this.pop();\n    },\n\n    type: \"CiscoCliProbe\"\n});",
      "sys_id": "ef8a1d4f93510200084135bb357ffbc2"
    },
    {
      "script": "var MIDServerThread = Class.create();\r\n\r\nMIDServerThread.prototype = {\r\n    initialize: function() {\r\n      this.active = Packages.java.lang.Thread.activeCount();\r\n      this.allThreads = Packages.java.lang.reflect.Array.newInstance(Packages.java.lang.Thread, this.active);\r\n      Packages.java.lang.Thread.enumerate(this.allThreads);\r\n    },\r\n\r\n    getThread : function (threadName) {\r\n      for (var i = 0; i < this.active; i++) {\r\n        if (this.allThreads[i] == null)\r\n          continue;\r\n\r\n        if (this.allThreads[i].getName() == threadName) {\r\n          return this.allThreads[i];\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n\r\n    listThreads : function () {\r\n      ms.log(\"Listing threads\");\r\n      for (var i = 0; i < this.active; i++) {\r\n        if (this.allThreads[i] == null)\r\n          continue;\r\n\r\n        ms.log(this.allThreads[i].getName());\r\n      }\r\n      ms.log(\"---------------\");\r\n    },\r\n\r\n    interrupt : function (threadName) {\r\n      var thread = this.getThread(threadName);\r\n      if (thread == null) {\r\n        ms.log(\"Thread '\" + threadName + \"' not found\");\r\n        return;\r\n      }\r\n\r\n      ms.log(\"interrupting thread '\" + threadName + \"'\");\r\n      thread.interrupt();\r\n    },\r\n\r\n    type: 'MIDServerThread'\r\n}",
      "sys_id": "f038ded50a0a0b3f00dd2b1b9a76e9ba"
    },
    {
      "script": "var ArrayUtil = Class.create();\nArrayUtil.prototype = {\n    initialize: function(){\n    },\n    \n    contains: function(array, element){\n        array = this.convertArray(array);\n        for (var i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                return true;\n            }\n        }\n        return false;\n    },\n    \n    indexOf: function(array, item, startIndex){\n        array = this.convertArray(array);\n        var len = array.length;\n        if (startIndex == null) {\n            startIndex = 0;\n        }\n        else \n            if (startIndex < 0) {\n                startIndex += len;\n                if (startIndex < 0) \n                    startIndex = 0;\n            }\n        \n        for (var i = startIndex; i < len; i++) {\n            var val = array[i] || array.charAt && array.charAt(i);\n            if (val == item) \n                return i;\n        }\n        \n        return -1;\n    },\n    \n    ensureArray: function(obj){\n        var array = new Array();\n        \n        if (obj == null || typeof obj == \"undefined\") \n            return array;\n        \n        if (obj.constructor.toString().indexOf(\"Array\") > -1) \n            return obj;\n        \n        array.push(obj);\n        return array;\n    },\n    \n    concat: function(parent, children){\n        for (var i = 0; i < children.length; i++) {\n            var item = children[i];\n            parent.push(item);\n        }\n        \n        return parent;\n    },\n    \n    convertArray: function(a){\n        if (a.size() > 0) {\n            var newArray = new Array();\n            for (var i = 0; i < a.size(); i++) {\n                var val = a.get(i);\n                newArray.push(val);\n            }\n            a = newArray;\n        }\n        \n        return a;\n    },\n    \n    /**\n     * Find the difference between two or more arrays\n     * diff(a,b,c)\n     * will return an array of items from a that were not found in either b or c\n     * Duplicate items are removed from the result\n     * @param two or more arrays\n     * @return Array\n     */\n    diff: function(){\n        if (!arguments.length) \n            return [];\n        \n        var a1 = arguments[0];\n        if (arguments.length == 1) \n            return a1;\n        \n        var a = a2 = null;\n        var n = 1;\n        while (n < arguments.length) {\n            a = [];\n            a2 = arguments[n];\n            var l = a1.length;\n            var l2 = a2.length;\n            var diff = true;\n            for (var i = 0; i < l; i++) {\n                for (var j = 0; j < l2; j++) {\n                    if (a1[i] === a2[j]) {\n                        diff = false;\n                        break;\n                    }\n                }\n                diff ? a.push(a1[i]) : diff = true;\n            }\n            a1 = a;\n            n++;\n        }\n        return this.unique(a);\n    },\n    \n    /**\n     * Find the intersect between two or more arrays\n     * intersect(a,b,c)\n     * will return an array of items from a that were also found in both b or c\n     * Duplicate items are removed from the result\n     * @param two or more arrays\n     * @return Array\n     */\n    intersect: function(){\n        if (!arguments.length) \n            return [];\n        \n        var a1 = arguments[0];\n        if (arguments.length == 1) \n            return a1;\n\n        var a1 = arguments[0];\n        var a = a2 = null;\n        var n = 1;\n        while (n < arguments.length) {\n            a = [];\n            a2 = arguments[n];\n            var l = a1.length;\n            var l2 = a2.length;\n            for (var i = 0; i < l; i++) {\n                for (var j = 0; j < l2; j++) {\n                    if (a1[i] === a2[j]) \n                        a.push(a1[i]);\n                }\n            }\n            a1 = a;\n            n++;\n        }\n        return this.unique(a);\n    },\n    \n    /**\n     * Merge two or more arrays together\n     * union(a,b,c)\n     * will return an array of items with items from all arrays, duplicate items are removed from the result\n     * @param two or more arrays\n     * @return Array\n     */\n    union: function(){\n        if (!arguments.length) \n            return [];\n        \n        var a1 = arguments[0];\n        var a = [].concat(a1);\n        var l = arguments.length;\n        var n = 1;\n        for (var i = n; i < l; i++) {\n            a = a.concat(arguments[i]);\n        }\n        return this.unique(a);\n    },\n    \n    /**\n     * Removes duplicate items from an array\n     * @param Array a1\n     * @return Array\n     */\n    unique: function(a1){\n        var a = [];\n        var l = a1.length;\n        for (var i = 0; i < l; i++) {\n            for (var j = i + 1; j < l; j++) {\n                if (a1[i] === a1[j]) \n                    j = ++i;\n            }\n            a.push(a1[i]);\n        }\n        return a;\n    },\n    \n    type: \"ArrayUtil\"\n}\n\n",
      "sys_id": "f3c130709f02210054679ff3367fcf56"
    }
  ];

  const midServerData = [
    {
      sys_id: '01d84eb60b22101088b90bdb35673af0',
      script: '604935eb02361cf224e096fed1a995fba33070eb9595597d442729b0a627fd73'
    },
    {
      sys_id: '157e428fc3023100d8d4bea192d3aefa',
      script: '3a91bf2babda93b8e849f505dc62c1ff9b1930bcc53272699035bc6613ac4c57'
    },
    {
      sys_id: '17db143bc7121010f580178603c2601f',
      script: 'b7f80d9194fdf05f39321cc783404a2bd87c37fdb5485a389bc13be6b75d00dd'
    },
    {
      sys_id: '1d53c9680a0a0b84148db3d4e1dceda3',
      script: '108e053402f752f6d9d713df0c552d4f4003e356c1d1845f440d9bc4a6da91b4'
    },
    {
      sys_id: '1d548db90a0a0b843717527b8eebc621',
      script: '5cc4d0f4914c5f4e585a4453feaf93dc04daae70baf3e6edc7ac156b69837ba2'
    },
    {
      sys_id: '1d5557480a0a0b84026940e176f072e9',
      script: '5e666ae18db22a1c49e4daeb7b6ae1caca4c5487adac8082d672fd6c1535c79e'
    },
    {
      sys_id: '1fb087ae5b33330012868473b881c77f',
      script: '2fa77ea66a1a6e8d2effc6fe1bf5699d901b09cb1865e9010807e5fc433145ee'
    },
    {
      sys_id: '2678642247012100fc856f2ccee4903b',
      script: '718c59cb0f9127c3bcfe5dfcd46afa1a664435b789c0c1b85cc4fa6ddd5e61b9'
    },
    {
      sys_id: '2eb7802893010200e4e4705bb47ffb82',
      script: 'e6c1027e6ace1c52585c5d5239aa505d2764a730976e39b537b03e6aa344f136'
    },
    {
      sys_id: '300bde7b9f21210054679ff3367fcf25',
      script: '431ffa379cf6c233abce4b2a3284ef7d7804dbd482d4342555d4d9c1212a6909'
    },
    {
      sys_id: '31ebed618f071200c2fe0b5437bdee97',
      script: 'ea9ce78c133a14de2dd15b88b3822867d0d351b87198d6d602a97ad892c1762d'
    },
    {
      sys_id: '373cd430c32121002d031f051eba8fa6',
      script: '97e4b6f901ce713ee542dcb0757a7c43f9d1e23821902c2963c500f8132d247b'
    },
    {
      sys_id: '3d34b3c593301200f81a35bb357ffb22',
      script: '2c7b6f7b66d8dede2d3e748000862967d7e1a60b8d137cf88ab42ad8f5d57808'
    },
    {
      sys_id: '3ec5e196732300102535b7385ef6a763',
      script: '15faeda8fad2e4ad0d2ba0999c4f3e69c5633e6583fc0cb16100bb4cce2543f9'
    },
    {
      sys_id: '431e983fff13330001d3cd6bd53bf1d6',
      script: '3c7e8147857825f5a4ced5eda48539f416be20cb39ae124afacd80a4ea57b574'
    },
    {
      sys_id: '44cb75427f1002003d9fbb87adfa9141',
      script: '5454ce21769be653727b5cb5ff87b2344a8a5226b1b11305572733d136ea4bd5'
    },
    {
      sys_id: '44d40559674c330018da6c706785ef4c',
      script: '4d871f698fb6cc1a252ad0f3bb38db5ee7570f38f57646e7fe063adadb856eb1'
    },
    {
      sys_id: '544bff02930b02007d8a705bb47ffbeb',
      script: '65d7f1996c8b48e472d85947a468529237047d0393507aaf5e3f402e4cf39040'
    },
    {
      sys_id: '63a7021d87633300dee3caf736cb0b3d',
      script: '58e3053a2076ee739a9588803a64cf03b59abe931c0e0bab48ec6ba5be6a978f'
    },
    {
      sys_id: '6553d09237603100dcd445cbbebe5d24',
      script: '9c345a143e85ba33ed0d13d4e5982e6896e974feb07cc0751ac08766eaa72a48'
    },
    {
      sys_id: '6c522b788f731200c2fe0b5437bdee99',
      script: 'e1759a30bc875d03a6f7bd4ca14fb5c6c61011689fc4931731da240961095f8a'
    },
    {
      sys_id: '6c5fb0ef93c31200c2fe705bb47ffbaa',
      script: '9ee857e203909bcfae4e3559b713056c38aee3186a41667ac14c995df69bb931'
    },
    {
      sys_id: '7427eb5293d10200084135bb357ffb5d',
      script: '8aa091cd129e6bd1b2947d7024ce78087ac4e0fded93b35e64445814a6a456df'
    },
    {
      sys_id: '78d5b1d20a000483009c638af616cd41',
      script: '67e677fba57c7aa3064dbbc55491b8740a8cf083a9078709f488ebbbb8d3f44e'
    },
    {
      sys_id: '7c6ff0ef93c31200c2fe705bb47ffb32',
      script: 'edc12b87d8eb4d33c328c04da007981608bd7af2b0d97ef8d63a5bb54a80e814'
    },
    {
      sys_id: '7ca74e780a0004830163988cbd58df6d',
      script: '023b3584a2cd8453b067f145c066b3a908ca2ef3846e9bb69da924cfe4ab5afc'
    },
    {
      sys_id: '7ca7e99037203100dcd445cbbebe5d48',
      script: '47e8d6694854e2d5fe21d5ce5b54f171e81236051a1e0b85cc1e3ba34768773b'
    },
    {
      sys_id: '7f33ea069f71210054679ff3367fcf41',
      script: '2e8d03a3c96fe775a727b5ee0e20ba1de99f92944b0400bdff464f376b5a5abf'
    },
    {
      sys_id: '804e7c738fd75200c2fe0b5437bdeeca',
      script: '1a38bccfeb8c3a8d26e2e12b034fc09f20c0980cf62b087386c63e830caa5f4d'
    },
    {
      sys_id: '83ebeec1c0a8019a156932ff99e06b5f',
      script: 'c7df300a237cf3b13ded2f960d201d0b39a8357f42bfb382f8ae3b06c8c98139'
    },
    {
      sys_id: '8888482893010200e4e4705bb47ffb88',
      script: 'e6fd1cdc778aa3685b7d4a20b326d6681aae62ab30235ea8d92ca4e3558c9314'
    },
    {
      sys_id: '890123c3ff0333000941cd6bd53bf189',
      script: '2d6ea87b006a4a3eeb0b6be0014ec0f67999f2221d84ada8a023efdb2f8a2f7a'
    },
    {
      sys_id: '8ba9e32d0a0a0bb0496b9f907870483d',
      script: 'da1a342aa4f61a8e623314f1fcbb421529af055a319c4143ef8ea4d76d6ceacc'
    },
    {
      sys_id: '8d290571ff2200007fe1fe51c17f9dcc',
      script: '7bd7c304cae1ae09d9d9369310a96d5e178fe661bdfd9486468ab8b42d90f4d6'
    },
    {
      sys_id: '901bde7b9f21210054679ff3367fcf99',
      script: 'e2f65b80a8f88072c12b1fb7f81ac646951ff33333367e750b3ef33195e0a36d'
    },
    {
      sys_id: '95e51ae5c0a8019a75cd1ef52db6bf36',
      script: 'ea1559ac4c6714468b04696cac7e1d759de4e8ae89fe6fbd3284030818514c89'
    },
    {
      sys_id: 'a02fde6f0a0a0beb41f18dad6e9c1a22',
      script: 'a179cf24711c67227c7aeebb9ceca04e5ec12be13827835a3272414b47c2fd45'
    },
    {
      sys_id: 'a224819b0f0323001b54fe39b4767e5d',
      script: '85febe0faa18ca241d401d4f1e5b9bdbaadb71830facd2f26ab6319161e65a13'
    },
    {
      sys_id: 'a668f2f147412100fc856f2ccee490e8',
      script: 'fc2bbb678cadf0d5e5f7b548c6a32962e6c0cd99edeca7fd316794a2ead5cb29'
    },
    {
      sys_id: 'ad8fb4ef93c31200c2fe705bb47ffb2f',
      script: '248537371c89a52485b1a4359d956c64dfd359266f29d23c6e5de6e10c56018b'
    },
    {
      sys_id: 'adb836e79f21210054679ff3367fcf13',
      script: 'a17f60eaf8be0bc8c6cc8939901727c4241568c1a80c811535e8dc37afc3620e'
    },
    {
      sys_id: 'b21ebd109f02020003f3b0aec32e709a',
      script: 'caac133b5545d586eb67f932192cd4797e574909ca7ed993e6b1f72f732df40c'
    },
    {
      sys_id: 'bb6e3cd3c0a8020100823824cbacec99',
      script: 'e3de6476e321f101fa22f8cea1d8a4518a38089e42b36ed98e1683da61e9217e'
    },
    {
      sys_id: 'bb6f9cf6c0a8020100ba345c60be2383',
      script: '3a888603fd6c36f43a4c453b470258765a8db919a83fe5f996b2f54da53c532f'
    },
    {
      sys_id: 'be27e596732300102535b7385ef6a7a5',
      script: '1ec95fddd74476f765676a44b41481e13bb1aeebc6df1944fcbc83bca1778088'
    },
    {
      sys_id: 'c41709b5531333006626ddeeff7b12fd',
      script: '045dddd9da61138976ff07eb91cb31c0c381136ca7f05009773d56c117658aa7'
    },
    {
      sys_id: 'd24260d48f1c2200c2fe0b5437bdee20',
      script: '76e4c1438b25d402de74d440356dc0a4e8e2a12afd4b2bef67f2436be5d4da7f'
    },
    {
      sys_id: 'd847c5ef93210200084135bb357ffb3c',
      script: '4f2538b390019e4d341b681b294c70adff7eb501b04e32825f473b7565a6ccd1'
    },
    {
      sys_id: 'da6fe3dac0a802010030ce326d6850d2',
      script: '47553acb3491d603040634d35603e5a6bc8658405d6a8e00cfb13fbc4b524f11'
    },
    {
      sys_id: 'db1b58349f02210054679ff3367fcfc3',
      script: '8cde9db1d116a56b3bcc455a7c8d4dc1a97ad894857c925269e3a2a6246227bc'
    },
    {
      sys_id: 'e1c0271293d10200084135bb357ffb3e',
      script: 'ed67425d1ad4b957a4a0475010b71324343ab1eba362067e1aa0ce9a1f719a82'
    },
    {
      sys_id: 'e6dfb0ef93c31200c2fe705bb47ffbae',
      script: '0e0f14372ffef5d9db031140bfa439e5f37ca394a9d384b681a1246778d7c0e4'
    },
    {
      sys_id: 'ec826c90ff230000dada679cdbffad9c',
      script: '401b3d056dd5ced3aceed2d84ae724a1b39081b7e3162d37a114f4e652137229'
    },
    {
      sys_id: 'ef8a1d4f93510200084135bb357ffbc2',
      script: '22d96a432bb12c36d7f0294ed313c4772d3074f65ad1874cf312b9f4a116f961'
    },
    {
      sys_id: 'f038ded50a0a0b3f00dd2b1b9a76e9ba',
      script: '7a46eeb6a4585d95855ba6634395dc18749d32b75acd8a83e498fc756b8f5e35'
    },
    {
      sys_id: 'f3c130709f02210054679ff3367fcf56',
      script: 'ff506d178522d88da87be514e8682e5aa7ceba9dc2b4378b9ab9f0e65df42341'
    }
  ];
  const midServerData2 = [
    {
      sys_id: '01d84eb60b22101088b90bdb35673af0',
      script: '604935eb02361cf224e096fed1a995fba33070eb9595597d442729b0a627fd73'
    },
    {
      sys_id: '157e428fc3023100d8d4bea192d3aefa',
      script: '3a91bf2babda93b8e849f505dc62c1ff9b1930bcc53272699035bc6613ac4c57'
    },
    {
      sys_id: '17db143bc7121010f580178603c2601f',
      script: 'b7f80d9194fdf05f39321cc783404a2bd87c37fdb5485a389bc13be6b75d00dd'
    },
    {
      sys_id: '1d53c9680a0a0b84148db3d4e1dceda3',
      script: '108e053402f752f6d9d713df0c552d4f4003e356c1d1845f440d9bc4a6da91b4'
    },
    {
      sys_id: '1d548db90a0a0b843717527b8eebc621',
      script: '5cc4d0f4914c5f4e585a4453feaf93dc04daae70baf3e6edc7ac156b69837ba2'
    },
    {
      sys_id: '1d5557480a0a0b84026940e176f072e9',
      script: '5e666ae18db22a1c49e4daeb7b6ae1caca4c5487adac8082d672fd6c1535c79e'
    },
    {
      sys_id: '1fb087ae5b33330012868473b881c77f',
      script: '2fa77ea66a1a6e8d2effc6fe1bf5699d901b09cb1865e9010807e5fc433145ee'
    },
    {
      sys_id: '2678642247012100fc856f2ccee4903b',
      script: '718c59cb0f9127c3bcfe5dfcd46afa1a664435b789c0c1b85cc4fa6ddd5e61b9'
    },
    {
      sys_id: '2eb7802893010200e4e4705bb47ffb82',
      script: 'e6c1027e6ace1c52585c5d5239aa505d2764a730976e39b537b03e6aa344f136'
    },
    {
      sys_id: '300bde7b9f21210054679ff3367fcf25',
      script: '431ffa379cf6c233abce4b2a3284ef7d7804dbd482d4342555d4d9c1212a6909'
    },
    {
      sys_id: '31ebed618f071200c2fe0b5437bdee97',
      script: 'ea9ce78c133a14de2dd15b88b3822867d0d351b87198d6d602a97ad892c1762d'
    },
    {
      sys_id: '373cd430c32121002d031f051eba8fa6',
      script: '97e4b6f901ce713ee542dcb0757a7c43f9d1e23821902c2963c500f8132d247b'
    },
    {
      sys_id: '3d34b3c593301200f81a35bb357ffb22',
      script: '2c7b6f7b66d8dede2d3e748000862967d7e1a60b8d137cf88ab42ad8f5d57808'
    },
    {
      sys_id: '3ec5e196732300102535b7385ef6a763',
      script: '15faeda8fad2e4ad0d2ba0999c4f3e69c5633e6583fc0cb16100bb4cce2543f9'
    },
    {
      sys_id: '431e983fff13330001d3cd6bd53bf1d6',
      script: '3c7e8147857825f5a4ced5eda48539f416be20cb39ae124afacd80a4ea57b574'
    },
    {
      sys_id: '44cb75427f1002003d9fbb87adfa9141',
      script: '5454ce21769be653727b5cb5ff87b2344a8a5226b1b11305572733d136ea4bd5'
    },
    {
      sys_id: '44d40559674c330018da6c706785ef4c',
      script: '4d871f698fb6cc1a252ad0f3bb38db5ee7570f38f57646e7fe063adadb856eb1'
    },
    {
      sys_id: '544bff02930b02007d8a705bb47ffbeb',
      script: '65d7f1996c8b48e472d85947a468529237047d0393507aaf5e3f402e4cf39040'
    },
    {
      sys_id: '63a7021d87633300dee3caf736cb0b3d',
      script: '58e3053a2076ee739a9588803a64cf03b59abe931c0e0bab48ec6ba5be6a978f'
    },
    {
      sys_id: '6553d09237603100dcd445cbbebe5d24',
      script: '9c345a143e85ba33ed0d13d4e5982e6896e974feb07cc0751ac08766eaa72a48'
    },
    {
      sys_id: '6c522b788f731200c2fe0b5437bdee99',
      script: 'e1759a30bc875d03a6f7bd4ca14fb5c6c61011689fc4931731da240961095f8a'
    },
    {
      sys_id: '6c5fb0ef93c31200c2fe705bb47ffbaa',
      script: '9ee857e203909bcfae4e3559b713056c38aee3186a41667ac14c995df69bb931'
    },
    {
      sys_id: '7427eb5293d10200084135bb357ffb5d',
      script: '8aa091cd129e6bd1b2947d7024ce78087ac4e0fded93b35e64445814a6a456df'
    },
    {
      sys_id: '78d5b1d20a000483009c638af616cd41',
      script: '67e677fba57c7aa3064dbbc55491b8740a8cf083a9078709f488ebbbb8d3f44e'
    },
    {
      sys_id: '7c6ff0ef93c31200c2fe705bb47ffb32',
      script: 'edc12b87d8eb4d33c328c04da007981608bd7af2b0d97ef8d63a5bb54a80e814'
    },
    {
      sys_id: '7ca74e780a0004830163988cbd58df6d',
      script: '023b3584a2cd8453b067f145c066b3a908ca2ef3846e9bb69da924cfe4ab5afc'
    },
    {
      sys_id: '7ca7e99037203100dcd445cbbebe5d48',
      script: '47e8d6694854e2d5fe21d5ce5b54f171e81236051a1e0b85cc1e3ba34768773b'
    },
    {
      sys_id: '7f33ea069f71210054679ff3367fcf41',
      script: '2e8d03a3c96fe775a727b5ee0e20ba1de99f92944b0400bdff464f376b5a5abf'
    },
    {
      sys_id: '804e7c738fd75200c2fe0b5437bdeeca',
      script: '1a38bccfeb8c3a8d26e2e12b034fc09f20c0980cf62b087386c63e830caa5f4d'
    },
    {
      sys_id: '83ebeec1c0a8019a156932ff99e06b5f',
      script: 'c7df300a237cf3b13ded2f960d201d0b39a8357f42bfb382f8ae3b06c8c98139'
    },
    {
      sys_id: '8888482893010200e4e4705bb47ffb88',
      script: 'e6fd1cdc778aa3685b7d4a20b326d6681aae62ab30235ea8d92ca4e3558c9314'
    },
    {
      sys_id: '890123c3ff0333000941cd6bd53bf189',
      script: '2d6ea87b006a4a3eeb0b6be0014ec0f67999f2221d84ada8a023efdb2f8a2f7a'
    },
    {
      sys_id: '8ba9e32d0a0a0bb0496b9f907870483d',
      script: 'da1a342aa4f61a8e623314f1fcbb421529af055a319c4143ef8ea4d76d6ceacc'
    },
    {
      sys_id: '8d290571ff2200007fe1fe51c17f9dcc',
      script: '7bd7c304cae1ae09d9d9369310a96d5e178fe661bdfd9486468ab8b42d90f4d6'
    },
    {
      sys_id: '901bde7b9f21210054679ff3367fcf99',
      script: 'e2f65b80a8f88072c12b1fb7f81ac646951ff33333367e750b3ef33195e0a36d'
    },
    {
      sys_id: '95e51ae5c0a8019a75cd1ef52db6bf36',
      script: 'ea1559ac4c6714468b04696cac7e1d759de4e8ae89fe6fbd3284030818514c89'
    },
    {
      sys_id: 'a02fde6f0a0a0beb41f18dad6e9c1a22',
      script: 'a179cf24711c67227c7aeebb9ceca04e5ec12be13827835a3272414b47c2fd45'
    },
    {
      sys_id: 'a224819b0f0323001b54fe39b4767e5d',
      script: '85febe0faa18ca241d401d4f1e5b9bdbaadb71830facd2f26ab6319161e65a13'
    },
    {
      sys_id: 'a668f2f147412100fc856f2ccee490e8',
      script: 'fc2bbb678cadf0d5e5f7b548c6a32962e6c0cd99edeca7fd316794a2ead5cb29'
    },
    {
      sys_id: 'ad8fb4ef93c31200c2fe705bb47ffb2f',
      script: '248537371c89a52485b1a4359d956c64dfd359266f29d23c6e5de6e10c56018b'
    },
    {
      sys_id: 'adb836e79f21210054679ff3367fcf13',
      script: 'a17f60eaf8be0bc8c6cc8939901727c4241568c1a80c811535e8dc37afc3620e'
    },
    {
      sys_id: 'b21ebd109f02020003f3b0aec32e709a',
      script: 'caac133b5545d586eb67f932192cd4797e574909ca7ed993e6b1f72f732df40c'
    },
    {
      sys_id: 'bb6e3cd3c0a8020100823824cbacec99',
      script: 'e3de6476e321f101fa22f8cea1d8a4518a38089e42b36ed98e1683da61e9217e'
    },
    {
      sys_id: 'bb6f9cf6c0a8020100ba345c60be2383',
      script: '3a888603fd6c36f43a4c453b470258765a8db919a83fe5f996b2f54da53c532f'
    },
    {
      sys_id: 'be27e596732300102535b7385ef6a7a5',
      script: '1ec95fddd74476f765676a44b41481e13bb1aeebc6df1944fcbc83bca1778088'
    },
    {
      sys_id: 'c41709b5531333006626ddeeff7b12fd',
      script: '045dddd9da61138976ff07eb91cb31c0c381136ca7f05009773d56c117658aa7'
    },
    {
      sys_id: 'd24260d48f1c2200c2fe0b5437bdee20',
      script: '76e4c1438b25d402de74d440356dc0a4e8e2a12afd4b2bef67f2436be5d4da7f'
    },
    {
      sys_id: 'd847c5ef93210200084135bb357ffb3c',
      script: '4f2538b390019e4d341b681b294c70adff7eb501b04e32825f473b7565a6ccd1'
    },
    {
      sys_id: 'da6fe3dac0a802010030ce326d6850d2',
      script: '47553acb3491d603040634d35603e5a6bc8658405d6a8e00cfb13fbc4b524f11'
    },
    {
      sys_id: 'db1b58349f02210054679ff3367fcfc3',
      script: '8cde9db1d116a56b3bcc455a7c8d4dc1a97ad894857c925269e3a2a6246227bc'
    },
    {
      sys_id: 'e1c0271293d10200084135bb357ffb3e',
      script: 'ed67425d1ad4b957a4a0475010b71324343ab1eba362067e1aa0ce9a1f719a82'
    },
    {
      sys_id: 'e6dfb0ef93c31200c2fe705bb47ffbae',
      script: '0e0f14372ffef5d9db031140bfa439e5f37ca394a9d384b681a1246778d7c0e4'
    },
    {
      sys_id: 'ec826c90ff230000dada679cdbffad9c',
      script: '401b3d056dd5ced3aceed2d84ae724a1b39081b7e3162d37a114f4e652137229'
    },
    {
      sys_id: 'ef8a1d4f93510200084135bb357ffbc2',
      script: '22d96a432bb12c36d7f0294ed313c4772d3074f65ad1874cf312b9f4a116f961'
    },
    {
      sys_id: 'f038ded50a0a0b3f00dd2b1b9a76e9ba',
      script: '7a46eeb6a4585d95855ba6634395dc18749d32b75acd8a83e498fc756b8f5e35'
    },
    {
      sys_id: 'f3c130709f02210054679ff3367fcf56',
      script: 'ff506d178522d88da87be514e8682e5aa7ceba9dc2b4378b9ab9f0e65df42341'
    }
  ];

  

  module.exports = {arrayData, midServerData, midServerData2};